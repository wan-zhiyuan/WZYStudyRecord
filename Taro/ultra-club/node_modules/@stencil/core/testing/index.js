function _lazyRequire(e) {
  return new Proxy({}, {
    get(t, s) {
      const r = require(e);
      return Reflect.get(r, s);
    },
    set(t, s, r) {
      const n = require(e);
      return Reflect.set(n, s, r);
    }
  });
}

function _interopDefault(e) {
  return e && "object" == typeof e && "default" in e ? e.default : e;
}

async function startPuppeteerBrowser(e) {
  if (!e.flags.e2e) return null;
  const t = process.env, s = e.testing.browserExecutablePath ? "puppeteer-core" : "puppeteer", r = e.sys.lazyRequire.getModulePath(s), n = require(r);
  t.__STENCIL_PUPPETEER_MODULE__ = r, t.__STENCIL_BROWSER_WAIT_UNTIL = e.testing.browserWaitUntil, 
  e.flags.devtools && (e.testing.browserDevtools = !0, e.testing.browserHeadless = !1, 
  t.__STENCIL_E2E_DEVTOOLS__ = "true"), e.logger.debug("puppeteer: " + r), e.logger.debug("puppeteer headless: " + e.testing.browserHeadless), 
  Array.isArray(e.testing.browserArgs) && e.logger.debug("puppeteer args: " + e.testing.browserArgs.join(" ")), 
  "boolean" == typeof e.testing.browserDevtools && e.logger.debug("puppeteer devtools: " + e.testing.browserDevtools), 
  "number" == typeof e.testing.browserSlowMo && e.logger.debug("puppeteer slowMo: " + e.testing.browserSlowMo);
  const i = {
    ignoreHTTPSErrors: !0,
    args: e.testing.browserArgs,
    headless: e.testing.browserHeadless,
    devtools: e.testing.browserDevtools,
    slowMo: e.testing.browserSlowMo
  };
  e.testing.browserExecutablePath && (i.executablePath = e.testing.browserExecutablePath);
  const o = await (e.testing.browserWSEndpoint ? n.connect(Object.assign(Object.assign({}, i), {
    browserWSEndpoint: e.testing.browserWSEndpoint
  })) : n.launch(Object.assign({}, i)));
  return t.__STENCIL_BROWSER_WS_ENDPOINT__ = o.wsEndpoint(), e.logger.debug("puppeteer browser wsEndpoint: " + t.__STENCIL_BROWSER_WS_ENDPOINT__), 
  o;
}

function getAppStyleUrl(e, t) {
  return e.globalStyle ? getAppUrl(e, t, e.fsNamespace + ".css") : null;
}

function getAppUrl(e, t, s) {
  const r = e.outputTargets.find(isOutputTargetWww);
  if (r) {
    const e = r.buildDir, n = path$1.join(e, s), i = path$1.relative(r.dir, n);
    return new URL(i, t).href;
  }
  const n = e.outputTargets.find(isOutputTargetDistLazy);
  if (n) {
    const r = n.esmDir, i = path$1.join(r, s), o = path$1.relative(e.rootDir, i);
    return new URL(o, t).href;
  }
  return t;
}

function setScreenshotEmulateData(e, t) {
  const s = {
    userAgent: "default",
    viewport: {
      width: 800,
      height: 600,
      deviceScaleFactor: 1,
      isMobile: !1,
      hasTouch: !1,
      isLandscape: !1
    }
  };
  if ("string" == typeof e.device) try {
    const r = require(t.__STENCIL_PUPPETEER_MODULE__ + "/DeviceDescriptors")[e.device];
    if (!r) return void console.error("invalid emulate device: " + e.device);
    s.device = e.device, s.userAgent = r.userAgent, s.viewport = r.viewport;
  } catch (e) {
    return void console.error("error loading puppeteer DeviceDescriptors", e);
  }
  e.viewport && ("number" == typeof e.viewport.width && (s.viewport.width = e.viewport.width), 
  "number" == typeof e.viewport.height && (s.viewport.height = e.viewport.height), 
  "number" == typeof e.viewport.deviceScaleFactor && (s.viewport.deviceScaleFactor = e.viewport.deviceScaleFactor), 
  "boolean" == typeof e.viewport.hasTouch && (s.viewport.hasTouch = e.viewport.hasTouch), 
  "boolean" == typeof e.viewport.isLandscape && (s.viewport.isLandscape = e.viewport.isLandscape), 
  "boolean" == typeof e.viewport.isMobile && (s.viewport.isMobile = e.viewport.isMobile), 
  "string" == typeof e.userAgent && (s.userAgent = e.userAgent)), t.__STENCIL_EMULATE__ = JSON.stringify(s);
}

async function runJest(e, t) {
  let s = !1;
  try {
    const r = function r(e, t) {
      let s = e.emulate.slice();
      if ("string" == typeof t.emulate) {
        const e = t.emulate.toLowerCase();
        s = s.filter(t => "string" == typeof t.device && t.device.toLowerCase() === e || !("string" != typeof t.userAgent || !t.userAgent.toLowerCase().includes(e)));
      }
      return s;
    }(e.testing, e.flags);
    t.__STENCIL_EMULATE_CONFIGS__ = JSON.stringify(r), e.flags.ci || e.flags.e2e ? t.__STENCIL_DEFAULT_TIMEOUT__ = "30000" : t.__STENCIL_DEFAULT_TIMEOUT__ = "15000", 
    e.flags.devtools && (t.__STENCIL_DEFAULT_TIMEOUT__ = "300000000"), e.logger.debug("default timeout: " + t.__STENCIL_DEFAULT_TIMEOUT__);
    const n = function n(e) {
      const t = require("yargs"), s = [ ...e.flags.unknownArgs.slice(), ...e.flags.knownArgs.slice() ];
      s.some(e => e.startsWith("--max-workers") || e.startsWith("--maxWorkers")) || s.push("--max-workers=" + e.maxConcurrentWorkers), 
      e.flags.devtools && s.push("--runInBand"), e.logger.info(e.logger.magenta("jest args: " + s.join(" ")));
      const {options: r} = require("jest-cli/build/cli/args"), n = t(s).options(r).argv;
      if (n.config = function i(e) {
        const t = e.testing, s = require("jest-config").defaults, r = Object.keys(s), n = {};
        return Object.keys(t).forEach(e => {
          r.includes(e) && (n[e] = t[e]);
        }), n.rootDir = e.rootDir, isString(t.collectCoverage) && (n.collectCoverage = t.collectCoverage), 
        isString(t.coverageDirectory) && (n.coverageDirectory = t.coverageDirectory), t.coverageThreshold && (n.coverageThreshold = t.coverageThreshold), 
        isString(t.globalSetup) && (n.globalSetup = t.globalSetup), isString(t.globalTeardown) && (n.globalTeardown = t.globalTeardown), 
        isString(t.preset) && (n.preset = t.preset), t.projects && (n.projects = t.projects), 
        Array.isArray(t.reporters) && (n.reporters = t.reporters), isString(t.testResultsProcessor) && (n.testResultsProcessor = t.testResultsProcessor), 
        t.transform && (n.transform = t.transform), t.verbose && (n.verbose = t.verbose), 
        JSON.stringify(n);
      }(e), "string" == typeof n.maxWorkers) try {
        n.maxWorkers = parseInt(n.maxWorkers, 10);
      } catch (e) {}
      return "string" == typeof n.ci && (n.ci = "true" === n.ci || "" === n.ci), n;
    }(e), i = function i(e, t) {
      const s = t.projects ? t.projects : [];
      return s.push(e.rootDir), s;
    }(e, n), {runCLI: o} = require("@jest/core");
    s = !!(await o(n, i)).results.success;
  } catch (t) {
    e.logger.error("runJest: " + t);
  }
  return s;
}

function createBuildId() {
  const e = new Date;
  let t = e.getFullYear() + "";
  return t += ("0" + (e.getMonth() + 1)).slice(-2), t += ("0" + e.getDate()).slice(-2), 
  t += ("0" + e.getHours()).slice(-2), t += ("0" + e.getMinutes()).slice(-2), t += ("0" + e.getSeconds()).slice(-2), 
  t;
}

function createBuildMessage() {
  const e = new Date;
  let t = e.getFullYear() + "-";
  return t += ("0" + (e.getMonth() + 1)).slice(-2) + "-", t += ("0" + e.getDate()).slice(-2) + " ", 
  t += ("0" + e.getHours()).slice(-2) + ":", t += ("0" + e.getMinutes()).slice(-2) + ":", 
  t += ("0" + e.getSeconds()).slice(-2), "Build: " + t;
}

function transpile(e, t = {}) {
  t = Object.assign(Object.assign({}, t), {
    componentExport: null,
    componentMetadata: "compilerstatic",
    coreImportPath: isString(t.coreImportPath) ? t.coreImportPath : "@stencil/core/internal/testing",
    currentDirectory: t.currentDirectory || process.cwd(),
    module: "cjs",
    proxy: null,
    sourceMap: "inline",
    style: null,
    styleImportData: "queryparams",
    target: "es2015"
  });
  try {
    const e = process.versions.node.split(".");
    parseInt(e[0], 10) >= 10 && (t.target = "es2017");
  } catch (e) {}
  return stencil_js.transpileSync(e, t);
}

function formatDiagnostic(e) {
  let t = "";
  return e.relFilePath && (t += e.relFilePath, "number" == typeof e.lineNumber && (t += ":" + e.lineNumber + 1, 
  "number" == typeof e.columnNumber && (t += ":" + e.columnNumber)), t += "\n"), t += e.messageText, 
  t;
}

function compareHtml(e, t, s) {
  if (null == e) throw new Error(`expect toEqualHtml() value is "${e}"`);
  if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
  let r;
  if (1 === e.nodeType) {
    const t = function n(e) {
      return e && e.ownerDocument && e.ownerDocument.defaultView && e.ownerDocument.defaultView.__stencil_spec_options || {};
    }(e);
    r = index_cjs_js.serializeNodeToHtml(e, {
      prettyHtml: !0,
      outerHtml: !0,
      removeHtmlComments: !1 === t.includeAnnotations,
      excludeTags: [ "body" ],
      serializeShadowRoot: s
    });
  } else if (11 === e.nodeType) r = index_cjs_js.serializeNodeToHtml(e, {
    prettyHtml: !0,
    excludeTags: [ "style" ],
    excludeTagContent: [ "style" ],
    serializeShadowRoot: s
  }); else {
    if ("string" != typeof e) throw new Error("expect toEqualHtml() value should be an element, shadow root or string.");
    {
      const t = index_cjs_js.parseHtmlToFragment(e);
      r = index_cjs_js.serializeNodeToHtml(t, {
        prettyHtml: !0,
        serializeShadowRoot: s
      });
    }
  }
  const i = index_cjs_js.parseHtmlToFragment(t), o = index_cjs_js.serializeNodeToHtml(i, {
    prettyHtml: !0,
    excludeTags: [ "body" ]
  });
  return r !== o ? (expect(r).toBe(o), {
    message: () => "HTML does not match",
    pass: !1
  }) : {
    message: () => "expect HTML to match",
    pass: !0
  };
}

function toHaveClasses(e, t) {
  if (!e) throw new Error("expect toHaveClasses value is null");
  if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
  if (1 !== e.nodeType) throw new Error("expect toHaveClasses value is not an element");
  const s = t.every(t => e.classList.contains(t));
  return {
    message: () => `expected to ${s ? "not " : ""}have css classes "${t.join(" ")}", but className is "${e.className}"`,
    pass: s
  };
}

async function globalMockFetch(e) {
  let t;
  if (null == e) throw new Error("missing url input for mock fetch()");
  if ("string" == typeof e) t = e; else {
    if ("string" != typeof e.url) throw new Error("invalid url for mock fetch()");
    t = e.url;
  }
  t = new URL(t, location.href).href;
  let s = mockedResponses.get(t);
  if (null == s) {
    const e = new URL(FETCH_DEFAULT_PATH, location.href);
    s = mockedResponses.get(e.href);
  }
  if (null == s) return new MockResponse404;
  const r = s.response.clone();
  return "number" != typeof r.status && (r.status = 200), "string" != typeof r.statusText && (r.status >= 500 ? r.statusText = "Internal Server Error" : 404 === r.status ? r.statusText = "Not Found" : r.status >= 400 ? r.statusText = "Bad Request" : 302 === r.status ? r.statusText = "Found" : 301 === r.status ? r.statusText = "Moved Permanently" : r.status >= 300 ? r.statusText = "Redirection" : r.statusText = "OK"), 
  r.ok = r.status >= 200 && r.status <= 299, "string" != typeof r.type && (r.type = "basic"), 
  r;
}

function setMockedResponse(e, t, s) {
  if (!e) throw new Error("MockResponse required");
  "string" == typeof e.url && "" !== e.url || ("string" == typeof t ? e.url = t : t && "string" == typeof t.url ? e.url = t.url : e.url = FETCH_DEFAULT_PATH);
  const r = new URL(e.url, location.href);
  e.url = r.href;
  const n = {
    response: e,
    reject: s
  };
  mockedResponses.set(e.url, n);
}

function resetBuildConditionals(e) {
  Object.keys(e).forEach(t => {
    e[t] = !0;
  }), e.isDev = !0, e.isTesting = !0, e.isDebug = !1, e.lazyLoad = !0, e.member = !0, 
  e.reflect = !0, e.scoped = !0, e.shadowDom = !0, e.slotRelocation = !0, e.asyncLoading = !0, 
  e.svg = !0, e.updatable = !0, e.vdomAttribute = !0, e.vdomClass = !0, e.vdomFunctional = !0, 
  e.vdomKey = !0, e.vdomPropOrAttr = !0, e.vdomRef = !0, e.vdomListener = !0, e.vdomStyle = !0, 
  e.vdomText = !0, e.vdomXlink = !0, e.allRenderFn = !1, e.devTools = !1, e.hydrateClientSide = !1, 
  e.hydrateServerSide = !1, e.cssAnnotations = !1, e.style = !1, e.hydratedAttribute = !1, 
  e.hydratedClass = !0, e.appendChildSlotFix = !1, e.cloneNodeFix = !1, e.dynamicImportShim = !1, 
  e.hotModuleReplacement = !1, e.safari10 = !1, e.scriptDataOpts = !1, e.slotChildNodesFix = !1;
}

function assertPath(e) {
  if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}

function normalizeStringPosix(e, t) {
  var s, r, n, i = "", o = 0, a = -1, l = 0;
  for (r = 0; r <= e.length; ++r) {
    if (r < e.length) s = e.charCodeAt(r); else {
      if (47 === s) break;
      s = 47;
    }
    if (47 === s) {
      if (a === r - 1 || 1 === l) ; else if (a !== r - 1 && 2 === l) {
        if (i.length < 2 || 2 !== o || 46 !== i.charCodeAt(i.length - 1) || 46 !== i.charCodeAt(i.length - 2)) if (i.length > 2) {
          if ((n = i.lastIndexOf("/")) !== i.length - 1) {
            -1 === n ? (i = "", o = 0) : o = (i = i.slice(0, n)).length - 1 - i.lastIndexOf("/"), 
            a = r, l = 0;
            continue;
          }
        } else if (2 === i.length || 1 === i.length) {
          i = "", o = 0, a = r, l = 0;
          continue;
        }
        t && (i.length > 0 ? i += "/.." : i = "..", o = 2);
      } else i.length > 0 ? i += "/" + e.slice(a + 1, r) : i = e.slice(a + 1, r), o = r - a - 1;
      a = r, l = 0;
    } else 46 === s && -1 !== l ? ++l : l = -1;
  }
  return i;
}

function specifierIncluded(e) {
  var t, s, r, n = e.split(" "), i = n.length > 1 ? n[0] : "=", o = (n.length > 1 ? n[1] : n[0]).split(".");
  for (t = 0; t < 3; ++t) if ((s = Number(current[t] || 0)) !== (r = Number(o[t] || 0))) return "<" === i ? s < r : ">=" === i && s >= r;
  return ">=" === i;
}

function matchesRange(e) {
  var t, s = e.split(/ ?&& ?/);
  if (0 === s.length) return !1;
  for (t = 0; t < s.length; ++t) if (!specifierIncluded(s[t])) return !1;
  return !0;
}

function versionIncluded(e) {
  if ("boolean" == typeof e) return e;
  if (e && "object" == typeof e) {
    for (var t = 0; t < e.length; ++t) if (matchesRange(e[t])) return !0;
    return !1;
  }
  return matchesRange(e);
}

function mockConfig(e) {
  const t = path$1__default.resolve("/");
  return e || (e = createTestingSystem()), e.getCurrentDirectory = () => t, {
    _isTesting: !0,
    namespace: "Testing",
    rootDir: t,
    globalScript: null,
    devMode: !0,
    enableCache: !1,
    buildAppCore: !1,
    buildDist: !0,
    flags: {},
    bundles: null,
    outputTargets: null,
    buildEs5: !1,
    hashFileNames: !1,
    logger: new TestingLogger,
    maxConcurrentWorkers: 0,
    minifyCss: !1,
    minifyJs: !1,
    sys: e,
    testing: null,
    validateTypes: !1,
    extras: {},
    nodeResolve: {
      customResolveOptions: {}
    }
  };
}

function mockCompilerCtx(e) {
  e || (e = mockConfig());
  const t = {
    version: 1,
    activeBuildId: 0,
    activeDirsAdded: [],
    activeDirsDeleted: [],
    activeFilesAdded: [],
    activeFilesDeleted: [],
    activeFilesUpdated: [],
    fs: null,
    cachedGlobalStyle: null,
    collections: [],
    compilerOptions: null,
    cache: null,
    cachedStyleMeta: new Map,
    events: null,
    fsWatcher: null,
    hasSuccessfulBuild: !1,
    isActivelyBuilding: !1,
    lastComponentStyleInput: new Map,
    lastBuildResults: null,
    lastBuildStyles: null,
    moduleMap: new Map,
    nodeMap: new WeakMap,
    resolvedCollections: new Set,
    rollupCacheHydrate: null,
    rollupCacheLazy: null,
    rollupCacheNative: null,
    rollupCache: new Map,
    rootTsFiles: [],
    styleModeNames: new Set,
    tsService: null,
    changedModules: new Set,
    changedFiles: new Set,
    reset: () => {},
    worker: stencil_js.createWorkerContext(e.sys)
  };
  return Object.defineProperty(t, "fs", {
    get() {
      return null == this._fs && (this._fs = (e => {
        const t = new Map, s = new Map, r = async e => {
          const t = g(e);
          if ("boolean" == typeof t.exists) return {
            exists: t.exists,
            isDirectory: t.isDirectory,
            isFile: t.isFile
          };
          const s = {
            exists: !1,
            isDirectory: !1,
            isFile: !1
          }, r = await l(e);
          return r ? (t.exists = r.exists, t.isDirectory = r.isDirectory, t.isFile = r.isFile, 
          s.exists = t.exists, s.isDirectory = t.isDirectory, s.isFile = t.isFile) : t.exists = !1, 
          s;
        }, n = async (e, s = {}) => {
          e = normalizePath(e);
          const r = [];
          if (!0 === s.inMemoryOnly) {
            let n = e;
            n.endsWith("/") || (n += "/");
            const i = e.split("/");
            t.forEach((t, n) => {
              if (!n.startsWith(e)) return;
              const a = n.split("/");
              if ((a.length === i.length + 1 || s.recursive && a.length > i.length) && t.exists) {
                const e = {
                  absPath: n,
                  relPath: a[i.length],
                  isDirectory: t.isDirectory,
                  isFile: t.isFile
                };
                o(s, e) || r.push(e);
              }
            });
          } else await i(e, e, s, r);
          return r.sort((e, t) => e.absPath < t.absPath ? -1 : e.absPath > t.absPath ? 1 : 0);
        }, i = async (t, s, r, n) => {
          const a = await e.readdir(s);
          if (a.length > 0) {
            const e = g(s);
            e.exists = !0, e.isFile = !1, e.isDirectory = !0, await Promise.all(a.map(async e => {
              const s = normalizePath(e), a = normalizePath(path$1.relative(t, s)), c = await l(s), u = {
                absPath: s,
                relPath: a,
                isDirectory: c.isDirectory,
                isFile: c.isFile
              };
              o(r, u) || (n.push(u), !0 === r.recursive && !0 === c.isDirectory && await i(t, s, r, n));
            }));
          }
        }, o = (e, t) => {
          if (t.isDirectory) {
            if (Array.isArray(e.excludeDirNames)) {
              const s = path$1.basename(t.absPath);
              if (e.excludeDirNames.some(e => s === e)) return !0;
            }
          } else if (Array.isArray(e.excludeExtensions)) {
            const s = t.relPath.toLowerCase();
            if (e.excludeExtensions.some(e => s.endsWith(e))) return !0;
          }
          return !1;
        }, a = async e => {
          const t = g(e);
          t.queueWriteToDisk || (t.queueDeleteFromDisk = !0);
        }, l = async t => {
          const s = g(t);
          if ("boolean" != typeof s.isDirectory || "boolean" != typeof s.isFile) {
            const r = await e.stat(t);
            r ? (s.exists = !0, r.isFile() ? (s.isFile = !0, s.isDirectory = !1, s.size = r.size) : r.isDirectory() ? (s.isFile = !1, 
            s.isDirectory = !0, s.size = r.size) : (s.isFile = !1, s.isDirectory = !1, s.size = null)) : s.exists = !1;
          }
          return {
            exists: !!s.exists,
            isFile: !!s.isFile,
            isDirectory: !!s.isDirectory,
            size: "number" == typeof s.size ? s.size : 0
          };
        }, c = t => {
          const s = g(t);
          if ("boolean" != typeof s.isDirectory || "boolean" != typeof s.isFile) {
            const r = e.statSync(t);
            r ? (s.exists = !0, r.isFile() ? (s.isFile = !0, s.isDirectory = !1, s.size = r.size) : r.isDirectory() ? (s.isFile = !1, 
            s.isDirectory = !0, s.size = r.size) : (s.isFile = !1, s.isDirectory = !1, s.size = null)) : s.exists = !1;
          }
          return {
            exists: !!s.exists,
            isFile: !!s.isFile,
            isDirectory: !!s.isDirectory
          };
        }, u = async (t, r, n) => {
          if ("string" != typeof t) throw new Error("writeFile, invalid filePath: " + t);
          if ("string" != typeof r) throw new Error("writeFile, invalid content: " + t);
          const i = {
            ignored: !1,
            changedContent: !1,
            queuedWrite: !1
          };
          if (!0 === shouldIgnore(t)) return i.ignored = !0, i;
          const o = g(t);
          if (o.exists = !0, o.isFile = !0, o.isDirectory = !1, o.queueDeleteFromDisk = !1, 
          "string" == typeof o.fileText ? i.changedContent = o.fileText.replace(/\r/g, "") !== r.replace(/\r/g, "") : i.changedContent = !0, 
          o.fileText = r, i.queuedWrite = !1, null != n && ("string" == typeof n.outputTargetType && s.set(t, n.outputTargetType), 
          !1 === n.useCache && (o.useCache = !1)), null != n && !0 === n.inMemoryOnly) o.queueWriteToDisk ? i.queuedWrite = !0 : o.queueWriteToDisk = !1, 
          await h(t, !0); else if (null != n && !0 === n.immediateWrite) {
            if (i.changedContent || !0 !== n.useCache) {
              const s = await e.readFile(t);
              "string" == typeof s && (i.changedContent = o.fileText.replace(/\r/g, "") !== s.replace(/\r/g, "")), 
              i.changedContent && (await h(t, !1), await e.writeFile(t, o.fileText));
            }
          } else o.queueWriteToDisk || !0 !== i.changedContent || (o.queueWriteToDisk = !0, 
          i.queuedWrite = !0);
          return i;
        }, h = async (e, t) => {
          const s = [];
          for (;"string" == typeof (e = path$1.dirname(e)) && e.length > 0 && "/" !== e && !1 === e.endsWith(":/") && !1 === e.endsWith(":\\"); ) s.push(e);
          s.reverse(), await d(s, t);
        }, d = async (t, s) => {
          const r = [];
          for (const n of t) {
            const t = g(n);
            if (!0 !== t.exists || !0 !== t.isDirectory) try {
              t.exists = !0, t.isDirectory = !0, t.isFile = !1, s || await e.mkdir(n), r.push(n);
            } catch (e) {}
          }
          return r;
        }, p = async t => {
          const s = g(t);
          if (null == s.fileText) throw new Error("unable to find item fileText to write: " + t);
          return await e.writeFile(t, s.fileText), !1 === s.useCache && m(t), t;
        }, f = e => {
          e = normalizePath(e), t.forEach((t, s) => {
            const r = path$1.relative(e, s).split("/")[0];
            r.startsWith(".") || r.startsWith("/") || m(s);
          });
        }, m = e => {
          e = normalizePath(e);
          const s = t.get(e);
          null == s || s.queueWriteToDisk || t.delete(e);
        }, g = e => {
          e = normalizePath(e);
          let s = t.get(e);
          return null != s || t.set(e, s = {
            exists: null,
            fileText: null,
            size: null,
            mtimeMs: null,
            isDirectory: null,
            isFile: null,
            queueCopyFileToDest: null,
            queueDeleteFromDisk: null,
            queueWriteToDisk: null,
            useCache: null
          }), s;
        };
        return {
          access: async e => (await r(e)).exists,
          accessSync: e => {
            const t = g(e);
            if ("boolean" != typeof t.exists) {
              const s = c(e);
              t.exists = s.exists, t.isDirectory = s.isDirectory, t.isFile = s.isFile;
            }
            return t.exists;
          },
          accessData: r,
          cancelDeleteDirectoriesFromDisk: e => {
            for (const t of e) {
              const e = g(t);
              !0 === e.queueDeleteFromDisk && (e.queueDeleteFromDisk = !1);
            }
          },
          cancelDeleteFilesFromDisk: e => {
            for (const t of e) {
              const e = g(t);
              !0 === e.isFile && !0 === e.queueDeleteFromDisk && (e.queueDeleteFromDisk = !1);
            }
          },
          clearCache: () => t.clear(),
          clearDirCache: f,
          clearFileCache: m,
          commit: async () => {
            const s = getCommitInstructions(t), r = await d(s.dirsToEnsure, !1), n = await (c = s.filesToWrite, 
            Promise.all(c.map(async e => {
              if ("string" != typeof e) throw new Error("unable to writeFile without filePath");
              return p(e);
            }))), i = await (l = s.filesToCopy, Promise.all(l.map(async t => {
              const s = t[0], r = t[1];
              return await e.copyFile(s, r), [ s, r ];
            }))), o = await (async t => await Promise.all(t.map(async t => {
              if ("string" != typeof t) throw new Error("unable to unlink without filePath");
              return await e.unlink(t), t;
            })))(s.filesToDelete), a = await (async t => {
              const s = [];
              for (const r of t) await e.rmdir(r), s.push(r);
              return s;
            })(s.dirsToDelete);
            var l, c;
            return s.filesToDelete.forEach(m), s.dirsToDelete.forEach(f), {
              filesCopied: i,
              filesWritten: n,
              filesDeleted: o,
              dirsDeleted: a,
              dirsAdded: r
            };
          },
          copyFile: async (e, t) => {
            g(e).queueCopyFileToDest = t;
          },
          emptyDirs: async e => {
            e = e.filter(isString).map(normalizePath).reduce((e, t) => (e.includes(t) || e.push(t), 
            e), []);
            const t = await Promise.all(e.map(e => n(e, {
              recursive: !0
            }))), s = [];
            for (const e of t) for (const t of e) s.includes(t.absPath) || s.push(t.absPath);
            s.sort((e, t) => {
              const s = e.split("/").length, r = t.split("/").length;
              return s < r ? 1 : s > r ? -1 : 0;
            }), await Promise.all(s.map(a)), e.forEach(e => {
              const t = g(e);
              t.isFile = !1, t.isDirectory = !0, t.queueWriteToDisk = !0, t.queueDeleteFromDisk = !1;
            });
          },
          getBuildOutputs: () => {
            const e = [];
            return s.forEach((t, s) => {
              const r = e.find(e => e.type === t);
              r ? r.files.push(s) : e.push({
                type: t,
                files: [ s ]
              });
            }), e.forEach(e => e.files.sort()), e.sort((e, t) => e.type < t.type ? -1 : e.type > t.type ? 1 : 0);
          },
          getItem: g,
          getMemoryStats: () => "data length: " + t.size,
          keys: () => Array.from(t.keys()).sort(),
          readFile: async (t, s) => {
            if (null == s || !0 === s.useCache || void 0 === s.useCache) {
              const e = g(t);
              if (e.exists && "string" == typeof e.fileText) return e.fileText;
            }
            const r = await e.readFile(t), n = g(t);
            return "string" == typeof r ? r.length < 5242880 && (n.exists = !0, n.isFile = !0, 
            n.isDirectory = !1, n.fileText = r) : n.exists = !1, r;
          },
          readFileSync: (t, s) => {
            if (null == s || !0 === s.useCache || void 0 === s.useCache) {
              const e = g(t);
              if (e.exists && "string" == typeof e.fileText) return e.fileText;
            }
            const r = e.readFileSync(t), n = g(t);
            return "string" == typeof r ? r.length < 5242880 && (n.exists = !0, n.isFile = !0, 
            n.isDirectory = !1, n.fileText = r) : n.exists = !1, r;
          },
          readdir: n,
          remove: async e => {
            const t = await l(e);
            !0 === t.isDirectory ? await (async e => {
              const t = g(e);
              t.isFile = !1, t.isDirectory = !0, t.queueWriteToDisk || (t.queueDeleteFromDisk = !0);
              try {
                const t = await n(e, {
                  recursive: !0
                });
                await Promise.all(t.map(e => e.relPath.endsWith(".gitkeep") ? null : a(e.absPath)));
              } catch (e) {}
            })(e) : !0 === t.isFile && await a(e);
          },
          stat: l,
          statSync: c,
          sys: e,
          writeFile: u,
          writeFiles: (e, t) => {
            const s = [];
            return isIterable(e) ? e.forEach((e, r) => {
              s.push(u(r, e, t));
            }) : Object.keys(e).map(r => {
              s.push(u(r, e[r], t));
            }), Promise.all(s);
          }
        };
      })(e.sys)), this._fs;
    }
  }), Object.defineProperty(t, "cache", {
    get() {
      return null == this._cache && (this._cache = function s(e, t) {
        e || (e = mockConfig()), t || (t = mockCompilerCtx(e)), e.enableCache = !0;
        const s = new Cache(e, t.fs);
        return s.initCacheDir(), s;
      }(e, t)), this._cache;
    }
  }), t;
}

async function initPageEvents(e) {
  e._e2eEvents = new Map, e._e2eEventIds = 0, e.spyOnEvent = pageSpyOnEvent.bind(e, e), 
  await e.exposeFunction("stencilOnEvent", (t, s) => {
    !function r(e, t, s) {
      const r = e.get(t);
      r && r.callback(s);
    }(e._e2eEvents, t, s);
  }), await e.evaluateOnNewDocument(browserContextEvents);
}

async function pageSpyOnEvent(e, t, s) {
  const r = new EventSpy(t), n = "document" !== s ? () => window : () => document, i = await e.evaluateHandle(n);
  return await addE2EListener(e, i, t, e => {
    r.push(e);
  }), r;
}

async function waitForEvent(e, t, s) {
  const r = .5 * jasmine.DEFAULT_TIMEOUT_INTERVAL, n = await e.evaluate((e, t, s) => new Promise((r, n) => {
    const i = setTimeout(() => {
      n(new Error("waitForEvent() timeout, eventName: " + t));
    }, s);
    e.addEventListener(t, e => {
      clearTimeout(i), r(window.stencilSerializeEvent(e));
    }, {
      once: !0
    });
  }), s, t, r);
  return await e.waitForChanges(), n;
}

async function addE2EListener(e, t, s, r) {
  const n = e._e2eEventIds++;
  e._e2eEvents.set(n, {
    eventName: s,
    callback: r
  });
  const i = t.executionContext();
  await i.evaluate((e, t, s) => {
    e.addEventListener(s, e => {
      window.stencilOnEvent(t, window.stencilSerializeEvent(e));
    });
  }, t, n, s);
}

function browserContextEvents() {
  const e = () => {
    const e = [], t = (e, s) => {
      if (null != s && 1 === s.nodeType) for (let r = 0; r < s.children.length; r++) {
        const n = s.children[r];
        n.tagName.includes("-") && "function" == typeof n.componentOnReady && e.push(n.componentOnReady()), 
        t(e, n);
      }
    };
    return t(e, window.document.documentElement), Promise.all(e).catch(e => console.error(e));
  }, t = () => e().then(() => new Promise(e => {
    requestAnimationFrame(e);
  })).then(() => e()).then(() => {
    window.stencilAppLoaded = !0;
  });
  window.stencilSerializeEventTarget = e => e ? e === window ? {
    serializedWindow: !0
  } : e === document ? {
    serializedDocument: !0
  } : null != e.nodeType ? {
    serializedElement: !0,
    nodeName: e.nodeName,
    nodeValue: e.nodeValue,
    nodeType: e.nodeType,
    tagName: e.tagName,
    className: e.className,
    id: e.id
  } : null : null, window.stencilSerializeEvent = e => ({
    bubbles: e.bubbles,
    cancelBubble: e.cancelBubble,
    cancelable: e.cancelable,
    composed: e.composed,
    currentTarget: window.stencilSerializeEventTarget(e.currentTarget),
    defaultPrevented: e.defaultPrevented,
    detail: e.detail,
    eventPhase: e.eventPhase,
    isTrusted: e.isTrusted,
    returnValue: e.returnValue,
    srcElement: window.stencilSerializeEventTarget(e.srcElement),
    target: window.stencilSerializeEventTarget(e.target),
    timeStamp: e.timeStamp,
    type: e.type,
    isSerializedEvent: !0
  }), "complete" === window.document.readyState ? t() : document.addEventListener("readystatechange", (function(e) {
    "complete" == e.target.readyState && t();
  }));
}

async function find(e, t, s) {
  const {lightSelector: r, shadowSelector: n, text: i, contains: o} = getSelector(s);
  let a;
  if (a = "string" == typeof r ? await async function l(e, t, s, r) {
    let n = await t.$(s);
    if (!n) return null;
    if (r) {
      const t = await e.evaluateHandle((e, t) => {
        if (!e.shadowRoot) throw new Error("shadow root does not exist for element: " + e.tagName.toLowerCase());
        return e.shadowRoot.querySelector(t);
      }, n, r);
      if (await n.dispose(), !t) return null;
      n = t.asElement();
    }
    return n;
  }(e, t, r, n) : await async function c(e, t, s, r) {
    const n = await e.evaluateHandle((e, t, s) => {
      let r = null;
      return function e(n) {
        if (n && !r) if (3 === n.nodeType) {
          if ("string" == typeof t && n.textContent.trim() === t) return void (r = n.parentElement);
          if ("string" == typeof s && n.textContent.includes(s)) return void (r = n.parentElement);
        } else {
          if ("SCRIPT" === n.nodeName || "STYLE" === n.nodeName) return;
          if (e(n.shadowRoot), n.childNodes) for (let t = 0; t < n.childNodes.length; t++) e(n.childNodes[t]);
        }
      }(e), r;
    }, t, s, r);
    return n ? n.asElement() : null;
  }(e, t, i, o), !a) return null;
  const u = new E2EElement(e, a);
  return await u.e2eSync(), u;
}

async function findAll(e, t, s) {
  const r = [], {lightSelector: n, shadowSelector: i} = getSelector(s), o = await t.$$(n);
  if (0 === o.length) return r;
  if (i) for (let t = 0; t < o.length; t++) {
    const s = o[t].executionContext(), n = await s.evaluateHandle((e, t) => {
      if (!e.shadowRoot) throw new Error("shadow root does not exist for element: " + e.tagName.toLowerCase());
      return e.shadowRoot.querySelectorAll(t);
    }, o[t], i);
    await o[t].dispose();
    const a = await n.getProperties();
    await n.dispose();
    for (const t of a.values()) {
      const s = t.asElement();
      if (s) {
        const t = new E2EElement(e, s);
        await t.e2eSync(), r.push(t);
      }
    }
  } else for (let t = 0; t < o.length; t++) {
    const s = new E2EElement(e, o[t]);
    await s.e2eSync(), r.push(s);
  }
  return r;
}

function getSelector(e) {
  const t = {
    lightSelector: null,
    shadowSelector: null,
    text: null,
    contains: null
  };
  if ("string" == typeof e) {
    const s = e.split(">>>");
    t.lightSelector = s[0].trim(), t.shadowSelector = s.length > 1 ? s[1].trim() : null;
  } else if ("string" == typeof e.text) t.text = e.text.trim(); else {
    if ("string" != typeof e.contains) throw new Error("invalid find selector: " + e);
    t.contains = e.contains.trim();
  }
  return t;
}

async function writeScreenshotData(e, t) {
  const s = function r(e, t) {
    const s = t + ".json";
    return path$1__default.join(e, s);
  }(e, t.id), n = JSON.stringify(t, null, 2);
  await writeFile(s, n);
}

function writeFile(e, t) {
  return new Promise((s, r) => {
    fs$1.writeFile(e, t, e => {
      e ? r(e) : s();
    });
  });
}

async function compareScreenshot(e, t, s, r, n, i, o, a) {
  const l = crypto$2.createHash("md5").update(s).digest("hex") + ".png", c = path$1.join(t.imagesDir, l);
  await async function u(e, t) {
    await function s(e) {
      return new Promise(t => {
        fs$1.access(e, e => t(!e));
      });
    }(e) || await writeFile(e, t);
  }(c, s), s = null, o && (o = normalizePath(path$1.relative(t.rootDir, o)));
  const h = function d(e, t) {
    if ("string" != typeof t || 0 === t.trim().length) throw new Error("invalid test description");
    const s = crypto$2.createHash("md5");
    return s.update(t + ":"), s.update(e.userAgent + ":"), s.update(e.viewport.width + ":"), 
    s.update(e.viewport.height + ":"), s.update(e.viewport.deviceScaleFactor + ":"), 
    s.update(e.viewport.hasTouch + ":"), s.update(e.viewport.isMobile + ":"), s.digest("hex").substr(0, 8).toLowerCase();
  }(e, r), p = {
    id: h,
    image: l,
    device: e.device,
    userAgent: e.userAgent,
    desc: r,
    testPath: o,
    width: n,
    height: i,
    deviceScaleFactor: e.viewport.deviceScaleFactor,
    hasTouch: e.viewport.hasTouch,
    isLandscape: e.viewport.isLandscape,
    isMobile: e.viewport.isMobile,
    diff: {
      id: h,
      desc: r,
      imageA: l,
      imageB: l,
      mismatchedPixels: 0,
      device: e.device,
      userAgent: e.userAgent,
      width: n,
      height: i,
      deviceScaleFactor: e.viewport.deviceScaleFactor,
      hasTouch: e.viewport.hasTouch,
      isLandscape: e.viewport.isLandscape,
      isMobile: e.viewport.isMobile,
      allowableMismatchedPixels: t.allowableMismatchedPixels,
      allowableMismatchedRatio: t.allowableMismatchedRatio,
      testPath: o
    }
  };
  if (t.updateMaster) return await writeScreenshotData(t.currentBuildDir, p), p.diff;
  const f = t.masterScreenshots[p.id];
  if (!f) return await writeScreenshotData(t.currentBuildDir, p), p.diff;
  if (p.diff.imageA = f, p.diff.imageA !== p.diff.imageB) {
    p.diff.cacheKey = function m(e, t, s) {
      const r = crypto$2.createHash("md5");
      return r.update(`${e}:${t}:${s}`), r.digest("hex").substr(0, 10);
    }(p.diff.imageA, p.diff.imageB, a);
    const s = t.cache[p.diff.cacheKey];
    if ("number" != typeof s || isNaN(s)) {
      const s = Math.round(e.viewport.width * e.viewport.deviceScaleFactor), r = Math.round(e.viewport.height * e.viewport.deviceScaleFactor), n = {
        imageAPath: path$1.join(t.imagesDir, p.diff.imageA),
        imageBPath: path$1.join(t.imagesDir, p.diff.imageB),
        width: s,
        height: r,
        pixelmatchThreshold: a
      };
      p.diff.mismatchedPixels = await async function g(e, t) {
        return new Promise((s, r) => {
          const n = .5 * jasmine.DEFAULT_TIMEOUT_INTERVAL, i = setTimeout(() => {
            r(`getMismatchedPixels timeout: ${n}ms`);
          }, n);
          try {
            const n = {
              execArgv: process.execArgv.filter(e => !/^--(debug|inspect)/.test(e)),
              env: process.env,
              cwd: process.cwd(),
              stdio: [ "pipe", "pipe", "pipe", "ipc" ]
            }, o = child_process$1.fork(e, [], n);
            o.on("message", e => {
              o.kill(), clearTimeout(i), s(e);
            }), o.on("error", e => {
              clearTimeout(i), r(e);
            }), o.send(t);
          } catch (e) {
            clearTimeout(i), r("getMismatchedPixels error: " + e);
          }
        });
      }(t.pixelmatchModulePath, n);
    } else p.diff.mismatchedPixels = s;
  }
  return await writeScreenshotData(t.currentBuildDir, p), p.diff;
}

async function e2eGoTo(e, t, s = {}) {
  if (e.isClosed()) throw new Error("e2eGoTo unavailable: page already closed");
  if ("string" != typeof t) throw new Error("invalid gotoTest() url");
  if (!t.startsWith("/")) throw new Error("gotoTest() url must start with /");
  const r = env.__STENCIL_BROWSER_URL__;
  if ("string" != typeof r) throw new Error("invalid gotoTest() browser url");
  const n = r + t.substring(1);
  s.waitUntil || (s.waitUntil = env.__STENCIL_BROWSER_WAIT_UNTIL);
  const i = await e._e2eGoto(n, s);
  if (!i.ok()) throw new Error(`Testing unable to load ${t}, HTTP status: ${i.status()}`);
  return await waitForStencil(e), i;
}

async function e2eSetContent(e, t, s = {}) {
  if (e.isClosed()) throw new Error("e2eSetContent unavailable: page already closed");
  if ("string" != typeof t) throw new Error("invalid e2eSetContent() html");
  const r = [], n = env.__STENCIL_APP_SCRIPT_URL__;
  if ("string" != typeof n) throw new Error("invalid e2eSetContent() app script url");
  r.push("<!doctype html>"), r.push("<html>"), r.push("<head>");
  const i = env.__STENCIL_APP_STYLE_URL__;
  "string" == typeof i && r.push(`<link rel="stylesheet" href="${i}">`), r.push(`<script type="module" src="${n}"><\/script>`), 
  r.push("</head>"), r.push("<body>"), r.push(t), r.push("</body>"), r.push("</html>");
  const o = env.__STENCIL_BROWSER_URL__;
  await e.setRequestInterception(!0), e.on("request", e => {
    o === e.url() ? e.respond({
      status: 200,
      contentType: "text/html",
      body: r.join("\n")
    }) : e.continue();
  }), s.waitUntil || (s.waitUntil = env.__STENCIL_BROWSER_WAIT_UNTIL);
  const a = await e._e2eGoto(o, s);
  if (!a.ok()) throw new Error("Testing unable to load content");
  return await waitForStencil(e), a;
}

async function waitForStencil(e) {
  try {
    await e.waitForFunction("window.stencilAppLoaded", {
      timeout: 4750
    });
  } catch (e) {
    throw new Error("App did not load in allowed time. Please ensure the content loads a stencil application.");
  }
}

async function waitForChanges(e) {
  try {
    if (e.isClosed()) return;
    if (await Promise.all(e._e2eElements.map(e => e.e2eRunActions())), e.isClosed()) return;
    if (await e.evaluate(() => new Promise(e => {
      requestAnimationFrame(() => {
        const t = [], s = (e, t) => {
          if (null != e) {
            "shadowRoot" in e && e.shadowRoot instanceof ShadowRoot && s(e.shadowRoot, t);
            const r = e.children, n = r.length;
            for (let e = 0; e < n; e++) {
              const n = r[e];
              null != n && (n.tagName.includes("-") && "function" == typeof n.componentOnReady && t.push(n.componentOnReady()), 
              s(n, t));
            }
          }
        };
        s(document.documentElement, t), Promise.all(t).then(() => {
          e();
        }).catch(() => {
          e();
        });
      });
    })), e.isClosed()) return;
    await e.waitFor(100), await Promise.all(e._e2eElements.map(e => e.e2eSync()));
  } catch (e) {}
}

function serializeConsoleMessage(e) {
  return `${e.text()} ${function t(e) {
    let t = "";
    return e && e.url && (t = "\nLocation: " + e.url, e.lineNumber && (t += ":" + e.lineNumber), 
    e.columnNumber && (t += ":" + e.columnNumber)), t;
  }(e.location())}`;
}

var posix, pathBrowserify, caller, pathParse, parse, getNodeModulesDirs, nodeModulesPaths, normalizeOptions, current, core$2, mod, core_1, isCore, realpathFS, defaultIsFile, defaultIsDir, defaultRealpath, maybeRealpath, getPackageCandidates, async, realpathFS$1, defaultIsFile$1, defaultIsDir$1, defaultRealpathSync, maybeRealpathSync, getPackageCandidates$1, sync, resolve;

const path$1 = require("path"), path$1__default = _interopDefault(path$1), index_js = _lazyRequire("../dev-server/index.js"), stencil_js = require("../compiler/stencil.js"), ts = _interopDefault(require("typescript")), appData = _lazyRequire("@stencil/core/internal/app-data"), index_cjs_js = _lazyRequire("../mock-doc/index.cjs.js"), testing = _lazyRequire("@stencil/core/internal/testing"), fs$1 = _interopDefault(require("fs")), crypto$2 = require("crypto"), child_process$1 = require("child_process"), isFunction = e => "function" == typeof e, isString = e => "string" == typeof e, isIterable = e => (e => null != e)(e) && isFunction(e[Symbol.iterator]), IS_DENO_ENV = "undefined" != typeof Deno, IS_NODE_ENV = !(IS_DENO_ENV || "undefined" == typeof global || "function" != typeof require || !global.process || "string" != typeof __filename || global.origin && "string" == typeof global.origin), IS_BROWSER_ENV = (IS_DENO_ENV && Deno.build.os, 
IS_NODE_ENV && global.process.platform, "undefined" != typeof location && "undefined" != typeof navigator && "undefined" != typeof XMLHttpRequest), IS_WEB_WORKER_ENV = IS_BROWSER_ENV && "undefined" != typeof self && "function" == typeof self.importScripts, HAS_WEB_WORKER = IS_BROWSER_ENV && "function" == typeof Worker, IS_FETCH_ENV = "function" == typeof fetch, formatComponentRuntimeMeta = (IS_NODE_ENV ? process.cwd : IS_DENO_ENV && Deno.cwd, 
IS_NODE_ENV ? process.exit : IS_DENO_ENV && Deno.exit, (e, t) => {
  let s = 0;
  "shadow" === e.encapsulation ? (s |= 1, e.shadowDelegatesFocus && (s |= 16)) : "scoped" === e.encapsulation && (s |= 2), 
  "shadow" !== e.encapsulation && e.htmlTagNames.includes("slot") && (s |= 4), e.hasMode && (s |= 32);
  const r = formatComponentRuntimeMembers(e, t), n = formatHostListeners(e);
  return trimFalsy([ s, e.tagName, Object.keys(r).length > 0 ? r : void 0, n.length > 0 ? n : void 0 ]);
}), formatComponentRuntimeMembers = (e, t = !0) => Object.assign(Object.assign(Object.assign({}, formatPropertiesRuntimeMember(e.properties)), formatStatesRuntimeMember(e.states)), t ? formatMethodsRuntimeMember(e.methods) : {}), formatPropertiesRuntimeMember = e => {
  const t = {};
  return e.forEach(e => {
    t[e.name] = trimFalsy([ formatFlags(e), formatAttrName(e) ]);
  }), t;
}, formatFlags = e => {
  let t = formatPropType(e.type);
  return e.mutable && (t |= 1024), e.reflect && (t |= 512), t;
}, formatAttrName = e => {
  if ("string" == typeof e.attribute) {
    if (e.name === e.attribute) return;
    return e.attribute;
  }
}, formatPropType = e => "string" === e ? 1 : "number" === e ? 2 : "boolean" === e ? 4 : "any" === e ? 8 : 16, formatStatesRuntimeMember = e => {
  const t = {};
  return e.forEach(e => {
    t[e.name] = [ 32 ];
  }), t;
}, formatMethodsRuntimeMember = e => {
  const t = {};
  return e.forEach(e => {
    t[e.name] = [ 64 ];
  }), t;
}, formatHostListeners = e => e.listeners.map(e => [ computeListenerFlags(e), e.name, e.method ]), computeListenerFlags = e => {
  let t = 0;
  switch (e.capture && (t |= 2), e.passive && (t |= 1), e.target) {
   case "document":
    t |= 4;
    break;

   case "window":
    t |= 8;
    break;

   case "parent":
    t |= 16;
    break;

   case "body":
    t |= 32;
  }
  return t;
}, trimFalsy = e => {
  const t = e;
  for (var s = t.length - 1; s >= 0 && !t[s]; s--) t.pop();
  return t;
}, windowsPathRegex = /^(?:[a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?[\\/]$/, hasError = e => null != e && 0 !== e.length && e.some(e => "error" === e.level && "runtime" !== e.type), normalizePath = e => {
  if ("string" != typeof e) throw new Error("invalid path to normalize");
  e = normalizeSlashes(e.trim());
  const t = pathComponents(e, getRootLength(e)), s = reducePathComponents(t), r = s[0], n = s[1], i = r + s.slice(1).join("/");
  return "" === i ? "." : "" === r && n && e.includes("/") && !n.startsWith(".") && !n.startsWith("@") ? "./" + i : i;
}, normalizeSlashes = e => e.replace(backslashRegExp, "/"), backslashRegExp = /\\/g, reducePathComponents = e => {
  if (!Array.isArray(e) || 0 === e.length) return [];
  const t = [ e[0] ];
  for (let s = 1; s < e.length; s++) {
    const r = e[s];
    if (r && "." !== r) {
      if (".." === r) if (t.length > 1) {
        if (".." !== t[t.length - 1]) {
          t.pop();
          continue;
        }
      } else if (t[0]) continue;
      t.push(r);
    }
  }
  return t;
}, getRootLength = e => {
  const t = getEncodedRootLength(e);
  return t < 0 ? ~t : t;
}, getEncodedRootLength = e => {
  if (!e) return 0;
  const t = e.charCodeAt(0);
  if (47 === t || 92 === t) {
    if (e.charCodeAt(1) !== t) return 1;
    const s = e.indexOf(47 === t ? "/" : "\\", 2);
    return s < 0 ? e.length : s + 1;
  }
  if (isVolumeCharacter(t) && 58 === e.charCodeAt(1)) {
    const t = e.charCodeAt(2);
    if (47 === t || 92 === t) return 3;
    if (2 === e.length) return 2;
  }
  const s = e.indexOf("://");
  if (-1 !== s) {
    const t = s + "://".length, r = e.indexOf("/", t);
    if (-1 !== r) {
      const n = e.slice(0, s), i = e.slice(t, r);
      if ("file" === n && ("" === i || "localhost" === i) && isVolumeCharacter(e.charCodeAt(r + 1))) {
        const t = getFileUrlVolumeSeparatorEnd(e, r + 2);
        if (-1 !== t) {
          if (47 === e.charCodeAt(t)) return ~(t + 1);
          if (t === e.length) return ~t;
        }
      }
      return ~(r + 1);
    }
    return ~e.length;
  }
  return 0;
}, isVolumeCharacter = e => e >= 97 && e <= 122 || e >= 65 && e <= 90, getFileUrlVolumeSeparatorEnd = (e, t) => {
  const s = e.charCodeAt(t);
  if (58 === s) return t + 1;
  if (37 === s && 51 === e.charCodeAt(t + 1)) {
    const s = e.charCodeAt(t + 2);
    if (97 === s || 65 === s) return t + 3;
  }
  return -1;
}, pathComponents = (e, t) => {
  const s = e.substring(0, t), r = e.substring(t).split("/"), n = r.length;
  return n > 0 && !r[n - 1] && r.pop(), [ s, ...r ];
}, normalizeFsPath = e => normalizePath(e.split("?")[0].replace(/\0/g, "")), flattenDiagnosticMessageText = (e, t) => {
  if ("string" == typeof t) return t;
  if (void 0 === t) return "";
  const s = [], r = e.file.fileName.includes("stencil.config");
  r && s.push(2322);
  let n = "";
  if (!s.includes(t.code) && (n = t.messageText, isIterable(t.next))) for (const s of t.next) n += flattenDiagnosticMessageText(e, s);
  return r && (n = n.replace("type 'StencilConfig'", "Stencil Config"), n = n.replace("Object literal may only specify known properties, but ", ""), 
  n = n.replace("Object literal may only specify known properties, and ", "")), n.trim();
}, isOutputTargetDistLazy = e => e.type === DIST_LAZY, isOutputTargetWww = e => e.type === WWW, DIST_LAZY = "dist-lazy", WWW = "www", jestPreprocessor = {
  process(e, t, s) {
    if (function r(e, t) {
      const s = e.split(".").pop().toLowerCase().split("?")[0];
      if ("ts" === s || "tsx" === s || "jsx" === s) return !0;
      if ("mjs" === s) return !0;
      if ("js" === s) {
        if (t.includes("import ") || t.includes("import.") || t.includes("import(")) return !0;
        if (t.includes("export ")) return !0;
      }
      return "css" === s;
    }(t, e)) {
      const r = {
        file: t,
        currentDirectory: s.rootDir
      }, n = this.getCompilerOptions(s.rootDir);
      n && (n.baseUrl && (r.baseUrl = n.baseUrl), n.paths && (r.paths = n.paths));
      const i = transpile(e, r), o = i.diagnostics.some(e => "error" === e.level);
      if (i.diagnostics && o) {
        const e = i.diagnostics.map(formatDiagnostic).join("\n\n");
        throw new Error(e);
      }
      return i.code;
    }
    return e;
  },
  getCompilerOptions(e) {
    return this._tsCompilerOptions || (this._tsCompilerOptions = function t(e) {
      if ("string" != typeof e) return null;
      e = normalizePath(e);
      const t = ts.findConfigFile(e, ts.sys.fileExists);
      if (!t) return null;
      const s = ts.readConfigFile(t, ts.sys.readFile);
      if (s.error) throw new Error(formatDiagnostic((e => {
        const t = {
          level: "warn",
          type: "typescript",
          language: "typescript",
          header: "TypeScript",
          code: e.code.toString(),
          messageText: flattenDiagnosticMessageText(e, e.messageText),
          relFilePath: null,
          absFilePath: null,
          lines: []
        };
        if (1 === e.category && (t.level = "error"), e.file) {
          t.absFilePath = e.file.fileName;
          const r = "string" != typeof (s = e.file.text) ? [] : (s = s.replace(/\\r/g, "\n")).split("\n"), n = e.file.getLineAndCharacterOfPosition(e.start), i = {
            lineIndex: n.line,
            lineNumber: n.line + 1,
            text: r[n.line],
            errorCharStart: n.character,
            errorLength: Math.max(e.length, 1)
          };
          if (t.lineNumber = i.lineNumber, t.columnNumber = i.errorCharStart + 1, t.lines.push(i), 
          0 === i.errorLength && i.errorCharStart > 0 && (i.errorLength = 1, i.errorCharStart--), 
          i.lineIndex > 0) {
            const e = {
              lineIndex: i.lineIndex - 1,
              lineNumber: i.lineNumber - 1,
              text: r[i.lineIndex - 1],
              errorCharStart: -1,
              errorLength: -1
            };
            t.lines.unshift(e);
          }
          if (i.lineIndex + 1 < r.length) {
            const e = {
              lineIndex: i.lineIndex + 1,
              lineNumber: i.lineNumber + 1,
              text: r[i.lineIndex + 1],
              errorCharStart: -1,
              errorLength: -1
            };
            t.lines.push(e);
          }
        }
        var s;
        return t;
      })(s.error)));
      return ts.parseJsonConfigFileContent(s.config, ts.sys, e, void 0, t).options;
    }(e)), this._tsCompilerOptions;
  },
  getCacheKey(e, t, s, r) {
    if (!this._tsCompilerOptionsKey) {
      const e = this.getCompilerOptions(r.rootDir);
      this._tsCompilerOptionsKey = JSON.stringify(e);
    }
    return [ process.version, this._tsCompilerOptionsKey, e, t, s, !!r.instrument, 5 ].join(":");
  }
}, deepEqual = function e(t, s) {
  var r, n, i, o, a, l, c, u, h, d;
  if (t === s) return !0;
  if (t && s && "object" == typeof t && "object" == typeof s) {
    if (r = Array.isArray(t), n = Array.isArray(s), r && n) {
      if ((o = t.length) != s.length) return !1;
      for (i = o; 0 != i--; ) if (!e(t[i], s[i])) return !1;
      return !0;
    }
    if (r != n) return !1;
    if ((l = t instanceof Date) != (c = s instanceof Date)) return !1;
    if (l && c) return t.getTime() == s.getTime();
    if ((u = t instanceof RegExp) != (h = s instanceof RegExp)) return !1;
    if (u && h) return t.toString() == s.toString();
    if ((o = (d = Object.keys(t)).length) !== Object.keys(s).length) return !1;
    for (i = o; 0 != i--; ) if (!Object.prototype.hasOwnProperty.call(s, d[i])) return !1;
    for (i = o; 0 != i--; ) if (!e(t[a = d[i]], s[a])) return !1;
    return !0;
  }
  return t != t && s != s;
}, expectExtend = {
  toEqualAttribute: function toEqualAttribute(e, t, s) {
    if (!e) throw new Error("expect toMatchAttribute value is null");
    if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
    if (1 !== e.nodeType) throw new Error("expect toMatchAttribute value is not an element");
    let r = e.getAttribute(t);
    null != s && (s = String(s)), null != r && (r = String(r));
    const n = s === r;
    return {
      message: () => `expected attribute ${t} "${s}" to ${n ? "not " : ""}equal "${r}"`,
      pass: n
    };
  },
  toEqualAttributes: function toEqualAttributes(e, t) {
    if (!e) throw new Error("expect toEqualAttributes value is null");
    if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
    if (1 !== e.nodeType) throw new Error("expect toEqualAttributes value is not an element");
    const s = Object.keys(t), r = s.every(s => {
      let r = t[s];
      return null != r && (r = String(r)), e.getAttribute(s) === r;
    });
    return {
      message: () => `expected attributes to ${r ? "not " : ""}equal ${s.map(e => `[${e}="${t[e]}"]`).join(", ")}`,
      pass: r
    };
  },
  toEqualHtml: function toEqualHtml(e, t) {
    return compareHtml(e, t, !0);
  },
  toEqualLightHtml: function toEqualLightHtml(e, t) {
    return compareHtml(e, t, !1);
  },
  toEqualText: function toEqualText(e, t) {
    if (null == e) throw new Error(`expect toEqualText() value is "${e}"`);
    if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
    let s;
    1 === e.nodeType ? s = e.textContent.replace(/\s\s+/g, " ").trim() : null != e && (s = String(e).replace(/\s\s+/g, " ").trim()), 
    "string" == typeof t && (t = t.replace(/\s\s+/g, " ").trim());
    const r = s === t;
    return {
      message: () => `expected textContent "${t}" to ${r ? "not " : ""}equal "${s}"`,
      pass: r
    };
  },
  toHaveAttribute: function toHaveAttribute(e, t) {
    if (!e) throw new Error("expect toHaveAttribute value is null");
    if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
    if (1 !== e.nodeType) throw new Error("expect toHaveAttribute value is not an element");
    const s = e.hasAttribute(t);
    return {
      message: () => `expected to ${s ? "not " : ""}have the attribute "${t}"`,
      pass: s
    };
  },
  toHaveClass: function toHaveClass(e, t) {
    if (!e) throw new Error("expect toHaveClass value is null");
    if ("function" == typeof e.then) throw new Error("element must be a resolved value, not a promise, before it can be tested");
    if (1 !== e.nodeType) throw new Error("expect toHaveClass value is not an element");
    const s = e.classList.contains(t);
    return {
      message: () => `expected to ${s ? "not " : ""}have css class "${t}"`,
      pass: s
    };
  },
  toHaveClasses,
  toMatchClasses: function toMatchClasses(e, t) {
    let {pass: s} = toHaveClasses(e, t);
    return s && (s = t.length === e.classList.length), {
      message: () => `expected to ${s ? "not " : ""}match css classes "${t.join(" ")}", but className is "${e.className}"`,
      pass: s
    };
  },
  toHaveReceivedEvent: function toHaveReceivedEvent(e) {
    if (!e) throw new Error("toHaveReceivedEvent event spy is null");
    if ("function" == typeof e.then) throw new Error("event spy must be a resolved value, not a promise, before it can be tested");
    if (!e.eventName) throw new Error("toHaveReceivedEvent did not receive an event spy");
    const t = e.events.length > 0;
    return {
      message: () => `expected to have ${t ? "not " : ""}called "${e.eventName}" event`,
      pass: t
    };
  },
  toHaveReceivedEventDetail: function toHaveReceivedEventDetail(e, t) {
    if (!e) throw new Error("toHaveReceivedEventDetail event spy is null");
    if ("function" == typeof e.then) throw new Error("event spy must be a resolved value, not a promise, before it can be tested");
    if (!e.eventName) throw new Error("toHaveReceivedEventDetail did not receive an event spy");
    if (!e.lastEvent) throw new Error(`event "${e.eventName}" was not received`);
    const s = deepEqual(e.lastEvent.detail, t);
    return expect(e.lastEvent.detail).toEqual(t), {
      message: () => `expected event "${e.eventName}" detail to ${s ? "not " : ""}equal`,
      pass: s
    };
  },
  toHaveReceivedEventTimes: function toHaveReceivedEventTimes(e, t) {
    if (!e) throw new Error("toHaveReceivedEventTimes event spy is null");
    if ("function" == typeof e.then) throw new Error("event spy must be a resolved value, not a promise, before it can be tested");
    if (!e.eventName) throw new Error("toHaveReceivedEventTimes did not receive an event spy");
    return {
      message: () => `expected event "${e.eventName}" to have been called ${t} times, but was called ${e.events.length} time${e.events.length > 1 ? "s" : ""}`,
      pass: e.length === t
    };
  },
  toHaveFirstReceivedEventDetail: function toHaveFirstReceivedEventDetail(e, t) {
    if (!e) throw new Error("toHaveFirstReceivedEventDetail event spy is null");
    if ("function" == typeof e.then) throw new Error("event spy must be a resolved value, not a promise, before it can be tested");
    if (!e.eventName) throw new Error("toHaveFirstReceivedEventDetail did not receive an event spy");
    if (!e.firstEvent) throw new Error(`event "${e.eventName}" was not received`);
    const s = deepEqual(e.firstEvent.detail, t);
    return expect(e.lastEvent.detail).toEqual(t), {
      message: () => `expected event "${e.eventName}" detail to ${s ? "not " : ""}equal`,
      pass: s
    };
  },
  toHaveNthReceivedEventDetail: function toHaveNthReceivedEventDetail(e, t, s) {
    if (!e) throw new Error("toHaveNthReceivedEventDetail event spy is null");
    if ("function" == typeof e.then) throw new Error("event spy must be a resolved value, not a promise, before it can be tested");
    if (!e.eventName) throw new Error("toHaveNthReceivedEventDetail did not receive an event spy");
    if (!e.firstEvent) throw new Error(`event "${e.eventName}" was not received`);
    const r = e.events[t];
    if (!r) throw new Error(`event at index ${t} was not received`);
    const n = deepEqual(r.detail, s);
    return expect(r.detail).toEqual(s), {
      message: () => `expected event "${e.eventName}" detail to ${n ? "not " : ""}equal`,
      pass: n
    };
  },
  toMatchScreenshot: function toMatchScreenshot(e, t = {}) {
    if (!e) throw new Error("expect toMatchScreenshot value is null");
    if ("function" == typeof e.then) throw new Error("expect(compare).toMatchScreenshot() must be a resolved value, not a promise, before it can be tested");
    if ("number" != typeof e.mismatchedPixels) throw new Error("expect toMatchScreenshot() value is not a screenshot compare");
    const s = e.device || e.userAgent;
    if ("number" == typeof t.allowableMismatchedRatio) {
      if (t.allowableMismatchedRatio < 0 || t.allowableMismatchedRatio > 1) throw new Error("expect toMatchScreenshot() allowableMismatchedRatio must be a value ranging from 0 to 1");
      const r = e.mismatchedPixels / (e.width * e.deviceScaleFactor * (e.height * e.deviceScaleFactor));
      return {
        message: () => `${s}: screenshot has a mismatch ratio of "${r}" for "${e.desc}", but expected ratio to be less than "${t.allowableMismatchedRatio}"`,
        pass: r <= t.allowableMismatchedRatio
      };
    }
    if ("number" == typeof t.allowableMismatchedPixels) {
      if (t.allowableMismatchedPixels < 0) throw new Error("expect toMatchScreenshot() allowableMismatchedPixels value must be a value that is 0 or greater");
      return {
        message: () => `${s}: screenshot has "${e.mismatchedPixels}" mismatched pixels for "${e.desc}", but expected less than "${t.allowableMismatchedPixels}" mismatched pixels`,
        pass: e.mismatchedPixels <= t.allowableMismatchedPixels
      };
    }
    if ("number" == typeof e.allowableMismatchedRatio) {
      const t = e.mismatchedPixels / (e.width * e.deviceScaleFactor * (e.height * e.deviceScaleFactor));
      return {
        message: () => `${s}: screenshot has a mismatch ratio of "${t}" for "${e.desc}", but expected ratio to be less than "${e.allowableMismatchedRatio}"`,
        pass: t <= e.allowableMismatchedRatio
      };
    }
    if ("number" == typeof e.allowableMismatchedPixels) return {
      message: () => `${s}: screenshot has "${e.mismatchedPixels}" mismatched pixels for "${e.desc}", but expected less than "${e.allowableMismatchedPixels}" mismatched pixels`,
      pass: e.mismatchedPixels <= e.allowableMismatchedPixels
    };
    throw new Error("expect toMatchScreenshot() missing allowableMismatchedPixels in testing config");
  }
};

class MockHeaders {
  constructor(e) {
    if (this._values = [], "object" == typeof e) if ("function" == typeof e[Symbol.iterator]) {
      const t = [];
      for (const s of e) "function" == typeof s[Symbol.iterator] && t.push([ ...s ]);
      for (const e of t) this.append(e[0], e[1]);
    } else for (const t in e) this.append(t, e[t]);
  }
  append(e, t) {
    this._values.push([ e, t + "" ]);
  }
  delete(e) {
    e = e.toLowerCase();
    for (let t = this._values.length - 1; t >= 0; t--) this._values[t][0].toLowerCase() === e && this._values.splice(t, 1);
  }
  entries() {
    const e = [];
    for (const t of this.keys()) e.push([ t, this.get(t) ]);
    let t = -1;
    return {
      next: () => (t++, {
        value: e[t],
        done: !e[t]
      }),
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  forEach(e) {
    for (const t of this.entries()) e(t[1], t[0]);
  }
  get(e) {
    const t = [];
    e = e.toLowerCase();
    for (const s of this._values) s[0].toLowerCase() === e && t.push(s[1]);
    return t.length > 0 ? t.join(", ") : null;
  }
  has(e) {
    e = e.toLowerCase();
    for (const t of this._values) if (t[0].toLowerCase() === e) return !0;
    return !1;
  }
  keys() {
    const e = [];
    for (const t of this._values) {
      const s = t[0].toLowerCase();
      e.includes(s) || e.push(s);
    }
    let t = -1;
    return {
      next: () => (t++, {
        value: e[t],
        done: !e[t]
      }),
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  set(e, t) {
    for (const s of this._values) if (s[0].toLowerCase() === e.toLowerCase()) return void (s[1] = t + "");
    this.append(e, t);
  }
  values() {
    const e = this._values;
    let t = -1;
    return {
      next() {
        t++;
        const s = !e[t];
        return {
          value: s ? void 0 : e[t][1],
          done: s
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
}

class MockRequest {
  constructor(e, t = {}) {
    this._method = "GET", this._url = "/", this.bodyUsed = !1, this.cache = "default", 
    this.credentials = "same-origin", this.integrity = "", this.keepalive = !1, this.mode = "cors", 
    this.redirect = "follow", this.referrer = "about:client", this.referrerPolicy = "", 
    "string" == typeof e ? this.url = e : e && (Object.assign(this, e), this.headers = new MockHeaders(e.headers)), 
    Object.assign(this, t), t.headers && (this.headers = new MockHeaders(t.headers)), 
    this.headers || (this.headers = new MockHeaders);
  }
  get url() {
    return "string" == typeof this._url ? new URL(this._url, location.href).href : new URL("/", location.href).href;
  }
  set url(e) {
    this._url = e;
  }
  get method() {
    return "string" == typeof this._method ? this._method.toUpperCase() : "GET";
  }
  set method(e) {
    this._method = e;
  }
  clone() {
    const e = Object.assign({}, this);
    return e.headers = new MockHeaders(this.headers), new MockRequest(e);
  }
}

class MockResponse {
  constructor(e, t = {}) {
    this.ok = !0, this.status = 200, this.statusText = "", this.type = "default", this.url = "", 
    this._body = e, t && Object.assign(this, t), this.headers = new MockHeaders(t.headers);
  }
  async json() {
    return JSON.parse(this._body);
  }
  async text() {
    return this._body;
  }
  clone() {
    const e = Object.assign({}, this);
    return e.headers = new MockHeaders(this.headers), new MockResponse(this._body, e);
  }
}

const mockedResponses = new Map, mockFetch = {
  json(e, t) {
    setMockedResponse(new MockResponse(JSON.stringify(e, null, 2), {
      headers: new MockHeaders({
        "Content-Type": "application/json"
      })
    }), t, !1);
  },
  text(e, t) {
    setMockedResponse(new MockResponse(e, {
      headers: new MockHeaders({
        "Content-Type": "text/plain"
      })
    }), t, !1);
  },
  response(e, t) {
    setMockedResponse(e, t, !1);
  },
  reject(e, t) {
    setMockedResponse(e, t, !0);
  },
  reset: function mockFetchReset() {
    mockedResponses.clear();
  }
};

class MockResponse404 extends MockResponse {
  constructor() {
    super("", {
      headers: new MockHeaders({
        "Content-Type": "text/plain"
      })
    }), this.ok = !1, this.status = 404, this.statusText = "Not Found";
  }
  async json() {
    return {
      status: 404,
      statusText: "Not Found"
    };
  }
  async text() {
    return "Not Found";
  }
}

const FETCH_DEFAULT_PATH = "/mock-fetch-data", HtmlSerializer = {
  print: e => index_cjs_js.serializeNodeToHtml(e, {
    serializeShadowRoot: !0,
    prettyHtml: !0,
    outerHtml: !0
  }),
  test: e => null != e && (e instanceof HTMLElement || e instanceof index_cjs_js.MockNode)
};

class BuildContext {
  constructor(e, t) {
    this.buildId = -1, this.buildMessages = [], this.buildResults = null, this.bundleBuildCount = 0, 
    this.collections = [], this.completedTasks = [], this.components = [], this.componentGraph = new Map, 
    this.data = {}, this.diagnostics = [], this.dirsAdded = [], this.dirsDeleted = [], 
    this.entryModules = [], this.filesAdded = [], this.filesChanged = [], this.filesDeleted = [], 
    this.filesUpdated = [], this.filesWritten = [], this.globalStyle = void 0, this.hasConfigChanges = !1, 
    this.hasFinished = !1, this.hasHtmlChanges = !1, this.hasPrintedResults = !1, this.hasServiceWorkerChanges = !1, 
    this.hasScriptChanges = !0, this.hasStyleChanges = !0, this.hydrateAppFilePath = null, 
    this.indexBuildCount = 0, this.indexDoc = void 0, this.isRebuild = !1, this.moduleFiles = [], 
    this.outputs = [], this.packageJson = {}, this.packageJsonFilePath = null, this.pendingCopyTasks = [], 
    this.requiresFullBuild = !0, this.scriptsAdded = [], this.scriptsDeleted = [], this.startTime = Date.now(), 
    this.styleBuildCount = 0, this.stylesPromise = null, this.stylesUpdated = [], this.timeSpan = null, 
    this.transpileBuildCount = 0, this.config = e, this.compilerCtx = t, this.buildId = ++this.compilerCtx.activeBuildId, 
    this.debug = e.logger.debug.bind(e.logger);
  }
  start() {
    const e = `${this.isRebuild ? "rebuild" : "build"}, ${this.config.fsNamespace}, ${this.config.devMode ? "dev" : "prod"} mode, started`, t = {
      buildId: this.buildId,
      messages: [],
      progress: 0
    };
    this.compilerCtx.events.emit("buildLog", t), this.timeSpan = this.createTimeSpan(e), 
    this.timestamp = getBuildTimestamp(), this.debug("start build, " + this.timestamp);
    const s = {
      buildId: this.buildId,
      timestamp: this.timestamp
    };
    this.compilerCtx.events.emit("buildStart", s);
  }
  createTimeSpan(e, t) {
    if (!this.hasFinished || t) {
      t && this.config.watch && (e = `${this.config.logger.cyan("[" + this.buildId + "]")} ${e}`);
      const s = this.config.logger.createTimeSpan(e, t, this.buildMessages);
      if (!t && this.compilerCtx.events) {
        const e = {
          buildId: this.buildId,
          messages: this.buildMessages,
          progress: getProgress(this.completedTasks)
        };
        this.compilerCtx.events.emit("buildLog", e);
      }
      return {
        duration: () => s.duration(),
        finish: (e, r, n, i) => {
          if ((!this.hasFinished || t) && (t && this.config.watch && (e = `${this.config.logger.cyan("[" + this.buildId + "]")} ${e}`), 
          s.finish(e, r, n, i), !t)) {
            const e = {
              buildId: this.buildId,
              messages: this.buildMessages.slice(),
              progress: getProgress(this.completedTasks)
            };
            this.compilerCtx.events.emit("buildLog", e);
          }
          return s.duration();
        }
      };
    }
    return {
      duration: () => 0,
      finish: () => 0
    };
  }
  debug(e) {
    this.config.logger.debug(e);
  }
  get hasError() {
    return hasError(this.diagnostics);
  }
  get hasWarning() {
    return null != (e = this.diagnostics) && 0 !== e.length && e.some(e => "warn" === e.level);
    var e;
  }
  progress(e) {
    this.completedTasks.push(e);
  }
  async validateTypesBuild() {
    this.hasError || this.validateTypesPromise && (this.config.watch || (this.debug("build, non-watch, waiting on validateTypes"), 
    await this.validateTypesPromise, this.debug("build, non-watch, finished waiting on validateTypes")));
  }
}

const getBuildTimestamp = () => {
  const e = new Date;
  let t = e.getUTCFullYear() + "-";
  return t += ("0" + (e.getUTCMonth() + 1)).slice(-2) + "-", t += ("0" + e.getUTCDate()).slice(-2) + "T", 
  t += ("0" + e.getUTCHours()).slice(-2) + ":", t += ("0" + e.getUTCMinutes()).slice(-2) + ":", 
  t += ("0" + e.getUTCSeconds()).slice(-2), t;
}, getProgress = e => {
  let t = 0;
  const s = Object.keys(ProgressTask);
  return s.forEach((s, r) => {
    e.includes(ProgressTask[s]) && (t = r);
  }), (t + 1) / s.length;
}, ProgressTask = {
  emptyOutputTargets: {},
  transpileApp: {},
  generateStyles: {},
  generateOutputTargets: {},
  validateTypesBuild: {},
  writeBuildFiles: {}
};

class Cache {
  constructor(e, t) {
    this.config = e, this.cacheFs = t, this.failed = 0, this.skip = !1, this.sys = e.sys, 
    this.logger = e.logger;
  }
  async initCacheDir() {
    if (!this.config._isTesting && this.config.cacheDir) {
      if (!this.config.enableCache || !this.cacheFs) return this.config.logger.info("cache optimizations disabled"), 
      void this.clearDiskCache();
      this.config.logger.debug("cache enabled, cacheDir: " + this.config.cacheDir);
      try {
        const e = path$1.join(this.config.cacheDir, "_README.log");
        await this.cacheFs.writeFile(e, CACHE_DIR_README);
      } catch (e) {
        this.logger.error("Cache, initCacheDir: " + e), this.config.enableCache = !1;
      }
    }
  }
  async get(e) {
    if (!this.config.enableCache || this.skip) return null;
    if (this.failed >= MAX_FAILED) return this.skip || (this.skip = !0, this.logger.debug(`cache had ${this.failed} failed ops, skip disk ops for remander of build`)), 
    null;
    let t;
    try {
      t = await this.cacheFs.readFile(this.getCacheFilePath(e)), this.failed = 0, this.skip = !1;
    } catch (e) {
      this.failed++, t = null;
    }
    return t;
  }
  async put(e, t) {
    if (!this.config.enableCache) return !1;
    let s;
    try {
      await this.cacheFs.writeFile(this.getCacheFilePath(e), t), s = !0;
    } catch (e) {
      this.failed++, s = !1;
    }
    return s;
  }
  async has(e) {
    return "string" == typeof await this.get(e);
  }
  async createKey(e, ...t) {
    return this.config.enableCache ? e + "_" + await this.sys.generateContentHash(JSON.stringify(t), 32) : e + 9999999 * Math.random();
  }
  async commit() {
    this.config.enableCache && (this.skip = !1, this.failed = 0, await this.cacheFs.commit(), 
    await this.clearExpiredCache());
  }
  clear() {
    null != this.cacheFs && this.cacheFs.clearCache();
  }
  async clearExpiredCache() {
    if (null == this.cacheFs || null == this.sys.cacheStorage) return;
    const e = Date.now(), t = await this.sys.cacheStorage.get(EXP_STORAGE_KEY);
    if (null != t) {
      if (e - t < ONE_DAY) return;
      const s = this.cacheFs.sys, r = await s.readdir(this.config.cacheDir), n = r.map(e => path$1.join(this.config.cacheDir, e));
      let i = 0;
      const o = n.map(async t => {
        const r = (await s.stat(t)).mtime.getTime();
        e - r > ONE_WEEK && (await s.unlink(t), i++);
      });
      await Promise.all(o), this.logger.debug(`clearExpiredCache, cachedFileNames: ${r.length}, totalCleared: ${i}`);
    }
    this.logger.debug("clearExpiredCache, set last clear"), await this.sys.cacheStorage.set(EXP_STORAGE_KEY, e);
  }
  async clearDiskCache() {
    null != this.cacheFs && await this.cacheFs.access(this.config.cacheDir) && (await this.cacheFs.remove(this.config.cacheDir), 
    await this.cacheFs.commit());
  }
  getCacheFilePath(e) {
    return path$1.join(this.config.cacheDir, e) + ".log";
  }
  getMemoryStats() {
    return null != this.cacheFs ? this.cacheFs.getMemoryStats() : null;
  }
}

const MAX_FAILED = 100, ONE_DAY = 864e5, ONE_WEEK = 7 * ONE_DAY, EXP_STORAGE_KEY = "last_clear_expired_cache", CACHE_DIR_README = '# Stencil Cache Directory\n\nThis directory contains files which the compiler has\ncached for faster builds. To disable caching, please set\n"enableCache: false" within the stencil config.\n\nTo change the cache directory, please update the\n"cacheDir" property within the stencil config.\n', getCommitInstructions = e => {
  const t = {
    filesToDelete: [],
    filesToWrite: [],
    filesToCopy: [],
    dirsToDelete: [],
    dirsToEnsure: []
  };
  e.forEach((e, s) => {
    if (!0 === e.queueWriteToDisk) {
      if (!0 === e.isFile) {
        t.filesToWrite.push(s);
        const e = normalizePath(path$1.dirname(s));
        t.dirsToEnsure.includes(e) || t.dirsToEnsure.push(e);
        const r = t.dirsToDelete.indexOf(e);
        r > -1 && t.dirsToDelete.splice(r, 1);
        const n = t.filesToDelete.indexOf(s);
        n > -1 && t.filesToDelete.splice(n, 1);
      } else if (!0 === e.isDirectory) {
        t.dirsToEnsure.includes(s) || t.dirsToEnsure.push(s);
        const e = t.dirsToDelete.indexOf(s);
        e > -1 && t.dirsToDelete.splice(e, 1);
      }
    } else if (!0 === e.queueDeleteFromDisk) e.isDirectory && !t.dirsToEnsure.includes(s) ? t.dirsToDelete.push(s) : e.isFile && !t.filesToWrite.includes(s) && t.filesToDelete.push(s); else if ("string" == typeof e.queueCopyFileToDest) {
      const r = s, n = e.queueCopyFileToDest;
      t.filesToCopy.push([ r, n ]);
      const i = normalizePath(path$1.dirname(n));
      t.dirsToEnsure.includes(i) || t.dirsToEnsure.push(i);
      const o = t.dirsToDelete.indexOf(i);
      o > -1 && t.dirsToDelete.splice(o, 1);
      const a = t.filesToDelete.indexOf(n);
      a > -1 && t.filesToDelete.splice(a, 1);
    }
    e.queueDeleteFromDisk = !1, e.queueWriteToDisk = !1;
  });
  for (let e = 0, s = t.dirsToEnsure.length; e < s; e++) {
    const s = t.dirsToEnsure[e].split("/");
    for (let e = 2; e < s.length; e++) {
      const r = s.slice(0, e).join("/");
      !1 === t.dirsToEnsure.includes(r) && t.dirsToEnsure.push(r);
    }
  }
  t.dirsToEnsure.sort((e, t) => {
    const s = e.split("/").length, r = t.split("/").length;
    return s < r ? -1 : s > r ? 1 : e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
  }), t.dirsToDelete.sort((e, t) => {
    const s = e.split("/").length, r = t.split("/").length;
    return s < r ? 1 : s > r ? -1 : e.length < t.length ? 1 : e.length > t.length ? -1 : 0;
  });
  for (const e of t.dirsToEnsure) {
    const s = t.dirsToDelete.indexOf(e);
    s > -1 && t.dirsToDelete.splice(s, 1);
  }
  return t.dirsToDelete = t.dirsToDelete.filter(e => "/" !== e && !0 !== e.endsWith(":/")), 
  t.dirsToEnsure = t.dirsToEnsure.filter(t => {
    const s = e.get(t);
    return (null == s || !0 !== s.exists || !0 !== s.isDirectory) && "/" !== t && !t.endsWith(":/");
  }), t;
}, shouldIgnore = e => (e = e.trim().toLowerCase(), IGNORE.some(t => e.endsWith(t))), IGNORE = [ ".ds_store", ".gitignore", "desktop.ini", "thumbs.db" ];

(posix = {
  resolve: function e() {
    var t, s, r, n = "", i = !1;
    for (s = arguments.length - 1; s >= -1 && !i; s--) s >= 0 ? r = arguments[s] : (void 0 === t && (t = process.cwd()), 
    r = t), assertPath(r), 0 !== r.length && (n = r + "/" + n, i = 47 === r.charCodeAt(0));
    return n = normalizeStringPosix(n, !i), i ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
  },
  normalize: function e(t) {
    var s, r;
    return assertPath(t), 0 === t.length ? "." : (s = 47 === t.charCodeAt(0), r = 47 === t.charCodeAt(t.length - 1), 
    0 !== (t = normalizeStringPosix(t, !s)).length || s || (t = "."), t.length > 0 && r && (t += "/"), 
    s ? "/" + t : t);
  },
  isAbsolute: function e(t) {
    return assertPath(t), t.length > 0 && 47 === t.charCodeAt(0);
  },
  join: function e() {
    var t, s, r;
    if (0 === arguments.length) return ".";
    for (s = 0; s < arguments.length; ++s) assertPath(r = arguments[s]), r.length > 0 && (void 0 === t ? t = r : t += "/" + r);
    return void 0 === t ? "." : posix.normalize(t);
  },
  relative: function e(t, s) {
    var r, n, i, o, a, l, c, u, h, d;
    if (assertPath(t), assertPath(s), t === s) return "";
    if ((t = posix.resolve(t)) === (s = posix.resolve(s))) return "";
    for (r = 1; r < t.length && 47 === t.charCodeAt(r); ++r) ;
    for (i = (n = t.length) - r, o = 1; o < s.length && 47 === s.charCodeAt(o); ++o) ;
    for (l = i < (a = s.length - o) ? i : a, c = -1, u = 0; u <= l; ++u) {
      if (u === l) {
        if (a > l) {
          if (47 === s.charCodeAt(o + u)) return s.slice(o + u + 1);
          if (0 === u) return s.slice(o + u);
        } else i > l && (47 === t.charCodeAt(r + u) ? c = u : 0 === u && (c = 0));
        break;
      }
      if ((h = t.charCodeAt(r + u)) !== s.charCodeAt(o + u)) break;
      47 === h && (c = u);
    }
    for (d = "", u = r + c + 1; u <= n; ++u) u !== n && 47 !== t.charCodeAt(u) || (0 === d.length ? d += ".." : d += "/..");
    return d.length > 0 ? d + s.slice(o + c) : (o += c, 47 === s.charCodeAt(o) && ++o, 
    s.slice(o));
  },
  _makeLong: function e(t) {
    return t;
  },
  dirname: function e(t) {
    var s, r, n, i;
    if (assertPath(t), 0 === t.length) return ".";
    for (s = 47 === t.charCodeAt(0), r = -1, n = !0, i = t.length - 1; i >= 1; --i) if (47 === t.charCodeAt(i)) {
      if (!n) {
        r = i;
        break;
      }
    } else n = !1;
    return -1 === r ? s ? "/" : "." : s && 1 === r ? "//" : t.slice(0, r);
  },
  basename: function e(t, s) {
    var r, n, i, o, a, l, c;
    if (void 0 !== s && "string" != typeof s) throw new TypeError('"ext" argument must be a string');
    if (assertPath(t), r = 0, n = -1, i = !0, void 0 !== s && s.length > 0 && s.length <= t.length) {
      if (s.length === t.length && s === t) return "";
      for (a = s.length - 1, l = -1, o = t.length - 1; o >= 0; --o) if (47 === (c = t.charCodeAt(o))) {
        if (!i) {
          r = o + 1;
          break;
        }
      } else -1 === l && (i = !1, l = o + 1), a >= 0 && (c === s.charCodeAt(a) ? -1 == --a && (n = o) : (a = -1, 
      n = l));
      return r === n ? n = l : -1 === n && (n = t.length), t.slice(r, n);
    }
    for (o = t.length - 1; o >= 0; --o) if (47 === t.charCodeAt(o)) {
      if (!i) {
        r = o + 1;
        break;
      }
    } else -1 === n && (i = !1, n = o + 1);
    return -1 === n ? "" : t.slice(r, n);
  },
  extname: function e(t) {
    var s, r, n, i, o, a, l;
    for (assertPath(t), s = -1, r = 0, n = -1, i = !0, o = 0, a = t.length - 1; a >= 0; --a) if (47 !== (l = t.charCodeAt(a))) -1 === n && (i = !1, 
    n = a + 1), 46 === l ? -1 === s ? s = a : 1 !== o && (o = 1) : -1 !== s && (o = -1); else if (!i) {
      r = a + 1;
      break;
    }
    return -1 === s || -1 === n || 0 === o || 1 === o && s === n - 1 && s === r + 1 ? "" : t.slice(s, n);
  },
  format: function e(t) {
    if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return function s(e, t) {
      var s = t.dir || t.root, r = t.base || (t.name || "") + (t.ext || "");
      return s ? s === t.root ? s + r : s + e + r : r;
    }("/", t);
  },
  parse: function e(t) {
    var s, r, n, i, o, a, l, c, u, h;
    if (assertPath(t), s = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    }, 0 === t.length) return s;
    for ((n = 47 === (r = t.charCodeAt(0))) ? (s.root = "/", i = 1) : i = 0, o = -1, 
    a = 0, l = -1, c = !0, u = t.length - 1, h = 0; u >= i; --u) if (47 !== (r = t.charCodeAt(u))) -1 === l && (c = !1, 
    l = u + 1), 46 === r ? -1 === o ? o = u : 1 !== h && (h = 1) : -1 !== o && (h = -1); else if (!c) {
      a = u + 1;
      break;
    }
    return -1 === o || -1 === l || 0 === h || 1 === h && o === l - 1 && o === a + 1 ? -1 !== l && (s.base = s.name = 0 === a && n ? t.slice(1, l) : t.slice(a, l)) : (0 === a && n ? (s.name = t.slice(1, o), 
    s.base = t.slice(1, l)) : (s.name = t.slice(a, o), s.base = t.slice(a, l)), s.ext = t.slice(o, l)), 
    a > 0 ? s.dir = t.slice(0, a - 1) : n && (s.dir = "/"), s;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
}).posix = posix, pathBrowserify = posix;

const YELLOW = "#f39c12", RED = "#c0392b", BLUE = "#3498db", COMMON_DIR_MODULE_EXTS = [ ".tsx", ".ts", ".mjs", ".js", ".jsx", ".json", ".md" ], COMMON_DIR_FILENAMES = [ "package.json", "index.js", "index.mjs" ], getCommonDirName = (e, t) => e + "/" + t, isCommonDirModuleFile = e => COMMON_DIR_MODULE_EXTS.some(t => e.endsWith(t)), shouldFetchModule = e => IS_FETCH_ENV && IS_BROWSER_ENV && isNodeModulePath(e), isNodeModulePath = e => normalizePath(e).split("/").includes("node_modules"), getPackageDirPath = (e, t) => {
  const s = normalizePath(e).split("/"), r = (e => {
    e.startsWith("~") && (e = e.substring(1));
    const t = e.split("/"), s = {
      moduleId: null,
      filePath: null,
      scope: null,
      scopeSubModuleId: null
    };
    return e.startsWith("@") && t.length > 1 ? (s.moduleId = t.slice(0, 2).join("/"), 
    s.filePath = t.slice(2).join("/"), s.scope = t[0], s.scopeSubModuleId = t[1]) : (s.moduleId = t[0], 
    s.filePath = t.slice(1).join("/")), s;
  })(t);
  for (let e = s.length - 1; e >= 1; e--) if ("node_modules" === s[e - 1]) if (r.scope) {
    if (s[e] === r.scope && s[e + 1] === r.scopeSubModuleId) return s.slice(0, e + 2).join("/");
  } else if (s[e] === r.moduleId) return s.slice(0, e + 1).join("/");
  return null;
}, packageVersions = new Map, known404Urls = new Set, getCommonDirUrl = (e, t, s, r) => getNodeModuleFetchUrl(e, t, s) + "/" + r, getNodeModuleFetchUrl = (e, t, s) => {
  let r = (s = normalizePath(s)).split("/").filter(e => e.length);
  const n = r.lastIndexOf("node_modules");
  n > -1 && n < r.length - 1 && (r = r.slice(n + 1));
  let i = r.shift();
  i.startsWith("@") && (i += "/" + r.shift());
  const o = r.join("/");
  if ("@stencil/core" === i) {
    return ((e, t) => {
      let s = (t = normalizePath(t)).split("/");
      const r = s.lastIndexOf("node_modules");
      return r > -1 && r < s.length - 1 && (s = s.slice(r + 1), s = s[0].startsWith("@") ? s.slice(2) : s.slice(1), 
      t = s.join("/")), new URL("./" + t, (e => new URL("../", e).href)(e)).href;
    })(e.getCompilerExecutingPath(), o);
  }
  return e.getRemoteModuleUrl({
    moduleId: i,
    version: t.get(i),
    path: o
  });
}, knownUrlSkips = [ "/@stencil/core/internal.js", "/@stencil/core/internal.json", "/@stencil/core/internal.mjs", "/@stencil/core/internal/stencil-core.js/index.json", "/@stencil/core/internal/stencil-core.js.json", "/@stencil/core/internal/stencil-core.js/package.json", "/@stencil/core.js", "/@stencil/core.json", "/@stencil/core.mjs", "/@stencil/core.css", "/@stencil/core/index.js", "/@stencil/core/index.json", "/@stencil/core/index.mjs", "/@stencil/core/index.css", "/@stencil/package.json" ], fetchModuleAsync = async (e, t, s, r, n) => {
  if (!((e => {
    if (!(e => e.endsWith(".d.ts"))(t = e) && t.endsWith(".ts") || (e => e.endsWith(".tsx"))(e)) return !0;
    var t;
    const s = e.split("/"), r = s[s.length - 2], n = s[s.length - 1];
    return !("node_modules" !== r || !isCommonDirModuleFile(n));
  })(n) || known404Urls.has(r) || (e => knownUrlSkips.some(t => e.endsWith(t)))(r))) try {
    const i = await ((e, t, s) => (console.trace(t), e && isFunction(e.fetch) ? e.fetch(t, void 0) : fetch(t, void 0)))(e, r);
    if (i) {
      if (i.ok) {
        const o = await i.clone().text();
        return await (async (e, t, s, r, n, i) => {
          s.endsWith("package.json") && ((e, t) => {
            try {
              const s = JSON.parse(t);
              s.name && s.version && ((e, t, s) => {
                e.set(t, s);
              })(e, s.name, s.version);
            } catch (e) {}
          })(i, n);
          let o = path$1.dirname(r);
          for (;"/" !== o && "" !== o; ) t ? (t.clearFileCache(o), await t.sys.mkdir(o)) : await e.mkdir(o), 
          o = path$1.dirname(o);
          t ? (t.clearFileCache(r), await t.sys.writeFile(r, n)) : await e.writeFile(r, n);
        })(e, t, r, n, o, s), o;
      }
      404 === i.status && known404Urls.add(r);
    }
  } catch (e) {
    console.error(e);
  }
};

caller = function() {
  var e, t = Error.prepareStackTrace;
  return Error.prepareStackTrace = function(e, t) {
    return t;
  }, e = (new Error).stack, Error.prepareStackTrace = t, e[2].getFileName();
}, pathParse = function createCommonjsModule(e, t, s) {
  return e(s = {
    path: t,
    exports: {},
    require: function(e, t) {
      return function r() {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
      }(null == t && s.path);
    }
  }, s.exports), s.exports;
}((function(e) {
  var t, s, r = "win32" === process.platform, n = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/, i = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/, o = {
    parse: function(e) {
      if ("string" != typeof e) throw new TypeError("Parameter 'pathString' must be a string, not " + typeof e);
      var t = function s(e) {
        var t = n.exec(e), s = (t[1] || "") + (t[2] || ""), r = t[3] || "", o = i.exec(r);
        return [ s, o[1], o[2], o[3] ];
      }(e);
      if (!t || 4 !== t.length) throw new TypeError("Invalid path '" + e + "'");
      return {
        root: t[0],
        dir: t[0] + t[1].slice(0, -1),
        base: t[2],
        ext: t[3],
        name: t[2].slice(0, t[2].length - t[3].length)
      };
    }
  };
  t = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, (s = {}).parse = function(e) {
    if ("string" != typeof e) throw new TypeError("Parameter 'pathString' must be a string, not " + typeof e);
    var s = function r(e) {
      return t.exec(e).slice(1);
    }(e);
    if (!s || 4 !== s.length) throw new TypeError("Invalid path '" + e + "'");
    return s[1] = s[1] || "", s[2] = s[2] || "", s[3] = s[3] || "", {
      root: s[0],
      dir: s[0] + s[1].slice(0, -1),
      base: s[2],
      ext: s[3],
      name: s[2].slice(0, s[2].length - s[3].length)
    };
  }, e.exports = r ? o.parse : s.parse, e.exports.posix = s.parse, e.exports.win32 = o.parse;
})), parse = path$1__default.parse || pathParse, getNodeModulesDirs = function e(t, s) {
  var r, n, i = "/";
  for (/^([A-Za-z]:)/.test(t) ? i = "" : /^\\\\/.test(t) && (i = "\\\\"), r = [ t ], 
  n = parse(t); n.dir !== r[r.length - 1]; ) r.push(n.dir), n = parse(n.dir);
  return r.reduce((function(e, t) {
    return e.concat(s.map((function(e) {
      return path$1__default.resolve(i, t, e);
    })));
  }), []);
}, nodeModulesPaths = function e(t, s, r) {
  var n, i = s && s.moduleDirectory ? [].concat(s.moduleDirectory) : [ "node_modules" ];
  return s && "function" == typeof s.paths ? s.paths(r, t, (function() {
    return getNodeModulesDirs(t, i);
  }), s) : (n = getNodeModulesDirs(t, i), s && s.paths ? n.concat(s.paths) : n);
}, normalizeOptions = function(e, t) {
  return t || {};
};

const wasi = ">= 13.4 && < 13.5", core = {
  assert: !0,
  async_hooks: ">= 8",
  buffer_ieee754: "< 0.9.7",
  buffer: !0,
  child_process: !0,
  cluster: !0,
  console: !0,
  constants: !0,
  crypto: !0,
  _debug_agent: ">= 1 && < 8",
  _debugger: "< 8",
  dgram: !0,
  dns: !0,
  domain: !0,
  events: !0,
  freelist: "< 6",
  fs: !0,
  "fs/promises": [ ">= 10 && < 10.1", ">= 14" ],
  _http_agent: ">= 0.11.1",
  _http_client: ">= 0.11.1",
  _http_common: ">= 0.11.1",
  _http_incoming: ">= 0.11.1",
  _http_outgoing: ">= 0.11.1",
  _http_server: ">= 0.11.1",
  http: !0,
  http2: ">= 8.8",
  https: !0,
  inspector: ">= 8.0.0",
  _linklist: "< 8",
  module: !0,
  net: !0,
  "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
  "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
  "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
  os: !0,
  path: !0,
  perf_hooks: ">= 8.5",
  process: ">= 1",
  punycode: !0,
  querystring: !0,
  readline: !0,
  repl: !0,
  smalloc: ">= 0.11.5 && < 3",
  _stream_duplex: ">= 0.9.4",
  _stream_transform: ">= 0.9.4",
  _stream_wrap: ">= 1.4.1",
  _stream_passthrough: ">= 0.9.4",
  _stream_readable: ">= 0.9.4",
  _stream_writable: ">= 0.9.4",
  stream: !0,
  string_decoder: !0,
  sys: !0,
  timers: !0,
  _tls_common: ">= 0.11.13",
  _tls_legacy: ">= 0.11.3 && < 10",
  _tls_wrap: ">= 0.11.3",
  tls: !0,
  trace_events: ">= 10",
  tty: !0,
  url: !0,
  util: !0,
  "v8/tools/arguments": ">= 10 && < 12",
  "v8/tools/codemap": [ ">= 4.4.0 && < 5", ">= 5.2.0 && < 12" ],
  "v8/tools/consarray": [ ">= 4.4.0 && < 5", ">= 5.2.0 && < 12" ],
  "v8/tools/csvparser": [ ">= 4.4.0 && < 5", ">= 5.2.0 && < 12" ],
  "v8/tools/logreader": [ ">= 4.4.0 && < 5", ">= 5.2.0 && < 12" ],
  "v8/tools/profile_view": [ ">= 4.4.0 && < 5", ">= 5.2.0 && < 12" ],
  "v8/tools/splaytree": [ ">= 4.4.0 && < 5", ">= 5.2.0 && < 12" ],
  v8: ">= 1",
  vm: !0,
  wasi,
  worker_threads: ">= 11.7",
  zlib: !0
}, data = function getCjsExportFromNamespace(e) {
  return e && e.default || e;
}(Object.freeze({
  __proto__: null,
  assert: !0,
  async_hooks: ">= 8",
  buffer_ieee754: "< 0.9.7",
  buffer: !0,
  child_process: !0,
  cluster: !0,
  console: !0,
  constants: !0,
  crypto: !0,
  _debug_agent: ">= 1 && < 8",
  _debugger: "< 8",
  dgram: !0,
  dns: !0,
  domain: !0,
  events: !0,
  freelist: "< 6",
  fs: !0,
  _http_agent: ">= 0.11.1",
  _http_client: ">= 0.11.1",
  _http_common: ">= 0.11.1",
  _http_incoming: ">= 0.11.1",
  _http_outgoing: ">= 0.11.1",
  _http_server: ">= 0.11.1",
  http: !0,
  http2: ">= 8.8",
  https: !0,
  inspector: ">= 8.0.0",
  _linklist: "< 8",
  module: !0,
  net: !0,
  os: !0,
  path: !0,
  perf_hooks: ">= 8.5",
  process: ">= 1",
  punycode: !0,
  querystring: !0,
  readline: !0,
  repl: !0,
  smalloc: ">= 0.11.5 && < 3",
  _stream_duplex: ">= 0.9.4",
  _stream_transform: ">= 0.9.4",
  _stream_wrap: ">= 1.4.1",
  _stream_passthrough: ">= 0.9.4",
  _stream_readable: ">= 0.9.4",
  _stream_writable: ">= 0.9.4",
  stream: !0,
  string_decoder: !0,
  sys: !0,
  timers: !0,
  _tls_common: ">= 0.11.13",
  _tls_legacy: ">= 0.11.3 && < 10",
  _tls_wrap: ">= 0.11.3",
  tls: !0,
  trace_events: ">= 10",
  tty: !0,
  url: !0,
  util: !0,
  v8: ">= 1",
  vm: !0,
  wasi,
  worker_threads: ">= 11.7",
  zlib: !0,
  default: core
}));

for (mod in current = process.versions && process.versions.node && process.versions.node.split(".") || [], 
core$2 = {}, data) Object.prototype.hasOwnProperty.call(data, mod) && (core$2[mod] = versionIncluded(data[mod]));

core_1 = core$2, isCore = function e(t) {
  return Object.prototype.hasOwnProperty.call(core_1, t);
}, realpathFS = fs$1.realpath && "function" == typeof fs$1.realpath.native ? fs$1.realpath.native : fs$1.realpath, 
defaultIsFile = function e(t, s) {
  fs$1.stat(t, (function(e, t) {
    return e ? "ENOENT" === e.code || "ENOTDIR" === e.code ? s(null, !1) : s(e) : s(null, t.isFile() || t.isFIFO());
  }));
}, defaultIsDir = function e(t, s) {
  fs$1.stat(t, (function(e, t) {
    return e ? "ENOENT" === e.code || "ENOTDIR" === e.code ? s(null, !1) : s(e) : s(null, t.isDirectory());
  }));
}, defaultRealpath = function e(t, s) {
  realpathFS(t, (function(e, r) {
    e && "ENOENT" !== e.code ? s(e) : s(null, e ? t : r);
  }));
}, maybeRealpath = function e(t, s, r, n) {
  r && !1 === r.preserveSymlinks ? t(s, n) : n(null, s);
}, getPackageCandidates = function e(t, s, r) {
  var n, i = nodeModulesPaths(s, r, t);
  for (n = 0; n < i.length; n++) i[n] = path$1__default.join(i[n], t);
  return i;
}, async = function e(t, s, r) {
  function n(e, s, r) {
    e ? w(e) : s ? w(null, s, r) : o(y, (function(e, s, r) {
      if (e) w(e); else if (s) maybeRealpath(h, s, _, (function(e, t) {
        e ? w(e) : w(null, t, r);
      })); else {
        var n = new Error("Cannot find module '" + t + "' from '" + m + "'");
        n.code = "MODULE_NOT_FOUND", w(n);
      }
    }));
  }
  function i(e, t, s) {
    var r = t, n = s;
    "function" == typeof r && (n = r, r = void 0), function e(t, s, r) {
      function i(r, i, u) {
        var h, d, f;
        return c = i, r ? n(r) : u && c && _.pathFilter && (d = (h = path$1__default.relative(u, a)).slice(0, h.length - t[0].length), 
        f = _.pathFilter(c, s, d)) ? e([ "" ].concat(p.slice()), path$1__default.resolve(u, f), c) : void l(a, o);
      }
      function o(r, i) {
        return r ? n(r) : i ? n(null, a, c) : void e(t.slice(1), s, c);
      }
      var a, c;
      if (0 === t.length) return n(null, void 0, r);
      a = s + t[0], (c = r) ? i(null, c) : function e(t, s) {
        return "" === t || "/" === t || "win32" === process.platform && /^\w:[/\\]*$/.test(t) || /[/\\]node_modules[/\\]*$/.test(t) ? s(null) : void maybeRealpath(h, t, _, (function(r, n) {
          if (r) return e(path$1__default.dirname(t), s);
          var i = path$1__default.join(n, "package.json");
          l(i, (function(r, n) {
            if (!n) return e(path$1__default.dirname(t), s);
            u(i, (function(e, r) {
              e && s(e);
              try {
                var n = JSON.parse(r);
              } catch (e) {}
              n && _.packageFilter && (n = _.packageFilter(n, i)), s(null, n, t);
            }));
          }));
        }));
      }(path$1__default.dirname(a), i);
    }([ "" ].concat(p), e, r);
  }
  function o(e, t, s) {
    var r = s, n = t;
    "function" == typeof n && (r = n, n = _.package), maybeRealpath(h, e, _, (function(t, s) {
      if (t) return r(t);
      var a = path$1__default.join(s, "package.json");
      l(a, (function(t, s) {
        return t ? r(t) : s ? void u(a, (function(t, s) {
          var n, l;
          if (t) return r(t);
          try {
            n = JSON.parse(s);
          } catch (e) {}
          if (n && _.packageFilter && (n = _.packageFilter(n, a)), n && n.main) return "string" != typeof n.main ? ((l = new TypeError("package “" + n.name + "” `main` must be a string")).code = "INVALID_PACKAGE_MAIN", 
          r(l)) : ("." !== n.main && "./" !== n.main || (n.main = "index"), void i(path$1__default.resolve(e, n.main), n, (function(t, s, n) {
            return t ? r(t) : s ? r(null, s, n) : n ? void o(path$1__default.resolve(e, n.main), n, (function(t, s, n) {
              return t ? r(t) : s ? r(null, s, n) : void i(path$1__default.join(e, "index"), n, r);
            })) : i(path$1__default.join(e, "index"), n, r);
          })));
          i(path$1__default.join(e, "/index"), n, r);
        })) : i(path$1__default.join(e, "index"), n, r);
      }));
    }));
  }
  var a, l, c, u, h, d, p, f, m, g, y, w = r, _ = s;
  if ("function" == typeof s && (w = _, _ = {}), "string" != typeof t) return a = new TypeError("Path must be a string."), 
  process.nextTick((function() {
    w(a);
  }));
  _ = normalizeOptions(0, _), l = _.isFile || defaultIsFile, c = _.isDirectory || defaultIsDir, 
  u = _.readFile || fs$1.readFile, h = _.realpath || defaultRealpath, d = _.packageIterator, 
  p = _.extensions || [ ".js" ], f = _.basedir || path$1__default.dirname(caller()), 
  m = _.filename || f, _.paths = _.paths || [], g = path$1__default.resolve(f), maybeRealpath(h, g, _, (function(e, s) {
    e ? w(e) : function r(e) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(t)) y = path$1__default.resolve(e, t), 
      "." !== t && ".." !== t && "/" !== t.slice(-1) || (y += "/"), /\/$/.test(t) && y === e ? o(y, _.package, n) : i(y, _.package, n); else {
        if (isCore(t)) return w(null, t);
        !function s(e, t, r) {
          var n = function() {
            return getPackageCandidates(e, t, _);
          };
          !function e(t, s) {
            function r(e, s, r) {
              return e ? t(e) : s ? t(null, s, r) : void o(a, _.package, n);
            }
            function n(r, n, i) {
              return r ? t(r) : n ? t(null, n, i) : void e(t, s.slice(1));
            }
            if (0 === s.length) return t(null, void 0);
            var a = s[0];
            c(path$1__default.dirname(a), (function l(n, o) {
              return n ? t(n) : o ? void i(a, _.package, r) : e(t, s.slice(1));
            }));
          }(r, d ? d(e, t, n, _) : n());
        }(t, e, (function(e, s, r) {
          if (e) w(e); else {
            if (s) return maybeRealpath(h, s, _, (function(e, t) {
              e ? w(e) : w(null, t, r);
            }));
            var n = new Error("Cannot find module '" + t + "' from '" + m + "'");
            n.code = "MODULE_NOT_FOUND", w(n);
          }
        }));
      }
    }(s);
  }));
}, realpathFS$1 = fs$1.realpathSync && "function" == typeof fs$1.realpathSync.native ? fs$1.realpathSync.native : fs$1.realpathSync, 
defaultIsFile$1 = function e(t) {
  try {
    var s = fs$1.statSync(t);
  } catch (e) {
    if (e && ("ENOENT" === e.code || "ENOTDIR" === e.code)) return !1;
    throw e;
  }
  return s.isFile() || s.isFIFO();
}, defaultIsDir$1 = function e(t) {
  try {
    var s = fs$1.statSync(t);
  } catch (e) {
    if (e && ("ENOENT" === e.code || "ENOTDIR" === e.code)) return !1;
    throw e;
  }
  return s.isDirectory();
}, defaultRealpathSync = function e(t) {
  try {
    return realpathFS$1(t);
  } catch (e) {
    if ("ENOENT" !== e.code) throw e;
  }
  return t;
}, maybeRealpathSync = function e(t, s, r) {
  return r && !1 === r.preserveSymlinks ? t(s) : s;
}, getPackageCandidates$1 = function e(t, s, r) {
  var n, i = nodeModulesPaths(s, r, t);
  for (n = 0; n < i.length; n++) i[n] = path$1__default.join(i[n], t);
  return i;
}, sync = function e(t, s) {
  function r(e) {
    var t, s, r, n, l = function e(t) {
      var s, r, n;
      if ("" !== t && "/" !== t && !("win32" === process.platform && /^\w:[/\\]*$/.test(t) || /[/\\]node_modules[/\\]*$/.test(t))) {
        if (s = path$1__default.join(maybeRealpathSync(c, t, i), "package.json"), !o(s)) return e(path$1__default.dirname(t));
        r = a(s);
        try {
          n = JSON.parse(r);
        } catch (e) {}
        return n && i.packageFilter && (n = i.packageFilter(n, t)), {
          pkg: n,
          dir: t
        };
      }
    }(path$1__default.dirname(e));
    if (l && l.dir && l.pkg && i.pathFilter && (t = path$1__default.relative(l.dir, e), 
    (s = i.pathFilter(l.pkg, e, t)) && (e = path$1__default.resolve(l.dir, s))), o(e)) return e;
    for (r = 0; r < h.length; r++) if (n = e + h[r], o(n)) return n;
  }
  function n(e) {
    var t, s, l, u, h, d = path$1__default.join(maybeRealpathSync(c, e, i), "/package.json");
    if (o(d)) {
      try {
        t = a(d, "UTF8"), s = JSON.parse(t);
      } catch (e) {}
      if (s && i.packageFilter && (s = i.packageFilter(s, e)), s && s.main) {
        if ("string" != typeof s.main) throw (l = new TypeError("package “" + s.name + "” `main` must be a string")).code = "INVALID_PACKAGE_MAIN", 
        l;
        "." !== s.main && "./" !== s.main || (s.main = "index");
        try {
          if (u = r(path$1__default.resolve(e, s.main))) return u;
          if (h = n(path$1__default.resolve(e, s.main))) return h;
        } catch (e) {}
      }
    }
    return r(path$1__default.join(e, "/index"));
  }
  var i, o, a, l, c, u, h, d, p, f, m, g, y, w;
  if ("string" != typeof t) throw new TypeError("Path must be a string.");
  if (i = normalizeOptions(0, s), o = i.isFile || defaultIsFile$1, a = i.readFileSync || fs$1.readFileSync, 
  l = i.isDirectory || defaultIsDir$1, c = i.realpathSync || defaultRealpathSync, 
  u = i.packageIterator, h = i.extensions || [ ".js" ], d = i.basedir || path$1__default.dirname(caller()), 
  p = i.filename || d, i.paths = i.paths || [], f = maybeRealpathSync(c, path$1__default.resolve(d), i), 
  /^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(t)) {
    if (m = path$1__default.resolve(f, t), "." !== t && ".." !== t && "/" !== t.slice(-1) || (m += "/"), 
    g = r(m) || n(m)) return maybeRealpathSync(c, g, i);
  } else {
    if (isCore(t)) return t;
    if (y = function _(e, t) {
      var s, o, a, c, h = function() {
        return getPackageCandidates$1(e, t, i);
      }, d = u ? u(e, t, h, i) : h();
      for (s = 0; s < d.length; s++) if (o = d[s], l(path$1__default.dirname(o))) {
        if (a = r(o)) return a;
        if (c = n(o)) return c;
      }
    }(t, f)) return maybeRealpathSync(c, y, i);
  }
  throw (w = new Error("Cannot find module '" + t + "' from '" + p + "'")).code = "MODULE_NOT_FOUND", 
  w;
}, async.core = core_1, async.isCore = isCore, async.sync = sync, resolve = async;

const createSystem = e => {
  const t = e && e.logger ? e.logger : (() => {
    let e = IS_BROWSER_ENV, t = "info";
    return {
      enableColors: t => e = t,
      getLevel: () => t,
      setLevel: e => t = e,
      emoji: e => e,
      info: console.log.bind(console),
      warn: console.warn.bind(console),
      error: console.error.bind(console),
      debug: console.debug.bind(console),
      red: e => e,
      green: e => e,
      yellow: e => e,
      blue: e => e,
      magenta: e => e,
      cyan: e => e,
      gray: e => e,
      bold: e => e,
      dim: e => e,
      bgRed: e => e,
      createTimeSpan: (e, t = !1) => ({
        duration: () => 0,
        finish: () => 0
      }),
      printDiagnostics(t) {
        t.forEach(t => ((e, t) => {
          let s = BLUE, r = "Build", n = "";
          "error" === e.level ? (s = RED, r = "Error") : "warn" === e.level && (s = YELLOW, 
          r = "Warning"), e.header && (r = e.header);
          const i = e.relFilePath || e.absFilePath;
          if (i && (n += i, "number" == typeof e.lineNumber && e.lineNumber > 0 && (n += ", line " + e.lineNumber, 
          "number" == typeof e.columnNumber && e.columnNumber > 0 && (n += ", column " + e.columnNumber)), 
          n += "\n"), n += e.messageText, e.lines && e.lines.length > 0 && (e.lines.forEach(e => {
            n += "\n" + e.lineNumber + ":  " + e.text;
          }), n += "\n"), t) {
            const e = [ "%c" + r, `background: ${s}; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;` ];
            console.log(...e, n);
          } else "error" === e.level ? console.error(n) : "warn" === e.level ? console.warn(n) : console.log(n);
        })(t, e));
      }
    };
  })(), s = new Map, r = new Set, n = e => r.add(e), i = e => r.delete(e), o = (() => {
    const e = [], t = t => {
      const s = e.findIndex(e => e.callback === t);
      return s > -1 && (e.splice(s, 1), !0);
    };
    return {
      emit: (t, s) => {
        const r = t.toLowerCase().trim(), n = e.slice();
        for (const e of n) if (null == e.eventName) try {
          e.callback(t, s);
        } catch (e) {
          console.error(e);
        } else if (e.eventName === r) try {
          e.callback(s);
        } catch (e) {
          console.error(e);
        }
      },
      on: (s, r) => {
        if ("function" == typeof s) {
          const r = null, n = s;
          return e.push({
            eventName: r,
            callback: n
          }), () => t(n);
        }
        if ("string" == typeof s && "function" == typeof r) {
          const n = s.toLowerCase().trim(), i = r;
          return e.push({
            eventName: n,
            callback: i
          }), () => t(i);
        }
        return () => !1;
      },
      unsubscribeAll: () => {
        e.length = 0;
      }
    };
  })(), a = IS_BROWSER_ENV && navigator.hardwareConcurrency || 1, l = e => {
    if ("/" === e || "" === e) return "/";
    const t = path$1.dirname(e), s = path$1.basename(e);
    return t.endsWith("/") ? normalizePath(`${t}${s}`) : normalizePath(`${t}/${s}`);
  }, c = e => {
    const t = s.get(l(e));
    return !(!t || !t.isDirectory && !t.isFile);
  }, u = (e, t) => {
    e = l(e);
    const s = {
      basename: path$1.basename(e),
      dirname: path$1.dirname(e),
      path: e,
      newDirs: [],
      error: null
    };
    return h(e, t, s), s;
  }, h = (e, t, r) => {
    const n = path$1.dirname(e);
    t && t.recursive && !(e => "/" === e || windowsPathRegex.test(e))(n) && h(n, t, r);
    const i = s.get(e);
    i ? (i.isDirectory = !0, i.isFile = !1) : (s.set(e, {
      basename: path$1.basename(e),
      dirname: n,
      isDirectory: !0,
      isFile: !1,
      watcherCallbacks: null,
      data: void 0
    }), r.newDirs.push(e), v(e, new Set));
  }, d = e => {
    e = l(e);
    const t = [], r = s.get(e);
    return r && r.isDirectory && s.forEach((s, r) => {
      "/" !== r && (e.endsWith("/") && `${e}${s.basename}` === r || `${e}/${s.basename}` === r) && t.push(r);
    }), t.sort();
  }, p = e => {
    e = l(e);
    const t = s.get(e);
    if (t && t.isFile) return t.data;
  }, f = e => ({
    path: l(e),
    error: null
  }), m = (e, t, r) => {
    const n = w(e);
    if (n && !r.error) if (n.isFile()) {
      const n = path$1.dirname(t), i = u(n, {
        recursive: !0
      }), o = s.get(e).data, a = b(t, o);
      r.newDirs.push(...i.newDirs), r.renamed.push({
        oldPath: e,
        newPath: t,
        isDirectory: !1,
        isFile: !0
      }), a.error ? r.error = a.error : r.newFiles.push(t);
    } else if (n.isDirectory()) {
      const s = d(e), n = u(t, {
        recursive: !0
      });
      r.newDirs.push(...n.newDirs), r.renamed.push({
        oldPath: e,
        newPath: t,
        isDirectory: !0,
        isFile: !1
      });
      for (const n of s) {
        const s = n.replace(e, t);
        m(n, s, r);
      }
    }
  }, g = (e, t = {}) => {
    const s = {
      basename: path$1.basename(e),
      dirname: path$1.dirname(e),
      path: e,
      removedDirs: [],
      removedFiles: [],
      error: null
    };
    return y(e, t, s), s;
  }, y = (e, t, r) => {
    if (!r.error) {
      e = l(e);
      const n = d(e);
      if (t && t.recursive) for (const e of n) {
        const n = s.get(e);
        if (n) if (n.isDirectory) y(e, t, r); else if (n.isFile) {
          const t = _(e);
          t.error ? r.error = t.error : r.removedFiles.push(e);
        }
      } else if (n.length > 0) return void (r.error = "cannot delete directory that contains files/subdirectories");
      s.delete(e), v(e, new Set), r.removedDirs.push(e);
    }
  }, w = e => {
    e = l(e);
    const t = s.get(e);
    if (t && (t.isDirectory || t.isFile)) return {
      isDirectory: () => t.isDirectory,
      isFile: () => t.isFile,
      isSymbolicLink: () => !1,
      size: t.isFile ? t.data.length : 0
    };
  }, _ = e => {
    e = l(e);
    const t = {
      basename: path$1.basename(e),
      dirname: path$1.dirname(e),
      path: e,
      error: null
    }, r = s.get(e);
    if (r) {
      if (r.watcherCallbacks) for (const t of r.watcherCallbacks) t(e, "fileDelete");
      s.delete(e), v(e, new Set);
    }
    return t;
  }, v = (e, t) => {
    const r = l(path$1.dirname(e)), n = s.get(r);
    if (n && n.isDirectory && n.watcherCallbacks) for (const t of n.watcherCallbacks) t(e, null);
    t.has(r) || (t.add(r), v(r, t));
  }, b = (e, t) => {
    const r = {
      path: e = l(e),
      error: null
    }, n = s.get(e);
    if (n) {
      const s = n.data !== t;
      if (n.data = t, s && n.watcherCallbacks) for (const t of n.watcherCallbacks) t(e, "fileUpdate");
    } else s.set(e, {
      basename: path$1.basename(e),
      dirname: path$1.dirname(e),
      isDirectory: !1,
      isFile: !0,
      watcherCallbacks: null,
      data: t
    }), v(e, new Set);
    return r;
  }, E = Promise.resolve();
  u("/");
  const T = {
    name: "in-memory",
    version: "0.0.0",
    events: o,
    access: async e => c(e),
    accessSync: c,
    addDestory: n,
    copyFile: async (e, t) => (b(t, p(e)), !0),
    destroy: async () => {
      const e = [];
      r.forEach(s => {
        try {
          const t = s();
          t && t.then && e.push(t);
        } catch (e) {
          t.error("stencil sys destroy: " + e);
        }
      }), await Promise.all(e), r.clear();
    },
    encodeToBase64: e => btoa(unescape(encodeURIComponent(e))),
    exit: e => t.warn("exit " + e),
    getCurrentDirectory: () => "/",
    getCompilerExecutingPath: () => IS_WEB_WORKER_ENV ? location.href : T.getRemoteModuleUrl({
      moduleId: "@stencil/core",
      path: "compiler/stencil.min.js"
    }),
    getLocalModulePath: e => path$1.join(e.rootDir, "node_modules", e.moduleId, e.path),
    getRemoteModuleUrl: e => {
      const t = `${e.moduleId}${e.version ? "@" + e.version : ""}/${e.path}`;
      return new URL(t, "https://cdn.jsdelivr.net/npm/").href;
    },
    hardwareConcurrency: a,
    isSymbolicLink: async e => !1,
    mkdir: async (e, t) => u(e, t),
    mkdirSync: u,
    nextTick: e => E.then(e),
    normalizePath: l,
    platformPath: pathBrowserify,
    readdir: async e => d(e),
    readdirSync: d,
    readFile: async e => p(e),
    readFileSync: p,
    realpath: async e => f(e),
    realpathSync: f,
    removeDestory: i,
    rename: async (e, t) => {
      const s = {
        oldPath: e = normalizePath(e),
        newPath: t = normalizePath(t),
        renamed: [],
        oldDirs: [],
        oldFiles: [],
        newDirs: [],
        newFiles: [],
        isFile: !1,
        isDirectory: !1,
        error: null
      }, r = w(e);
      if (r) {
        if (r.isFile() ? s.isFile = !0 : r.isDirectory() && (s.isDirectory = !0), m(e, t, s), 
        !s.error) if (s.isDirectory) {
          const t = g(e, {
            recursive: !0
          });
          t.error ? s.error = t.error : (s.oldDirs.push(...t.removedDirs), s.oldFiles.push(...t.removedFiles));
        } else if (s.isFile) {
          const t = _(e);
          t.error ? s.error = t.error : s.oldFiles.push(e);
        }
      } else s.error = e + " does not exist";
      return s;
    },
    resolvePath: e => l(e),
    rmdir: async (e, t = {}) => g(e, t),
    rmdirSync: g,
    stat: async e => w(e),
    statSync: w,
    tmpdir: () => "/.tmp",
    unlink: async e => _(e),
    unlinkSync: _,
    watchDirectory: (e, t) => {
      e = l(e);
      const r = s.get(e), o = () => {
        const r = s.get(e);
        if (r && r.watcherCallbacks) {
          const e = r.watcherCallbacks.indexOf(t);
          e > -1 && r.watcherCallbacks.splice(e, 1);
        }
      };
      return n(o), r ? (r.isDirectory = !0, r.isFile = !1, r.watcherCallbacks = r.watcherCallbacks || [], 
      r.watcherCallbacks.push(t)) : s.set(e, {
        basename: path$1.basename(e),
        dirname: path$1.dirname(e),
        isDirectory: !0,
        isFile: !1,
        watcherCallbacks: [ t ],
        data: void 0
      }), {
        close() {
          i(o), o();
        }
      };
    },
    watchFile: (e, t) => {
      e = l(e);
      const r = s.get(e), o = () => {
        const r = s.get(e);
        if (r && r.watcherCallbacks) {
          const e = r.watcherCallbacks.indexOf(t);
          e > -1 && r.watcherCallbacks.splice(e, 1);
        }
      };
      return n(o), r ? (r.isDirectory = !1, r.isFile = !0, r.watcherCallbacks = r.watcherCallbacks || [], 
      r.watcherCallbacks.push(t)) : s.set(e, {
        basename: path$1.basename(e),
        dirname: path$1.dirname(e),
        isDirectory: !0,
        isFile: !1,
        watcherCallbacks: [ t ],
        data: void 0
      }), {
        close() {
          i(o), o();
        }
      };
    },
    watchTimeout: 32,
    writeFile: async (e, t) => b(e, t),
    writeFileSync: b,
    generateContentHash: async (e, t) => {
      const s = await crypto.subtle.digest("SHA-256", (new TextEncoder).encode(e));
      let r = Array.from(new Uint8Array(s)).map(e => e.toString(16).padStart(2, "0")).join("");
      return "number" == typeof t && (r = r.substr(0, t)), r;
    },
    createWorkerController: HAS_WEB_WORKER ? e => ((e, t) => {
      let s, r = 0, n = !1, i = !1, o = 0;
      const a = new Map, l = [], c = [], u = Math.max(Math.min(t, e.hardwareConcurrency), 2) - 1, h = Promise.resolve(), d = e => console.error(e), p = () => {
        let t = null;
        const r = e.getCompilerExecutingPath(), i = {
          name: "stencil.worker." + o++
        };
        try {
          t = new Worker(r, i);
        } catch (e) {
          null == s && (s = new Blob([ `importScripts('${r}');` ], {
            type: "application/javascript"
          })), t = new Worker(URL.createObjectURL(s), i);
        }
        const l = {
          worker: t,
          activeTasks: 0,
          sendQueue: []
        };
        return t.onerror = d, t.onmessage = e => ((e, t) => {
          if (!n) {
            const s = t.data;
            if (Array.isArray(s)) for (const t of s) if (t) {
              const s = a.get(t.stencilId);
              s ? (a.delete(t.stencilId), t.stencilRtnError ? s.reject(t.stencilRtnError) : s.resolve(t.stencilRtnValue), 
              e.activeTasks--, (e.activeTasks < 0 || e.activeTasks > 50) && (e.activeTasks = 0)) : t.stencilRtnError && console.error(t.stencilRtnError);
            }
          }
        })(l, e), l;
      }, f = e => {
        e.sendQueue.length > 0 && (e.worker.postMessage(e.sendQueue), e.sendQueue.length = 0);
      }, m = e => {
        let t;
        if (c.length > 0) {
          if (t = c[0], u > 1) {
            for (const e of c) e.activeTasks < t.activeTasks && (t = e);
            t.activeTasks > 0 && c.length < u && (t = p(), c.push(t));
          }
        } else t = p(), c.push(t);
        t.activeTasks++, t.sendQueue.push(e);
      }, g = () => {
        i = !1, l.forEach(m), l.length = 0, c.forEach(f);
      }, y = (...e) => new Promise((t, s) => {
        if (n) s("task canceled"); else {
          const n = {
            stencilId: r++,
            args: e
          };
          l.push(n), a.set(n.stencilId, {
            resolve: t,
            reject: s
          }), i || (i = !0, h.then(g));
        }
      });
      return {
        send: y,
        destroy: () => {
          n = !0, a.forEach(e => e.reject("task canceled")), a.clear(), c.forEach(e => e.worker.terminate()), 
          c.length = 0;
        },
        handler: e => function(...t) {
          return y(e, ...t);
        },
        maxWorkers: u
      };
    })(T, e) : null,
    details: {
      cpuModel: "",
      freemem: () => 0,
      platform: "",
      release: "",
      totalmem: 0
    },
    copy: async (e, s) => (t.info("todo, copy task", e.length, s), {
      diagnostics: [],
      dirPaths: [],
      filePaths: []
    })
  };
  return T.resolveModuleId = e => ((e, t, s) => {
    const r = ((e, t, s) => ({
      async isFile(r, n) {
        const i = normalizeFsPath(r);
        if ((await t.stat(i)).isFile) n(null, !0); else {
          if (shouldFetchModule(i) && s.some(e => i.endsWith(e))) {
            const s = getNodeModuleFetchUrl(e, packageVersions, i);
            return void n(null, "string" == typeof await fetchModuleAsync(e, t, packageVersions, s, i));
          }
          n(null, !1);
        }
      },
      async isDirectory(s, r) {
        const n = normalizeFsPath(s);
        if ((await t.stat(n)).isDirectory) r(null, !0); else {
          if (shouldFetchModule(n)) {
            if ("node_modules" === path$1.basename(n)) return t.sys.mkdirSync(n), t.clearFileCache(n), 
            void r(null, !0);
            if (isCommonDirModuleFile(n)) return void r(null, !1);
            for (const s of COMMON_DIR_FILENAMES) {
              const i = getCommonDirUrl(e, packageVersions, n, s), o = getCommonDirName(n, s), a = await fetchModuleAsync(e, t, packageVersions, i, o);
              if (isString(a)) return void r(null, !0);
            }
          }
          r(null, !1);
        }
      },
      async readFile(e, s) {
        const r = normalizeFsPath(e), n = await t.readFile(r);
        return isString(n) ? s(null, n) : s("readFile not found: " + e);
      },
      async realpath(t, s) {
        const r = normalizeFsPath(t), n = await e.realpath(r);
        n.error && "ENOENT" !== n.error.code ? s(n.error) : s(null, n.error ? r : n.path);
      },
      extensions: s
    }))(e, null, s.exts);
    return r.basedir = path$1.dirname(normalizeFsPath(s.containingFile)), s.packageFilter ? r.packageFilter = s.packageFilter : null !== s.packageFilter && (r.packageFilter = e => (isString(e.main) && "" !== e.main || (e.main = "package.json"), 
    e)), new Promise((e, t) => {
      resolve(s.moduleId, r, (r, n, i) => {
        if (r) t(r); else {
          n = normalizePath(n);
          const t = {
            moduleId: s.moduleId,
            resolveId: n,
            pkgData: i,
            pkgDirPath: getPackageDirPath(n, s.moduleId)
          };
          e(t);
        }
      });
    });
  })(T, 0, e), T;
}, createTestingSystem = () => {
  let e = 0, t = 0;
  const s = createSystem();
  s.platformPath = path$1__default, s.generateContentHash = (e, t) => {
    let s = crypto$2.createHash("sha1").update(e).digest("hex").toLowerCase();
    return "number" == typeof t && (s = s.substr(0, t)), Promise.resolve(s);
  };
  const r = t => {
    const s = t;
    return (...t) => (e++, s.apply(s, t));
  }, n = e => {
    const s = e;
    return (...e) => (t++, s.apply(s, e));
  };
  return s.access = r(s.access), s.accessSync = r(s.accessSync), s.readFile = r(s.readFile), 
  s.readFileSync = r(s.readFileSync), s.readdir = r(s.readdir), s.readdirSync = r(s.readdirSync), 
  s.stat = r(s.stat), s.statSync = r(s.statSync), s.copyFile = n(s.copyFile), s.mkdir = n(s.mkdir), 
  s.mkdirSync = n(s.mkdirSync), s.unlink = n(s.unlink), s.unlinkSync = n(s.unlinkSync), 
  s.writeFile = n(s.writeFile), s.writeFileSync = n(s.writeFileSync), Object.defineProperties(s, {
    diskReads: {
      get: () => e,
      set(t) {
        e = t;
      }
    },
    diskWrites: {
      get: () => t,
      set(e) {
        t = e;
      }
    }
  });
};

class TestingLogger {
  constructor() {
    this.isEnabled = !1;
  }
  setLevel(e) {}
  getLevel() {
    return "info";
  }
  enableColors(e) {}
  emoji(e) {
    return "";
  }
  info(...e) {
    this.isEnabled && console.log.apply(console, e);
  }
  warn(...e) {
    this.isEnabled && console.warn.apply(console, e);
  }
  error(...e) {
    this.isEnabled && console.error.apply(console, e);
  }
  debug(...e) {
    this.isEnabled && console.log.apply(console, e);
  }
  color(e, t) {}
  red(e) {
    return e;
  }
  green(e) {
    return e;
  }
  yellow(e) {
    return e;
  }
  blue(e) {
    return e;
  }
  magenta(e) {
    return e;
  }
  cyan(e) {
    return e;
  }
  gray(e) {
    return e;
  }
  bold(e) {
    return e;
  }
  dim(e) {
    return e;
  }
  bgRed(e) {
    return e;
  }
  createTimeSpan(e, t = !1) {
    return {
      duration: () => 0,
      finish: () => 0
    };
  }
  printDiagnostics(e) {}
}

class EventSpy {
  constructor(e) {
    this.eventName = e, this.events = [], this.cursor = 0, this.queuedHandler = [];
  }
  get length() {
    return this.events.length;
  }
  get firstEvent() {
    return this.events[0] || null;
  }
  get lastEvent() {
    return this.events[this.events.length - 1] || null;
  }
  next() {
    const e = this.cursor;
    this.cursor++;
    const t = this.events[e];
    if (t) return Promise.resolve({
      done: !1,
      value: t
    });
    {
      let t;
      const s = new Promise(e => t = e);
      return this.queuedHandler.push(t), s.then(() => ({
        done: !1,
        value: this.events[e]
      }));
    }
  }
  push(e) {
    this.events.push(e);
    const t = this.queuedHandler.shift();
    t && t();
  }
}

class E2EElement extends index_cjs_js.MockHTMLElement {
  constructor(e, t) {
    super(null, null), this._page = e, this._elmHandle = t, this._queuedActions = [], 
    e._e2eElements.push(this);
  }
  _queueAction(e) {
    this._queuedActions.push(e);
  }
  find(e) {
    return find(this._page, this._elmHandle, e);
  }
  findAll(e) {
    return findAll(this._page, this._elmHandle, e);
  }
  callMethod(e, ...t) {
    return this._queueAction({
      methodName: e,
      methodArgs: t
    }), this.e2eRunActions();
  }
  triggerEvent(e, t) {
    this._queueAction({
      eventName: e,
      eventInitDict: t
    });
  }
  async spyOnEvent(e) {
    const t = new EventSpy(e);
    return await addE2EListener(this._page, this._elmHandle, e, e => {
      t.push(e);
    }), t;
  }
  async click(e) {
    await this._elmHandle.click(e), await this._page.waitForChanges();
  }
  async focus() {
    await this._elmHandle.focus(), await this._page.waitForChanges();
  }
  async hover() {
    await this._elmHandle.hover(), await this._page.waitForChanges();
  }
  async isVisible() {
    this._validate();
    let e = !1;
    try {
      const t = this._elmHandle.executionContext();
      e = await t.evaluate(e => new Promise(t => {
        window.requestAnimationFrame(() => {
          if (e.isConnected) {
            const s = window.getComputedStyle(e);
            s && "none" !== s.display && "hidden" !== s.visibility && "0" !== s.opacity ? window.requestAnimationFrame(() => {
              e.clientWidth, t(!0);
            }) : t(!1);
          } else t(!1);
        });
      }), this._elmHandle);
    } catch (e) {}
    return e;
  }
  waitForEvent(e) {
    return waitForEvent(this._page, e, this._elmHandle);
  }
  waitForVisible() {
    return new Promise((e, t) => {
      const s = setInterval(async () => {
        await this.isVisible() && (clearInterval(s), clearTimeout(i), e());
      }, 10), r = .5 * jasmine.DEFAULT_TIMEOUT_INTERVAL, n = new Error(`waitForVisible timed out: ${r}ms`), i = setTimeout(() => {
        clearTimeout(s), t(n);
      }, r);
    });
  }
  waitForNotVisible() {
    return new Promise((e, t) => {
      const s = setInterval(async () => {
        await this.isVisible() || (clearInterval(s), clearTimeout(i), e());
      }, 10), r = .5 * jasmine.DEFAULT_TIMEOUT_INTERVAL, n = new Error(`waitForNotVisible timed out: ${r}ms`), i = setTimeout(() => {
        clearTimeout(s), t(n);
      }, r);
    });
  }
  isIntersectingViewport() {
    return this._elmHandle.isIntersectingViewport();
  }
  async press(e, t) {
    await this._elmHandle.press(e, t), await this._page.waitForChanges();
  }
  async tap() {
    await this._elmHandle.tap(), await this._page.waitForChanges();
  }
  async type(e, t) {
    await this._elmHandle.type(e, t), await this._page.waitForChanges();
  }
  async getProperty(e) {
    this._validate();
    const t = this._elmHandle.executionContext();
    return await t.evaluate((e, t) => e[t], this._elmHandle, e);
  }
  setProperty(e, t) {
    this._queueAction({
      setPropertyName: e,
      setPropertyValue: t
    });
  }
  getAttribute(e) {
    return this._validate(), super.getAttribute(e);
  }
  setAttribute(e, t) {
    this._queueAction({
      setAttributeName: e,
      setAttributeValue: t
    });
  }
  removeAttribute(e) {
    this._queueAction({
      removeAttribute: e
    });
  }
  toggleAttribute(e, t) {
    this._queueAction({
      toggleAttributeName: e,
      toggleAttributeForce: t
    });
  }
  get classList() {
    return {
      add: (...e) => {
        e.forEach(e => {
          this._queueAction({
            classAdd: e
          });
        });
      },
      remove: (...e) => {
        e.forEach(e => {
          this._queueAction({
            classRemove: e
          });
        });
      },
      toggle: e => {
        this._queueAction({
          classToggle: e
        });
      },
      contains: e => (this._validate(), super.className.split(" ").includes(e))
    };
  }
  get className() {
    return this._validate(), super.className;
  }
  set className(e) {
    this._queueAction({
      setPropertyName: "className",
      setPropertyValue: e
    });
  }
  get id() {
    return this._validate(), super.id;
  }
  set id(e) {
    this._queueAction({
      setPropertyName: "id",
      setPropertyValue: e
    });
  }
  get innerHTML() {
    return this._validate(), super.innerHTML;
  }
  set innerHTML(e) {
    this._queueAction({
      setPropertyName: "innerHTML",
      setPropertyValue: e
    });
  }
  get innerText() {
    return this._validate(), super.innerText;
  }
  set innerText(e) {
    this._queueAction({
      setPropertyName: "innerText",
      setPropertyValue: e
    });
  }
  get nodeValue() {
    return this._validate(), super.nodeValue;
  }
  set nodeValue(e) {
    "string" == typeof e && this._queueAction({
      setPropertyName: "nodeValue",
      setPropertyValue: e
    });
  }
  get outerHTML() {
    return this._validate(), super.outerHTML;
  }
  set outerHTML(e) {
    throw new Error("outerHTML is read-only");
  }
  get shadowRoot() {
    return this._validate(), super.shadowRoot;
  }
  set shadowRoot(e) {
    super.shadowRoot = e;
  }
  get tabIndex() {
    return this._validate(), super.tabIndex;
  }
  set tabIndex(e) {
    this._queueAction({
      setPropertyName: "tabIndex",
      setPropertyValue: e
    });
  }
  get textContent() {
    return this._validate(), super.textContent;
  }
  set textContent(e) {
    this._queueAction({
      setPropertyName: "textContent",
      setPropertyValue: e
    });
  }
  get title() {
    return this._validate(), super.title;
  }
  set title(e) {
    this._queueAction({
      setPropertyName: "title",
      setPropertyValue: e
    });
  }
  async getComputedStyle(e) {
    const t = await this._page.evaluate((e, t) => {
      const s = {}, r = window.getComputedStyle(e, t);
      return Object.keys(r).forEach(e => {
        if (isNaN(e)) {
          const t = r[e];
          null != t && (s[e] = t);
        } else {
          const t = r[e];
          if (t.includes("-")) {
            const e = r.getPropertyValue(t);
            null != e && (s[t] = e);
          }
        }
      }), s;
    }, this._elmHandle, e);
    return t.getPropertyValue = e => t[e], t;
  }
  async e2eRunActions() {
    if (0 === this._queuedActions.length) return;
    const e = this._elmHandle.executionContext(), t = await e.evaluate((e, t) => e.componentOnReady().then(() => {
      let s = null;
      return t.forEach(t => {
        if (t.methodName) s = e[t.methodName].apply(e, t.methodArgs); else if (t.setPropertyName) e[t.setPropertyName] = t.setPropertyValue; else if (t.setAttributeName) e.setAttribute(t.setAttributeName, t.setAttributeValue); else if (t.removeAttribute) e.removeAttribute(t.removeAttribute); else if (t.toggleAttributeName) "boolean" == typeof t.toggleAttributeForce ? e.toggleAttribute(t.toggleAttributeName, t.toggleAttributeForce) : e.toggleAttribute(t.toggleAttributeName); else if (t.classAdd) e.classList.add(t.classAdd); else if (t.classRemove) e.classList.remove(t.classRemove); else if (t.classToggle) e.classList.toggle(t.classToggle); else if (t.eventName) {
          const s = t.eventInitDict || {};
          "boolean" != typeof s.bubbles && (s.bubbles = !0), "boolean" != typeof s.cancelable && (s.cancelable = !0), 
          "boolean" != typeof s.composed && (s.composed = !0);
          const r = new CustomEvent(t.eventName, s);
          e.dispatchEvent(r);
        }
      }), s && "function" == typeof s.then ? s.then(e => e) : s;
    }), this._elmHandle, this._queuedActions);
    return this._queuedActions.length = 0, t;
  }
  async e2eSync() {
    const e = this._elmHandle.executionContext(), {outerHTML: t, shadowRootHTML: s} = await e.evaluate(e => ({
      outerHTML: e.outerHTML,
      shadowRootHTML: e.shadowRoot ? e.shadowRoot.innerHTML : null
    }), this._elmHandle);
    "string" == typeof s ? (this.shadowRoot = index_cjs_js.parseHtmlToFragment(s), this.shadowRoot.host = this) : this.shadowRoot = null;
    const r = index_cjs_js.parseHtmlToFragment(t).firstElementChild;
    for (this.nodeName = r.nodeName, this.attributes = index_cjs_js.cloneAttributes(r.attributes); this.childNodes.length > 0; ) this.removeChild(this.childNodes[0]);
    for (;r.childNodes.length > 0; ) this.appendChild(r.childNodes[0]);
  }
  _validate() {
    if (this._queuedActions.length > 0) throw new Error("await page.waitForChanges() must be called before reading element information");
  }
  async e2eDispose() {
    this._elmHandle && (await this._elmHandle.dispose(), this._elmHandle = null);
    const e = this._page._e2eElements.indexOf(this);
    e > -1 && this._page._e2eElements.splice(e, 1), this._page = null;
  }
}

const env = process.env;

exports.MockHeaders = MockHeaders, exports.MockRequest = MockRequest, exports.MockResponse = MockResponse, 
exports.createJestPuppeteerEnvironment = function createJestPuppeteerEnvironment() {
  const e = require("jest-environment-node");
  return class extends e {
    constructor(e) {
      super(e), this.browser = null, this.pages = [];
    }
    async setup() {
      "true" === process.env.__STENCIL_E2E_TESTS__ && (this.global.__NEW_TEST_PAGE__ = this.newPuppeteerPage.bind(this), 
      this.global.__CLOSE_OPEN_PAGES__ = this.closeOpenPages.bind(this));
    }
    async newPuppeteerPage() {
      this.browser || (this.browser = await async function e() {
        const e = process.env, t = e.__STENCIL_BROWSER_WS_ENDPOINT__;
        if (!t) return null;
        const s = {
          browserWSEndpoint: t,
          ignoreHTTPSErrors: !0
        }, r = require(e.__STENCIL_PUPPETEER_MODULE__);
        return await r.connect(s);
      }());
      const t = await function s(e) {
        return e.newPage();
      }(this.browser);
      this.pages.push(t);
      const r = process.env;
      return "string" == typeof r.__STENCIL_DEFAULT_TIMEOUT__ && t.setDefaultTimeout(parseInt(r.__STENCIL_DEFAULT_TIMEOUT__, 10)), 
      t;
    }
    async closeOpenPages() {
      await Promise.all(this.pages.map(e => e.close())), this.pages.length = 0;
    }
    async teardown() {
      await super.teardown(), await this.closeOpenPages(), await async function e(t) {
        if (t) try {
          t.disconnect();
        } catch (e) {}
      }(this.browser), this.browser = null;
    }
  };
}, exports.createTestRunner = function createTestRunner() {
  const e = require("jest-runner");
  return class t extends e {
    async runTests(e, t, s, r, n, i) {
      const o = process.env;
      if (e = e.filter(e => function t(e, s) {
        const r = (e = e.toLowerCase().replace(/\\/g, "/")).includes(".e2e.") || e.includes("/e2e.");
        return !("true" !== s.__STENCIL_E2E_TESTS__ || !r) || "true" === s.__STENCIL_SPEC_TESTS__ && !r;
      }(e.path, o)), "true" === o.__STENCIL_SCREENSHOT__) {
        const a = JSON.parse(o.__STENCIL_EMULATE_CONFIGS__);
        for (let l = 0; l < a.length; l++) setScreenshotEmulateData(a[l], o), await super.runTests(e, t, s, r, n, i);
      } else await super.runTests(e, t, s, r, n, i);
    }
  };
}, exports.createTesting = async e => {
  e = function t(e) {
    return e.buildEs5 = !1, e.devMode = !0, e.minifyCss = !1, e.minifyJs = !1, e.hashFileNames = !1, 
    e.validateTypes = !1, e._isTesting = !0, e.buildDist = !0, e.flags = e.flags || {}, 
    e.flags.serve = !1, e.flags.open = !1, e.outputTargets.forEach(e => {
      "www" === e.type && (e.serviceWorker = null);
    }), e;
  }(e);
  const {createCompiler: s} = require("../compiler/stencil.js"), r = await s(e);
  let n, i;
  const o = async () => {
    const t = [];
    e && (e.sys && e.sys.destroy && t.push(e.sys.destroy()), e = null), n && (n.close && t.push(n.close()), 
    n = null), i && (i.close && t.push(i.close()), i = null), await Promise.all(t);
  };
  return {
    destroy: o,
    run: async (t = {}) => {
      let s, a = !1, l = !1;
      const c = [];
      try {
        if (!t.spec && !t.e2e) return e.logger.error("Testing requires either the --spec or --e2e command line flags, or both. For example, to run unit tests, use the command: stencil test --spec"), 
        !1;
        if (s = process.env, t.e2e && (c.push("e2e"), s.__STENCIL_E2E_TESTS__ = "true"), 
        t.spec && (c.push("spec"), s.__STENCIL_SPEC_TESTS__ = "true"), e.logger.info(e.logger.magenta(`testing ${c.join(" and ")} files`)), 
        a = !(!t.e2e || !t.screenshot), a && (s.__STENCIL_SCREENSHOT__ = "true", t.updateScreenshot ? e.logger.info(e.logger.magenta("updating master screenshots")) : e.logger.info(e.logger.magenta("comparing against master screenshots"))), 
        t.e2e) {
          let t = null;
          e.outputTargets.forEach(e => {
            e.empty = !1;
          });
          const a = !(e.flags && !1 === e.flags.build);
          a && (t = r.build()), e.devServer.openBrowser = !1, e.devServer.gzip = !1, e.devServer.reloadStrategy = null;
          const l = await Promise.all([ index_js.start(e.devServer, e.logger), startPuppeteerBrowser(e) ]);
          if (n = l[0], i = l[1], a) {
            const s = await t;
            if (!s || !e.watch && hasError(s && s.diagnostics)) return await o(), !1;
          }
          n && (s.__STENCIL_BROWSER_URL__ = n.browserUrl, e.logger.debug("e2e dev server url: " + s.__STENCIL_BROWSER_URL__), 
          s.__STENCIL_APP_SCRIPT_URL__ = function u(e, t) {
            return getAppUrl(e, t, e.fsNamespace + ".esm.js");
          }(e, n.browserUrl), e.logger.debug("e2e app script url: " + s.__STENCIL_APP_SCRIPT_URL__), 
          getAppStyleUrl(e, n.browserUrl) && (s.__STENCIL_APP_STYLE_URL__ = getAppStyleUrl(e, n.browserUrl), 
          e.logger.debug("e2e app style url: " + s.__STENCIL_APP_STYLE_URL__)));
        }
      } catch (t) {
        return e.logger.error(t), !1;
      }
      try {
        l = a ? await async function h(e, t) {
          e.logger.debug("screenshot connector: " + e.testing.screenshotConnector);
          const s = new (require(e.testing.screenshotConnector)), r = path$1.join(e.sys.getCompilerExecutingPath(), "..", "..", "screenshot", "pixel-match.js");
          e.logger.debug("pixelmatch module: " + r);
          const n = e.logger.createTimeSpan("screenshot, initBuild started", !0);
          await s.initBuild({
            buildId: createBuildId(),
            buildMessage: createBuildMessage(),
            buildTimestamp: Date.now(),
            appNamespace: e.namespace,
            rootDir: e.rootDir,
            cacheDir: e.cacheDir,
            packageDir: path$1.join(e.sys.getCompilerExecutingPath(), "..", ".."),
            updateMaster: e.flags.updateScreenshot,
            logger: e.logger,
            allowableMismatchedPixels: e.testing.allowableMismatchedPixels,
            allowableMismatchedRatio: e.testing.allowableMismatchedRatio,
            pixelmatchThreshold: e.testing.pixelmatchThreshold,
            waitBeforeScreenshot: e.testing.waitBeforeScreenshot,
            pixelmatchModulePath: r
          }), e.flags.updateScreenshot || await s.pullMasterBuild(), n.finish("screenshot, initBuild finished");
          const i = await Promise.all([ await s.getMasterBuild(), await s.getScreenshotCache() ]), o = i[0], a = i[1];
          t.__STENCIL_SCREENSHOT_BUILD__ = s.toJson(o, a);
          const l = e.logger.createTimeSpan("screenshot, tests started", !0), c = await runJest(e, t);
          l.finish("screenshot, tests finished, passed: " + c);
          try {
            const t = e.logger.createTimeSpan("screenshot, completeTimespan started", !0);
            let r = await s.completeBuild(o);
            if (t.finish("screenshot, completeTimespan finished"), r) {
              const t = e.logger.createTimeSpan("screenshot, publishBuild started", !0);
              if (r = await s.publishBuild(r), t.finish("screenshot, publishBuild finished"), 
              e.flags.updateScreenshot) r.currentBuild && "string" == typeof r.currentBuild.previewUrl && e.logger.info(e.logger.magenta(r.currentBuild.previewUrl)); else if (r.compare) {
                try {
                  await s.updateScreenshotCache(a, r);
                } catch (t) {
                  e.logger.error(t);
                }
                e.logger.info("screenshots compared: " + r.compare.diffs.length), "string" == typeof r.compare.url && e.logger.info(e.logger.magenta(r.compare.url));
              }
            }
          } catch (t) {
            e.logger.error(t, t.stack);
          }
          return c;
        }(e, s) : await runJest(e, s), e.logger.info("");
      } catch (t) {
        e.logger.error(t);
      }
      return l;
    }
  };
}, exports.jestPreprocessor = jestPreprocessor, exports.jestSetupTestFramework = function jestSetupTestFramework() {
  global.Context = {}, global.resourcesUrl = "/build", expect.extend(expectExtend), 
  expect.addSnapshotSerializer(HtmlSerializer), index_cjs_js.setupGlobal(global), 
  function e(t) {
    const s = t.window;
    "fetch" in s || (s.fetch = function(e) {
      return globalMockFetch(e);
    }), "fetch" in t || (t.fetch = function(e) {
      return globalMockFetch(e);
    });
  }(global), beforeEach(() => {
    testing.resetPlatform(), resetBuildConditionals(appData.BUILD), testing.modeResolutionChain.length = 0;
  }), afterEach(async () => {
    global.__CLOSE_OPEN_PAGES__ && await global.__CLOSE_OPEN_PAGES__(), testing.stopAutoApplyChanges(), 
    index_cjs_js.teardownGlobal(global), global.Context = {}, global.resourcesUrl = "/build";
  });
  const t = jasmine.getEnv();
  null != t && t.addReporter({
    specStarted: e => {
      global.currentSpec = e;
    }
  }), global.screenshotDescriptions = new Set;
  const s = process.env;
  if ("string" == typeof s.__STENCIL_DEFAULT_TIMEOUT__) {
    const e = parseInt(s.__STENCIL_DEFAULT_TIMEOUT__, 10);
    jest.setTimeout(1.5 * e), jasmine.DEFAULT_TIMEOUT_INTERVAL = e;
  }
}, exports.mockBuildCtx = function mockBuildCtx(e, t) {
  return e || (e = mockConfig()), t || (t = mockCompilerCtx(e)), new BuildContext(e, t);
}, exports.mockCompilerCtx = mockCompilerCtx, exports.mockConfig = mockConfig, exports.mockDocument = function mockDocument(e = null) {
  return new index_cjs_js.MockWindow(e).document;
}, exports.mockFetch = mockFetch, exports.mockLogger = function mockLogger() {
  return new TestingLogger;
}, exports.mockStencilSystem = function mockStencilSystem() {
  return createTestingSystem();
}, exports.mockWindow = function mockWindow(e = null) {
  return new index_cjs_js.MockWindow(e);
}, exports.newE2EPage = async function newE2EPage(e = {}) {
  if (!global.__NEW_TEST_PAGE__) throw new Error("newE2EPage() is only available from E2E tests, and ran with the --e2e cmd line flag.");
  const t = await global.__NEW_TEST_PAGE__(), s = [];
  try {
    t._e2eElements = [], t._e2eGoto = t.goto, t._e2eClose = t.close, await async function r(e) {
      if (e.isClosed()) return;
      const t = env.__STENCIL_EMULATE__;
      if (!t) return;
      const s = JSON.parse(t), r = {
        viewport: s.viewport,
        userAgent: s.userAgent
      };
      await e.emulate(r);
    }(t), await t.setCacheEnabled(!1), await initPageEvents(t), function n(e) {
      const t = process.env;
      "true" === t.__STENCIL_SCREENSHOT__ ? e.compareScreenshot = (s, r) => {
        const n = global;
        let i, o = "", a = "";
        if (n.currentSpec && ("string" == typeof n.currentSpec.fullName && (o = n.currentSpec.fullName), 
        "string" == typeof n.currentSpec.testPath && (a = n.currentSpec.testPath)), "string" == typeof s ? (o.length > 0 ? o += ", " + s : o = s, 
        "object" == typeof r && (i = r)) : "object" == typeof s && (i = s), o = o.trim(), 
        i = i || {}, !o) throw new Error(`Invalid screenshot description in "${a}"`);
        if (n.screenshotDescriptions.has(o)) throw new Error(`Screenshot description "${o}" found in "${a}" cannot be used for multiple screenshots and must be unique. To make screenshot descriptions unique within the same test, use the first argument to "compareScreenshot", such as "compareScreenshot('more to the description')".`);
        return n.screenshotDescriptions.add(o), async function l(e, t, s, r, n) {
          if ("string" != typeof t.__STENCIL_EMULATE__) throw new Error("compareScreenshot, missing screenshot emulate env var");
          if ("string" != typeof t.__STENCIL_SCREENSHOT_BUILD__) throw new Error("compareScreenshot, missing screen build env var");
          const i = JSON.parse(t.__STENCIL_EMULATE__), o = JSON.parse(t.__STENCIL_SCREENSHOT_BUILD__);
          await function a(e) {
            return new Promise(t => setTimeout(t, e));
          }(o.timeoutBeforeScreenshot), await e.evaluate(() => new Promise(e => {
            window.requestAnimationFrame(() => {
              e();
            });
          }));
          const l = function c(e) {
            const t = {
              type: "png",
              fullPage: e.fullPage,
              omitBackground: e.omitBackground,
              encoding: "binary"
            };
            return e.clip && (t.clip = {
              x: e.clip.x,
              y: e.clip.y,
              width: e.clip.width,
              height: e.clip.height
            }), t;
          }(n), u = await e.screenshot(l), h = "number" == typeof n.pixelmatchThreshold ? n.pixelmatchThreshold : o.pixelmatchThreshold;
          let d = i.viewport.width, p = i.viewport.height;
          return n && n.clip && ("number" == typeof n.clip.width && (d = n.clip.width), "number" == typeof n.clip.height && (p = n.clip.height)), 
          await compareScreenshot(i, o, u, s, d, p, r, h);
        }(e, t, o, a, i);
      } : e.compareScreenshot = async () => ({
        mismatchedPixels: 0,
        allowableMismatchedPixels: 1,
        allowableMismatchedRatio: 1,
        desc: "",
        width: 1,
        height: 1,
        deviceScaleFactor: 1
      });
    }(t);
    let r = null;
    t.close = async e => {
      try {
        if (Array.isArray(t._e2eElements)) {
          const e = t._e2eElements.map(async e => {
            "function" == typeof e.e2eDispose && await e.e2eDispose();
          });
          await Promise.all(e);
        }
      } catch (e) {}
      const s = () => {
        throw new Error("The page was already closed");
      };
      t._e2eElements = s, t._e2eEvents = s, t._e2eGoto = s, t.find = s, t.debugger = s, 
      t.findAll = s, t.compareScreenshot = s, t.setContent = s, t.spyOnEvent = s, t.waitForChanges = s, 
      t.waitForEvent = s;
      try {
        t.isClosed() || await t._e2eClose(e);
      } catch (e) {}
    };
    const n = async () => (r || (r = t.evaluateHandle(() => document)), (await r).asElement());
    t.find = async e => {
      const s = await n();
      return find(t, s, e);
    }, t.findAll = async e => {
      const s = await n();
      return findAll(t, s, e);
    }, t.waitForEvent = async e => {
      const s = await n();
      return waitForEvent(t, e, s);
    }, t.getDiagnostics = () => s, t.waitForChanges = waitForChanges.bind(null, t), 
    t.debugger = () => {
      if ("true" !== env.__STENCIL_E2E_DEVTOOLS__) throw new Error("Set the --devtools flag in order to use E2EPage.debugger()");
      return t.evaluate(() => new Promise(e => {
        e();
      }));
    };
    const i = !0 === e.failOnConsoleError, o = !0 === e.failOnNetworkError;
    t.on("console", e => {
      "error" === e.type() && (s.push({
        type: "error",
        message: e.text(),
        location: e.location().url
      }), i && fail(new Error(serializeConsoleMessage(e)))), function t(e) {
        const t = serializeConsoleMessage(e), s = e.type(), r = "warning" === s ? "warn" : s;
        "debug" !== r && ("function" == typeof console[r] ? console[r](t) : console.log(s, t));
      }(e);
    }), t.on("pageerror", e => {
      s.push({
        type: "pageerror",
        message: e.message,
        location: e.stack
      }), fail(e);
    }), t.on("requestfailed", e => {
      s.push({
        type: "requestfailed",
        message: e.failure().errorText,
        location: e.url()
      }), o ? fail(new Error(e.failure().errorText)) : console.error("requestfailed", e.url());
    }), "string" == typeof e.html ? await e2eSetContent(t, e.html, {
      waitUntil: e.waitUntil
    }) : "string" == typeof e.url ? await e2eGoTo(t, e.url, {
      waitUntil: e.waitUntil
    }) : (t.goto = e2eGoTo.bind(null, t), t.setContent = e2eSetContent.bind(null, t));
  } catch (e) {
    throw t && (t.isClosed() || await t.close()), e;
  }
  return t;
}, exports.newSpecPage = async function newSpecPage(e) {
  if (null == e) throw new Error("NewSpecPageOptions required");
  testing.resetPlatform(), resetBuildConditionals(appData.BUILD), testing.registerContext(e.context), 
  Array.isArray(e.components) && testing.registerComponents(e.components), e.hydrateClientSide && (e.includeAnnotations = !0), 
  e.hydrateServerSide ? (e.includeAnnotations = !0, testing.setSupportsShadowDom(!1)) : (e.includeAnnotations = !!e.includeAnnotations, 
  !1 === e.supportsShadowDom ? testing.setSupportsShadowDom(!1) : testing.setSupportsShadowDom(!0)), 
  appData.BUILD.cssAnnotations = e.includeAnnotations;
  const t = new Set;
  testing.win.__stencil_spec_options = e;
  const s = testing.win.document, r = {
    win: testing.win,
    doc: s,
    body: s.body,
    build: appData.BUILD,
    styles: testing.styles,
    setContent: e => (s.body.innerHTML = e, testing.flushAll()),
    waitForChanges: testing.flushAll,
    flushLoadModule: testing.flushLoadModule,
    flushQueue: testing.flushQueue
  }, n = e.components.map(e => {
    if (null == e.COMPILER_META) throw new Error('Invalid component class: Missing static "COMPILER_META" property.');
    t.add(e.COMPILER_META.tagName), e.isProxied = !1, function s(e) {
      "function" == typeof e.prototype.__componentWillLoad && (e.prototype.componentWillLoad = e.prototype.__componentWillLoad, 
      e.prototype.__componentWillLoad = null), "function" == typeof e.prototype.__componentWillUpdate && (e.prototype.componentWillUpdate = e.prototype.__componentWillUpdate, 
      e.prototype.__componentWillUpdate = null), "function" == typeof e.prototype.__componentWillRender && (e.prototype.componentWillRender = e.prototype.__componentWillRender, 
      e.prototype.__componentWillRender = null), "function" == typeof e.prototype.componentWillLoad && (e.prototype.__componentWillLoad = e.prototype.componentWillLoad, 
      e.prototype.componentWillLoad = function() {
        const e = this.__componentWillLoad();
        return null != e && "function" == typeof e.then ? testing.writeTask(() => e) : testing.writeTask(() => Promise.resolve()), 
        e;
      }), "function" == typeof e.prototype.componentWillUpdate && (e.prototype.__componentWillUpdate = e.prototype.componentWillUpdate, 
      e.prototype.componentWillUpdate = function() {
        const e = this.__componentWillUpdate();
        return null != e && "function" == typeof e.then ? testing.writeTask(() => e) : testing.writeTask(() => Promise.resolve()), 
        e;
      }), "function" == typeof e.prototype.componentWillRender && (e.prototype.__componentWillRender = e.prototype.componentWillRender, 
      e.prototype.componentWillRender = function() {
        const e = this.__componentWillRender();
        return null != e && "function" == typeof e.then ? testing.writeTask(() => e) : testing.writeTask(() => Promise.resolve()), 
        e;
      });
    }(e);
    const r = `${e.COMPILER_META.tagName}.${Math.round(899999 * Math.random()) + 1e5}`, n = e.COMPILER_META.styles;
    if (Array.isArray(n)) if (n.length > 1) {
      const t = {};
      n.forEach(e => {
        t[e.modeName] = e.styleStr;
      }), e.style = t;
    } else 1 === n.length && (e.style = n[0].styleStr);
    return testing.registerModule(r, e), ((e, t) => [ e, t.map(e => formatComponentRuntimeMeta(e, !0)) ])(r, [ e.COMPILER_META ]);
  }), i = (e => {
    const t = e.some(e => e.htmlTagNames.includes("slot")), s = e.some(e => "shadow" === e.encapsulation), r = e.some(e => "shadow" !== e.encapsulation && e.htmlTagNames.includes("slot")), n = {
      allRenderFn: e.every(e => e.hasRenderFn),
      cmpDidLoad: e.some(e => e.hasComponentDidLoadFn),
      cmpShouldUpdate: e.some(e => e.hasComponentShouldUpdateFn),
      cmpDidUnload: e.some(e => e.hasComponentDidUnloadFn),
      cmpDidUpdate: e.some(e => e.hasComponentDidUpdateFn),
      cmpDidRender: e.some(e => e.hasComponentDidRenderFn),
      cmpWillLoad: e.some(e => e.hasComponentWillLoadFn),
      cmpWillUpdate: e.some(e => e.hasComponentWillUpdateFn),
      cmpWillRender: e.some(e => e.hasComponentWillRenderFn),
      connectedCallback: e.some(e => e.hasConnectedCallbackFn),
      disconnectedCallback: e.some(e => e.hasDisconnectedCallbackFn),
      element: e.some(e => e.hasElement),
      event: e.some(e => e.hasEvent),
      hasRenderFn: e.some(e => e.hasRenderFn),
      lifecycle: e.some(e => e.hasLifecycle),
      asyncLoading: !1,
      hostListener: e.some(e => e.hasListener),
      hostListenerTargetWindow: e.some(e => e.hasListenerTargetWindow),
      hostListenerTargetDocument: e.some(e => e.hasListenerTargetDocument),
      hostListenerTargetBody: e.some(e => e.hasListenerTargetBody),
      hostListenerTargetParent: e.some(e => e.hasListenerTargetParent),
      hostListenerTarget: e.some(e => e.hasListenerTarget),
      member: e.some(e => e.hasMember),
      method: e.some(e => e.hasMethod),
      mode: e.some(e => e.hasMode),
      observeAttribute: e.some(e => e.hasAttribute),
      prop: e.some(e => e.hasProp),
      propBoolean: e.some(e => e.hasPropBoolean),
      propNumber: e.some(e => e.hasPropNumber),
      propString: e.some(e => e.hasPropString),
      propMutable: e.some(e => e.hasPropMutable),
      reflect: e.some(e => e.hasReflect),
      scoped: e.some(e => "scoped" === e.encapsulation),
      shadowDom: s,
      shadowDelegatesFocus: s && e.some(e => e.shadowDelegatesFocus),
      slot: t,
      slotRelocation: r,
      state: e.some(e => e.hasState),
      style: e.some(e => e.hasStyle),
      svg: e.some(e => e.htmlTagNames.includes("svg")),
      updatable: e.some(e => e.isUpdateable),
      vdomAttribute: e.some(e => e.hasVdomAttribute),
      vdomXlink: e.some(e => e.hasVdomXlink),
      vdomClass: e.some(e => e.hasVdomClass),
      vdomFunctional: e.some(e => e.hasVdomFunctional),
      vdomKey: e.some(e => e.hasVdomKey),
      vdomListener: e.some(e => e.hasVdomListener),
      vdomPropOrAttr: e.some(e => e.hasVdomPropOrAttr),
      vdomRef: e.some(e => e.hasVdomRef),
      vdomRender: e.some(e => e.hasVdomRender),
      vdomStyle: e.some(e => e.hasVdomStyle),
      vdomText: e.some(e => e.hasVdomText),
      watchCallback: e.some(e => e.hasWatchCallback),
      taskQueue: !0
    };
    return n.asyncLoading = n.cmpWillUpdate || n.cmpWillLoad || n.cmpWillRender, n.vdomAttribute = n.vdomAttribute || n.reflect, 
    n.vdomPropOrAttr = n.vdomPropOrAttr || n.reflect, n;
  })(e.components.map(e => e.COMPILER_META));
  if (e.strictBuild ? Object.assign(appData.BUILD, i) : Object.keys(i).forEach(e => {
    !0 === i[e] && (appData.BUILD[e] = !0);
  }), appData.BUILD.asyncLoading = !0, e.hydrateClientSide ? (appData.BUILD.hydrateClientSide = !0, 
  appData.BUILD.hydrateServerSide = !1) : e.hydrateServerSide && (appData.BUILD.hydrateServerSide = !0, 
  appData.BUILD.hydrateClientSide = !1), appData.BUILD.cloneNodeFix = !1, appData.BUILD.shadowDomShim = !1, 
  appData.BUILD.safari10 = !1, appData.BUILD.attachStyles = !!e.attachStyles, r.flush = () => (console.warn("DEPRECATED: page.flush(), please use page.waitForChanges() instead"), 
  r.waitForChanges()), "string" == typeof e.url && (r.win.location.href = e.url), 
  "string" == typeof e.direction && r.doc.documentElement.setAttribute("dir", e.direction), 
  "string" == typeof e.language && r.doc.documentElement.setAttribute("lang", e.language), 
  "string" == typeof e.cookie) try {
    r.doc.cookie = e.cookie;
  } catch (e) {}
  if ("string" == typeof e.referrer) try {
    r.doc.referrer = e.referrer;
  } catch (e) {}
  if ("string" == typeof e.userAgent) try {
    r.win.navigator.userAgent = e.userAgent;
  } catch (e) {}
  if (testing.bootstrapLazy(n), "function" == typeof e.template) {
    const t = {
      $ancestorComponent$: void 0,
      $flags$: 0,
      $modeName$: void 0,
      $cmpMeta$: {
        $flags$: 0,
        $tagName$: "body"
      },
      $hostElement$: r.body
    };
    testing.renderVdom(t, e.template());
  } else "string" == typeof e.html && (r.body.innerHTML = e.html);
  !1 !== e.flushQueue && await r.waitForChanges();
  let o = null;
  return Object.defineProperty(r, "root", {
    get() {
      if (null == o && (o = function e(t, s) {
        if (null != s) {
          const r = s.children, n = r.length;
          for (let e = 0; e < n; e++) {
            const s = r[e];
            if (t.has(s.nodeName.toLowerCase())) return s;
          }
          for (let s = 0; s < n; s++) {
            const n = e(t, r[s]);
            if (null != n) return n;
          }
        }
        return null;
      }(t, r.body)), null != o) return o;
      const e = r.body.firstElementChild;
      return null != e ? e : null;
    }
  }), Object.defineProperty(r, "rootInstance", {
    get() {
      const e = testing.getHostRef(r.root);
      return null != e ? e.$lazyInstance$ : null;
    }
  }), e.hydrateServerSide && testing.insertVdomAnnotations(s, []), e.autoApplyChanges && (testing.startAutoApplyChanges(), 
  r.waitForChanges = () => (console.error('waitForChanges() cannot be used manually if the "startAutoApplyChanges" option is enabled'), 
  Promise.resolve())), r;
}, exports.shuffleArray = function shuffleArray(e) {
  let t, s, r = e.length;
  for (;0 !== r; ) s = Math.floor(Math.random() * r), r -= 1, t = e[r], e[r] = e[s], 
  e[s] = t;
  return e;
}, exports.transpile = transpile;