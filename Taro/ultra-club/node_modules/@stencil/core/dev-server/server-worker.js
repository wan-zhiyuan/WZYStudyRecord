function _interopDefault(e) {
  return e && "object" == typeof e && "default" in e ? e.default : e;
}

function sendMsg(e, t) {
  e.send(t);
}

function sendError(e, t) {
  const r = {
    error: {
      message: t
    }
  };
  if ("string" == typeof t) r.error.message = t + ""; else if (t) try {
    r.error.message = util__default.inspect(t) + "";
  } catch (t) {}
  sendMsg(e, r);
}

function responseHeaders(e) {
  return Object.assign({}, DEFAULT_HEADERS, e);
}

function getBrowserUrl(e, t, r, s, n) {
  t = "0.0.0.0" === t ? "localhost" : t;
  const o = r && 80 !== r && 443 !== r ? ":" + r : "";
  let i = s;
  return n.startsWith("/") && (n = n.substring(1)), i += n, `${e = e.replace(/\:/g, "")}://${t}${o}${i}`;
}

function getContentType(e, t) {
  const r = t.replace(/^.*[/\\]/, "").toLowerCase(), s = r.replace(/^.*\./, "").toLowerCase(), n = r.length < t.length;
  return (s.length < r.length - 1 || !n) && e.contentTypes[s] || "application/octet-stream";
}

function isDevClient(e) {
  return e.startsWith("/~dev-server");
}

function isDevServerClient(e) {
  return "/~dev-server" === e;
}

function serve500(e, t, r, s, n) {
  try {
    r.writeHead(500, responseHeaders({
      "content-type": "text/plain; charset=utf-8",
      "x-source": n
    })), r.write(util__default.inspect(s)), r.end(), e.logRequests && sendMsg(process, {
      requestLog: {
        method: t.method,
        url: t.url,
        status: 500
      }
    });
  } catch (e) {
    sendError(process, "serve500: " + e);
  }
}

async function serve404(e, t, r, s) {
  try {
    if ("/favicon.ico" === t.pathname) try {
      const t = path.join(e.devServerDir, "static", "favicon.ico");
      r.writeHead(200, responseHeaders({
        "content-type": "image/x-icon",
        "x-source": "favicon: " + s
      }));
      const n = fs.createReadStream(t);
      return n.on("error", e => {
        r.writeHead(404, responseHeaders({
          "content-type": "text/plain; charset=utf-8",
          "x-source": `createReadStream error: ${e}, ${s}`
        })), r.write(util__default.inspect(e)), r.end();
      }), void n.pipe(r);
    } catch (n) {
      serve500(e, t, r, n, s);
    }
    const n = [ "404 File Not Found", "Url: " + t.pathname, "File: " + t.filePath ].join("\n");
    serve404Content(e, t, r, n, s), e.logRequests && sendMsg(process, {
      requestLog: {
        method: t.method,
        url: t.url,
        status: 404
      }
    });
  } catch (n) {
    serve500(e, t, r, n, s);
  }
}

function serve404Content(e, t, r, s, n) {
  try {
    const e = responseHeaders({
      "content-type": "text/plain; charset=utf-8",
      "x-source": n
    });
    r.writeHead(404, e), r.write(s), r.end();
  } catch (s) {
    serve500(e, t, r, s, "serve404Content: " + n);
  }
}

async function serveFile(e, t, r, s) {
  try {
    if (function n(e) {
      const t = e.toLowerCase().trim().split(".").pop();
      return TXT_EXT.includes(t);
    }(r.filePath)) {
      let n = await t.readFile(r.filePath, "utf8");
      e.websocket && function o(e) {
        return (e = e.toLowerCase().trim()).endsWith(".html") || e.endsWith(".htm");
      }(r.filePath) && !isDevServerClient(r.pathname) ? n = function i(e, t, r) {
        return function n(e, t) {
          return e.includes("</body>") ? e.replace("</body>", t + "</body>") : e.includes("</html>") ? e.replace("</html>", t + "</html>") : `${e}${t}`;
        }(r, `<iframe title="Stencil Dev Server Connector 1.16.4 &#9889;" src="${function s(e, t) {
          let r = e.address, s = e.port;
          return t && (r = t, s = null), getBrowserUrl(e.protocol, r, s, e.basePath, "/~dev-server");
        }(e, t.host)}" style="display:block;width:0;height:0;border:0;visibility:hidden" aria-hidden="true"></iframe>`);
      }(e, r, n) : function a(e) {
        return (e = e.toLowerCase().trim()).endsWith(".css");
      }(r.filePath) && (n = function l(e, t) {
        const r = Url.parse(e), s = querystring.parse(r.query), n = s["s-hmr"], o = s["s-hmr-urls"];
        n && o && o.split(",").forEach(e => {
          urlVersionIds.set(e, n);
        });
        const i = /url\((['"]?)(.*)\1\)/gi;
        let a, l = t;
        for (;null !== (a = i.exec(t)); ) {
          const e = a[2], t = Url.parse(e), r = path.basename(t.pathname), s = urlVersionIds.get(r);
          if (!s) continue;
          const n = querystring.parse(t.query);
          n["s-hmr"] = s, t.search = querystring.stringify(n);
          const o = Url.format(t);
          l = l.replace(e, o);
        }
        return l;
      }(r.url, n)), function c(e, t) {
        if (!e.gzip) return !1;
        if ("GET" !== t.method) return !1;
        const r = t.headers && t.headers["accept-encoding"];
        return "string" == typeof r && !!r.includes("gzip");
      }(e, r) ? (s.writeHead(200, responseHeaders({
        "content-type": getContentType(e, r.filePath) + "; charset=utf-8",
        "content-encoding": "gzip",
        vary: "Accept-Encoding"
      })), zlib.gzip(n, {
        level: 9
      }, (e, t) => {
        s.end(t);
      })) : (s.writeHead(200, responseHeaders({
        "content-type": getContentType(e, r.filePath) + "; charset=utf-8",
        "content-length": buffer.Buffer.byteLength(n, "utf8")
      })), s.write(n), s.end());
    } else s.writeHead(200, responseHeaders({
      "content-type": getContentType(e, r.filePath),
      "content-length": r.stats.size
    })), fs.createReadStream(r.filePath).pipe(s);
    e.logRequests && sendMsg(process, {
      requestLog: {
        method: r.method,
        url: r.url,
        status: 200
      }
    });
  } catch (t) {
    serve500(e, r, s, t, "serveFile");
  }
}

async function serveDevClient(e, t, r, s) {
  try {
    if (function n(e) {
      return e === OPEN_IN_EDITOR_URL;
    }(r.pathname)) return async function o(e, t, r, s) {
      let n = 200;
      const o = {};
      try {
        e.editors.length > 0 ? (await async function i(e, t, r, s) {
          const n = Url.parse(r.url).query, o = querystring.parse(n);
          if ("string" == typeof o.file) {
            if (s.file = o.file, null == o.line || isNaN(o.line) || (s.line = parseInt(o.line, 10)), 
            ("number" != typeof s.line || s.line < 1) && (s.line = 1), null == o.column || isNaN(o.column) || (s.column = parseInt(o.column, 10)), 
            ("number" != typeof s.column || s.column < 1) && (s.column = 1), "string" == typeof o.editor) {
              if (o.editor = o.editor.trim().toLowerCase(), !e.editors.some(e => e.id === o.editor)) return void (s.error = "invalid editor: " + o.editor);
              s.editor = o.editor;
            } else s.editor = e.editors[0].id;
            try {
              const e = await t.stat(s.file);
              s.exists = !!e && e.isFile();
            } catch (e) {
              s.exists = !1;
            }
          } else s.error = "missing file";
        }(e, t, r, o), await async function a(e) {
          if (e.exists && !e.error) try {
            const t = {
              editor: e.editor
            }, r = openInEditorApi.configure(t, t => e.error = t + "");
            if (e.error) return;
            e.open = `${e.file}:${e.line}:${e.column}`, await r.open(e.open);
          } catch (t) {
            e.error = t + "";
          }
        }(o)) : o.error = "no editors available";
      } catch (e) {
        o.error = e + "", n = 500;
      }
      sendMsg(process, {
        requestLog: {
          method: r.method,
          url: r.url,
          status: n
        }
      }), s.writeHead(n, responseHeaders({
        "content-type": "application/json; charset=utf-8"
      })), s.write(JSON.stringify(o, null, 2)), s.end();
    }(e, t, r, s);
    if (isDevServerClient(r.pathname)) return async function i(e, t, r, s) {
      try {
        const n = path.join(e.devServerDir, "connector.html");
        let o = await t.readFile(n, "utf8");
        if ("string" == typeof o) {
          const t = {
            basePath: e.basePath,
            editors: e.editors,
            reloadStrategy: e.reloadStrategy
          };
          o = o.replace("window.__DEV_CLIENT_CONFIG__", JSON.stringify(t)), s.writeHead(200, responseHeaders({
            "content-type": "text/html; charset=utf-8"
          })), s.write(o), s.end();
        } else serve404(e, r, s, "serveDevClientScript");
      } catch (t) {
        serve500(e, r, s, t, "serveDevClientScript");
      }
    }(e, t, r, s);
    if (function a(e) {
      return e === DEV_SERVER_INIT_URL;
    }(r.pathname)) r.filePath = path.join(e.devServerDir, "templates", "initial-load.html"); else {
      const t = r.pathname.replace("/~dev-server/", "");
      r.filePath = path.join(e.devServerDir, "static", t);
    }
    try {
      return r.stats = await t.stat(r.filePath), r.stats ? serveFile(e, t, r, s) : serve404(e, r, s, "serveDevClient no stats");
    } catch (t) {
      return serve404(e, r, s, "serveDevClient stats error " + t);
    }
  } catch (t) {
    return serve500(e, r, s, t, "serveDevClient");
  }
}

function createRequestHandler(e, t) {
  return async function(r, s) {
    try {
      const n = function n(e, t) {
        const r = {
          method: (t.method || "GET").toUpperCase(),
          headers: t.headers,
          acceptHeader: t.headers && "string" == typeof t.headers.accept && t.headers.accept || "",
          url: (t.url || "").trim() || "",
          host: t.headers && "string" == typeof t.headers.host && t.headers.host || null
        }, s = (Url.parse(r.url).pathname || "").replace(/\\/g, "/").split("/");
        return r.pathname = s.map(e => decodeURIComponent(e)).join("/"), r.pathname.length > 0 && !isDevClient(r.pathname) && (r.pathname = "/" + r.pathname.substring(e.basePath.length)), 
        r.filePath = normalizePath(path.normalize(path.join(e.root, path.relative("/", r.pathname)))), 
        r;
      }(e, r);
      if ("" === n.url) return s.writeHead(302, {
        location: "/"
      }), e.logRequests && sendMsg(process, {
        requestLog: {
          method: n.method,
          url: n.url,
          status: 302
        }
      }), s.end();
      if (isDevClient(n.pathname) && e.websocket) return serveDevClient(e, t, n, s);
      if (function o(e) {
        return e.includes("/~dev-module");
      }(n.pathname)) return async function i(e, t, r) {
        try {
          const s = (await function s(e, t) {
            return new Promise(r => {
              t.resolveId = resolveIds++, msgResolves.set(t.resolveId, r), sendMsg(e, t);
            });
          }(process, {
            compilerRequestPath: t.url
          })).compilerRequestResults;
          if (s) {
            const e = {
              "content-type": "application/javascript; charset=utf-8",
              "content-length": Buffer.byteLength(s.content, "utf8"),
              "x-dev-node-module-id": s.nodeModuleId,
              "x-dev-node-module-version": s.nodeModuleVersion,
              "x-dev-node-module-resolved-path": s.nodeResolvedPath,
              "x-dev-node-module-cache-path": s.cachePath,
              "x-dev-node-module-cache-hit": s.cacheHit
            };
            return r.writeHead(s.status, responseHeaders(e)), r.write(s.content), void r.end();
          }
          return serve404(e, t, r, "serveCompilerRequest");
        } catch (s) {
          return serve500(e, t, r, s, "serveCompilerRequest");
        }
      }(e, n, s);
      if (!function a(e, t) {
        return t.endsWith("/") || (t += "/"), e.endsWith("/") || (e += "/"), t.startsWith(e);
      }(e.basePath, n.url)) return e.logRequests && sendMsg(process, {
        requestLog: {
          method: n.method,
          url: n.url,
          status: 404
        }
      }), serve404Content(e, n, s, "404 File Not Found, base path: " + e.basePath, "invalid basePath");
      try {
        if (n.stats = await t.stat(n.filePath), n.stats) {
          if (n.stats.isFile()) return serveFile(e, t, n, s);
          if (n.stats.isDirectory()) return async function l(e, t, r, s) {
            try {
              const n = path.join(r.filePath, "index.html");
              if (r.stats = await t.stat(n), r.stats && r.stats.isFile()) return r.filePath = n, 
              serveFile(e, t, r, s);
            } catch (e) {}
            if (!r.pathname.endsWith("/")) return e.logRequests && sendMsg(process, {
              requestLog: {
                method: r.method,
                url: r.url,
                status: 302
              }
            }), s.writeHead(302, {
              location: r.pathname + "/"
            }), s.end();
            try {
              const n = await t.readdir(r.filePath);
              try {
                if (null == dirTemplate) {
                  const r = path.join(e.devServerDir, "templates", "directory-index.html");
                  dirTemplate = await t.readFile(r, "utf8");
                }
                const o = await async function n(e, t, r) {
                  const s = await async function n(e, t, r) {
                    return await Promise.all(r.map(async r => {
                      const s = path.basename(r), n = await e.stat(r);
                      return {
                        name: s,
                        pathname: Url.resolve(t, s),
                        isDirectory: !(!n || !n.isDirectory())
                      };
                    }));
                  }(e, t, r);
                  return "/" !== t && s.unshift({
                    isDirectory: !0,
                    pathname: "../",
                    name: ".."
                  }), s.map(e => `\n        <li class="${e.isDirectory ? "directory" : "file"}">\n          <a href="${e.pathname}">\n            <span class="icon"></span>\n            <span>${e.name}</span>\n          </a>\n        </li>`).join("");
                }(t, r.pathname, n), i = dirTemplate.replace("{{title}}", r.pathname).replace("{{nav}}", function o(e) {
                  const t = e.split("/");
                  t.pop();
                  let r = "";
                  return t.map((e, t) => (r += e + "/", `<a href="${r}">${0 === t ? "~" : e}</a>`)).join("<span>/</span>") + "<span>/</span>";
                }(r.pathname)).replace("{{files}}", o);
                s.writeHead(200, responseHeaders({
                  "content-type": "text/html; charset=utf-8",
                  "x-directory-index": r.pathname
                })), s.write(i), s.end(), e.logRequests && sendMsg(process, {
                  requestLog: {
                    method: r.method,
                    url: r.url,
                    status: 200
                  }
                });
              } catch (t) {
                serve500(e, r, s, t, "serveDirectoryIndex");
              }
            } catch (t) {
              serve404(e, r, s, "serveDirectoryIndex");
            }
          }(e, t, n, s);
        }
      } catch (e) {}
      const o = [ "notfound" ], i = function c(e, t) {
        return !!e.historyApiFallback && ("GET" === t.method && (!!t.acceptHeader.includes("text/html") && !(!e.historyApiFallback.disableDotRule && t.pathname.includes("."))));
      }(e, n);
      if (o.push("validHistoryApi: " + i), i) try {
        const r = path.join(e.root, e.historyApiFallback.index);
        if (o.push("indexFilePath: " + r), n.stats = await t.stat(r), n.stats && n.stats.isFile()) return n.filePath = r, 
        serveFile(e, t, n, s);
      } catch (e) {
        o.push("notfound error: " + e);
      }
      return serve404(e, n, s, o.join(", "));
    } catch (t) {
      return serve500(e, r, s, t, "not found error");
    }
  };
}

async function nodeCopyTasks(e, t) {
  const r = {
    diagnostics: [],
    dirPaths: [],
    filePaths: []
  };
  try {
    e = ((e, t = (e => e)) => {
      const r = new Set;
      return e.filter(e => {
        const s = t(e);
        return null == s || !r.has(s) && (r.add(s), !0);
      });
    })((n = await Promise.all(e.map(e => async function r(e, t) {
      return (e => {
        const t = {
          "{": "}",
          "(": ")",
          "[": "]"
        }, r = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if ("" === e) return !1;
        let s;
        for (;s = r.exec(e); ) {
          if (s[2]) return !0;
          let r = s.index + s[0].length;
          const n = s[1], o = n ? t[n] : null;
          if (n && o) {
            const t = e.indexOf(o, r);
            -1 !== t && (r = t + 1);
          }
          e = e.slice(r);
        }
        return !1;
      })(e.src) ? await async function r(e, t) {
        return (await asyncGlob(e.src, {
          cwd: t,
          nodir: !0
        })).map(r => function s(e, t, r) {
          const s = path.join(e.dest, e.keepDirStructure ? r : path.basename(r));
          return {
            src: path.join(t, r),
            dest: s,
            warn: e.warn,
            keepDirStructure: e.keepDirStructure
          };
        }(e, t, r));
      }(e, t) : [ {
        src: getSrcAbsPath(t, e.src),
        dest: e.keepDirStructure ? path.join(e.dest, e.src) : e.dest,
        warn: e.warn,
        keepDirStructure: e.keepDirStructure
      } ];
    }(e, t))), e = n.flat ? n.flat(1) : n.reduce((e, t) => (e.push(...t), e), [])), e => e.dest);
    const s = [];
    for (;e.length > 0; ) {
      const t = e.splice(0, 100);
      await Promise.all(t.map(e => processCopyTask(r, s, e)));
    }
    const o = function s(e) {
      const t = [];
      return e.forEach(e => {
        !function r(e, t) {
          (t = normalizePath(t)) !== ROOT_DIR && t + "/" !== ROOT_DIR && "" !== t && (e.includes(t) || e.push(t));
        }(t, path.dirname(e.dest));
      }), t.sort((e, t) => {
        const r = e.split("/").length, s = t.split("/").length;
        return r < s ? -1 : r > s ? 1 : e < t ? -1 : e > t ? 1 : 0;
      }), t;
    }(s);
    try {
      await Promise.all(o.map(e => mkdir(e, {
        recursive: !0
      })));
    } catch (e) {}
    for (;s.length > 0; ) {
      const e = s.splice(0, 100);
      await Promise.all(e.map(e => copyFile(e.src, e.dest)));
    }
  } catch (e) {
    catchError(r.diagnostics, e);
  }
  var n;
  return r;
}

function getSrcAbsPath(e, t) {
  return path.isAbsolute(t) ? t : path.join(e, t);
}

async function processCopyTask(e, t, r) {
  try {
    r.src = normalizePath(r.src), r.dest = normalizePath(r.dest), (await stat(r.src)).isDirectory() ? (e.dirPaths.includes(r.dest) || e.dirPaths.push(r.dest), 
    await async function s(e, t, r) {
      try {
        const s = await readdir(r.src);
        await Promise.all(s.map(async s => {
          const n = {
            src: path.join(r.src, s),
            dest: path.join(r.dest, s),
            warn: r.warn
          };
          await processCopyTask(e, t, n);
        }));
      } catch (t) {
        catchError(e.diagnostics, t);
      }
    }(e, t, r)) : function n(e) {
      return e = e.trim().toLowerCase(), IGNORE.some(t => e.endsWith(t));
    }(r.src) || (e.filePaths.includes(r.dest) || e.filePaths.push(r.dest), t.push(r));
  } catch (t) {
    !1 !== r.warn && (buildError(e.diagnostics).messageText = t.message);
  }
}

function asyncGlob(e, t) {
  return new Promise((r, s) => {
    (0, glob.glob)(e, t, (e, t) => {
      e ? s(e) : r(t);
    });
  });
}

function semiver(e, t, r) {
  return e = e.split("."), t = t.split("."), fn(e[0], t[0]) || fn(e[1], t[1]) || (t[2] = t.slice(2).join("."), 
  (r = /[.-]/.test(e[2] = e.slice(2).join("."))) == /[.-]/.test(t[2]) ? fn(e[2], t[2]) : r ? -1 : 1);
}

async function checkVersion(e, t) {
  try {
    const r = await async function r(e) {
      try {
        const e = await function t() {
          return new Promise(e => {
            fs.readFile(getLastCheckStoragePath(), "utf8", (t, r) => {
              if (!t && isString(r)) try {
                e(JSON.parse(r));
              } catch (e) {}
              e(null);
            });
          });
        }();
        if (null == e) return setLastCheck(), null;
        if (!function r(e, t, s) {
          return t + s < e;
        }(Date.now(), e, 6048e5)) return null;
        const t = setLastCheck(), r = await async function s(e) {
          const t = await Promise.resolve().then((function() {
            return function e(t) {
              if (t && t.__esModule) return t;
              var r = {};
              return t && Object.keys(t).forEach((function(e) {
                var s = Object.getOwnPropertyDescriptor(t, e);
                Object.defineProperty(r, e, s.get ? s : {
                  enumerable: !0,
                  get: function() {
                    return t[e];
                  }
                });
              })), r.default = t, r;
            }(require("https"));
          }));
          return new Promise((r, s) => {
            const n = t.request(e, t => {
              if (t.statusCode > 299) return void s(`url: ${e}, staus: ${t.statusCode}`);
              t.once("error", s);
              const n = [];
              t.once("end", () => {
                r(n.join(""));
              }), t.on("data", e => {
                n.push(e);
              });
            });
            n.once("error", s), n.end();
          });
        }("https://registry.npmjs.org/@stencil/core"), s = JSON.parse(r);
        return await t, s["dist-tags"].latest;
      } catch (t) {
        e.debug("getLatestCompilerVersion error: " + t);
      }
      return null;
    }(e);
    if (null != r) return () => {
      semiver(t, r) < 0 ? function s(e, t, r) {
        const s = [ `Update available: ${t} ${ARROW} ${r}`, "To get the latest, please run:", "npm install @stencil/core" ], n = s[0].length, o = [];
        let i = BOX_TOP_LEFT;
        for (;i.length <= n + 2 * PADDING; ) i += BOX_HORIZONTAL;
        i += BOX_TOP_RIGHT, o.push(i), s.forEach(e => {
          let t = BOX_VERTICAL;
          for (let e = 0; e < PADDING; e++) t += " ";
          for (t += e; t.length <= n + 2 * PADDING; ) t += " ";
          t += BOX_VERTICAL, o.push(t);
        });
        let a = BOX_BOTTOM_LEFT;
        for (;a.length <= n + 2 * PADDING; ) a += BOX_HORIZONTAL;
        a += BOX_BOTTOM_RIGHT, o.push(a);
        let l = `\n${INDENT}${o.join("\n" + INDENT)}\n`;
        l = l.replace(t, e.red(t)), l = l.replace(r, e.green(r)), l = l.replace("npm install @stencil/core", e.cyan("npm install @stencil/core")), 
        console.log(l);
      }(e, t, r) : console.debug(`${e.cyan("@stencil/core")} version ${e.green(t)} is the latest version`);
    };
  } catch (t) {
    e.debug("unable to load latest compiler version: " + t);
  }
  return noop;
}

function setLastCheck() {
  return new Promise(e => {
    const t = JSON.stringify(Date.now());
    fs.writeFile(getLastCheckStoragePath(), t, () => {
      e();
    });
  });
}

function getLastCheckStoragePath() {
  return path.join(os.tmpdir(), "stencil_last_version_node.json");
}

function getNextWorker(e) {
  const t = e.filter(e => !e.stopped);
  return 0 === t.length ? null : t.sort((e, t) => e.tasks.size < t.tasks.size ? -1 : e.tasks.size > t.tasks.size ? 1 : e.totalTasksAssigned < t.totalTasksAssigned ? -1 : e.totalTasksAssigned > t.totalTasksAssigned ? 1 : 0)[0];
}

async function startDevServerWorker(e, t) {
  let r = !1;
  try {
    const s = function s(e = {}) {
      const t = function r(e = {}) {
        const t = e.process || global.process, r = new Set, s = os.cpus(), n = s.length, o = os.platform(), i = {
          name: "node",
          version: t.versions.node,
          access: e => new Promise(t => {
            fs.access(e, e => {
              t(!e);
            });
          }),
          accessSync(e) {
            let t = !1;
            try {
              fs.accessSync(e), t = !0;
            } catch (e) {}
            return t;
          },
          addDestory(e) {
            r.add(e);
          },
          removeDestory(e) {
            r.delete(e);
          },
          checkVersion,
          copyFile: (e, t) => new Promise(r => {
            fs.copyFile(e, t, e => {
              r(!e);
            });
          }),
          createWorkerController(e) {
            const t = path.join(__dirname, "worker.js");
            return new NodeWorkerController(t, e);
          },
          async destroy() {
            const e = [];
            r.forEach(t => {
              try {
                const r = t();
                r && r.then && e.push(r);
              } catch (e) {
                console.error("node sys destroy: " + e);
              }
            }), e.length > 0 && await Promise.all(e), r.clear();
          },
          dynamicImport: e => Promise.resolve((e => ("function" == typeof __webpack_require__ ? __non_webpack_require__ : require)(e))(e)),
          encodeToBase64: e => Buffer.from(e).toString("base64"),
          async ensureDependencies() {
            const e = [];
            let t = null;
            try {
              t = require.resolve("typescript");
            } catch (t) {
              const r = buildError(e);
              r.header = "Unable to find TypeScript", r.messageText = 'Please ensure you install the dependencies first, for example: "npm install"';
            }
            return {
              stencilPath: i.getCompilerExecutingPath(),
              typescriptPath: t,
              diagnostics: e
            };
          },
          async ensureResources() {},
          exit: exit$1,
          getCurrentDirectory: () => normalizePath(t.cwd()),
          getCompilerExecutingPath: () => path.join(__dirname, "..", "..", "compiler", "stencil.js"),
          getDevServerExecutingPath: () => path.join(__dirname, "..", "..", "dev-server", "index.js"),
          getEnvironmentVar: e => process.env[e],
          getLocalModulePath: () => null,
          getRemoteModuleUrl: () => null,
          glob: asyncGlob,
          hardwareConcurrency: n,
          isSymbolicLink: e => new Promise(t => {
            try {
              fs.lstat(e, (e, r) => {
                t(!e && r.isSymbolicLink());
              });
            } catch (e) {
              t(!1);
            }
          }),
          mkdir: (e, t) => new Promise(r => {
            t ? fs.mkdir(e, t, t => {
              r({
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                newDirs: [],
                error: t
              });
            }) : fs.mkdir(e, t => {
              r({
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                newDirs: [],
                error: t
              });
            });
          }),
          mkdirSync(e, t) {
            const r = {
              basename: path.basename(e),
              dirname: path.dirname(e),
              path: e,
              newDirs: [],
              error: null
            };
            try {
              fs.mkdirSync(e, t);
            } catch (e) {
              r.error = e;
            }
            return r;
          },
          nextTick: t.nextTick,
          normalizePath,
          onProcessInterrupt(e) {},
          platformPath: path,
          readdir: e => new Promise(t => {
            fs.readdir(e, (r, s) => {
              t(r ? [] : s.map(t => normalizePath(path.join(e, t))));
            });
          }),
          readdirSync(e) {
            try {
              return fs.readdirSync(e).map(t => normalizePath(path.join(e, t)));
            } catch (e) {}
            return [];
          },
          readFile: e => new Promise(t => {
            fs.readFile(e, "utf8", (e, r) => {
              t(r);
            });
          }),
          readFileSync(e) {
            try {
              return fs.readFileSync(e, "utf8");
            } catch (e) {}
          },
          realpath: e => new Promise(t => {
            fs.realpath(e, "utf8", (e, r) => {
              t({
                path: r,
                error: e
              });
            });
          }),
          realpathSync(e) {
            const t = {
              path: void 0,
              error: null
            };
            try {
              t.path = fs.realpathSync(e, "utf8");
            } catch (e) {
              t.error = e;
            }
            return t;
          },
          rename: (e, t) => new Promise(r => {
            fs.rename(e, t, s => {
              r({
                oldPath: e,
                newPath: t,
                error: s,
                oldDirs: [],
                oldFiles: [],
                newDirs: [],
                newFiles: [],
                renamed: [],
                isFile: !1,
                isDirectory: !1
              });
            });
          }),
          resolvePath: e => normalizePath(e),
          rmdir: (e, t) => new Promise(r => {
            t && t.recursive ? fs.rmdir(e, {
              recursive: !0
            }, t => {
              r({
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                removedDirs: [],
                removedFiles: [],
                error: t
              });
            }) : fs.rmdir(e, t => {
              r({
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                removedDirs: [],
                removedFiles: [],
                error: t
              });
            });
          }),
          rmdirSync(e, t) {
            try {
              return t && t.recursive ? fs.rmdirSync(e, {
                recursive: !0
              }) : fs.rmdirSync(e), {
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                removedDirs: [],
                removedFiles: [],
                error: null
              };
            } catch (t) {
              return {
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                removedDirs: [],
                removedFiles: [],
                error: t
              };
            }
          },
          stat: e => new Promise(t => {
            fs.stat(e, (e, r) => {
              t(e ? void 0 : r);
            });
          }),
          statSync(e) {
            try {
              return fs.statSync(e);
            } catch (e) {}
          },
          tmpdir: () => os.tmpdir(),
          unlink: e => new Promise(t => {
            fs.unlink(e, r => {
              t({
                basename: path.basename(e),
                dirname: path.dirname(e),
                path: e,
                error: r
              });
            });
          }),
          unlinkSync(e) {
            const t = {
              basename: path.basename(e),
              dirname: path.dirname(e),
              path: e,
              error: null
            };
            try {
              fs.unlinkSync(e);
            } catch (e) {
              t.error = e;
            }
            return t;
          },
          writeFile: (e, t) => new Promise(r => {
            fs.writeFile(e, t, t => {
              r({
                path: e,
                error: t
              });
            });
          }),
          writeFileSync(e, t) {
            const r = {
              path: e,
              error: null
            };
            try {
              fs.writeFileSync(e, t);
            } catch (e) {
              r.error = e;
            }
            return r;
          },
          generateContentHash(e, t) {
            let r = crypto.createHash("sha1").update(e).digest("hex").toLowerCase();
            return "number" == typeof t && (r = r.substr(0, t)), Promise.resolve(r);
          },
          copy: nodeCopyTasks,
          details: {
            cpuModel: (Array.isArray(s) && s.length > 0 ? s[0] && s[0].model : "") || "",
            freemem: () => os.freemem(),
            platform: "darwin" === o || "linux" === o ? o : "win32" === o ? "windows" : "",
            release: os.release(),
            totalmem: os.totalmem()
          }
        }, a = new NodeResolveModule;
        return i.lazyRequire = new NodeLazyRequire(a, {
          "@types/jest": [ "24.9.1", "25.2.3" ],
          "@types/puppeteer": [ "1.19.0", "2.0.1" ],
          jest: [ "24.9.0", "26.0.1" ],
          "jest-cli": [ "24.9.0", "26.0.1" ],
          pixelmatch: [ "4.0.2", "4.0.2" ],
          puppeteer: [ "1.19.0", "2.1.1" ],
          "puppeteer-core": [ "1.19.0", "2.1.1" ],
          "workbox-build": [ "4.3.1", "4.3.1" ]
        }), i;
      }(e), s = require("typescript"), n = s.sys.watchFile, o = s.sys.watchDirectory;
      return t.watchTimeout = 80, t.events = (() => {
        const e = [], t = t => {
          const r = e.findIndex(e => e.callback === t);
          return r > -1 && (e.splice(r, 1), !0);
        };
        return {
          emit: (t, r) => {
            const s = t.toLowerCase().trim(), n = e.slice();
            for (const e of n) if (null == e.eventName) try {
              e.callback(t, r);
            } catch (e) {
              console.error(e);
            } else if (e.eventName === s) try {
              e.callback(r);
            } catch (e) {
              console.error(e);
            }
          },
          on: (r, s) => {
            if ("function" == typeof r) {
              const s = null, n = r;
              return e.push({
                eventName: s,
                callback: n
              }), () => t(n);
            }
            if ("string" == typeof r && "function" == typeof s) {
              const n = r.toLowerCase().trim(), o = s;
              return e.push({
                eventName: n,
                callback: o
              }), () => t(o);
            }
            return () => !1;
          },
          unsubscribeAll: () => {
            e.length = 0;
          }
        };
      })(), t.watchDirectory = (e, r, s) => {
        const n = o(e, e => {
          e = normalizePath(e), r(e, null);
        }, s), i = () => {
          n.close();
        };
        return t.addDestory(i), {
          close() {
            t.removeDestory(i), n.close();
          }
        };
      }, t.watchFile = (e, r) => {
        const o = n(e, (e, n) => {
          e = normalizePath(e), n === s.FileWatcherEventKind.Created ? (r(e, "fileAdd"), t.events.emit("fileAdd", e)) : n === s.FileWatcherEventKind.Changed ? (r(e, "fileUpdate"), 
          t.events.emit("fileUpdate", e)) : n === s.FileWatcherEventKind.Deleted && (r(e, "fileDelete"), 
          t.events.emit("fileDelete", e));
        }), i = () => {
          o.close();
        };
        return t.addDestory(i), {
          close() {
            t.removeDestory(i), o.close();
          }
        };
      }, t;
    }({
      process: e
    }), n = [];
    t.editors = await async function n() {
      const e = [];
      try {
        await Promise.all(Object.keys(openInEditorApi.editors).map(async t => {
          const r = await async function s(e) {
            let t = !1;
            try {
              await openInEditorApi.editors[e].detect(), t = !0;
            } catch (e) {}
            return t;
          }(t);
          e.push({
            id: t,
            priority: EDITOR_PRIORITY[t],
            supported: r
          });
        }));
      } catch (e) {}
      return e.filter(e => e.supported).sort((e, t) => e.priority < t.priority ? -1 : e.priority > t.priority ? 1 : 0).map(e => ({
        id: e.id,
        name: EDITORS[e.id]
      }));
    }();
    let o = await async function o(e, t, r) {
      e.port = await async function s(e, t) {
        return async function t(r) {
          return await function s(e, t) {
            return new Promise((r, s) => {
              const n = net.createServer().once("error", () => {
                r(!0);
              }).once("listening", () => {
                n.once("close", () => {
                  r(!1);
                }).close();
              }).on("error", e => {
                s(e);
              }).listen(t, e);
            });
          }(e, r) ? t(r + 1) : r;
        }(t);
      }(e.address, e.port);
      const n = createRequestHandler(e, t), o = e.https;
      let i = o ? https.createServer(o, n) : http.createServer(n);
      return r.push(() => {
        i.close(), i = null;
      }), i;
    }(t, s, n);
    t.websocket && function i(e, t, r) {
      function s() {
        this.isAlive = !0;
      }
      const n = {
        server: t
      }, o = new ws.Server(n);
      o.on("connection", t => {
        t.on("message", t => {
          e.send(JSON.parse(t.toString()));
        }), t.isAlive = !0, t.on("pong", s);
      });
      const i = setInterval(() => {
        o.clients.forEach(e => {
          if (!e.isAlive) return e.close(1e3);
          e.isAlive = !1, e.ping(noop);
        });
      }, 1e4);
      e.addListener("message", (function a(e) {
        if (e) {
          const t = JSON.stringify(e);
          o.clients.forEach(e => {
            e.readyState === e.OPEN && e.send(t);
          });
        }
      })), r.push(() => {
        clearInterval(i), o.clients.forEach(e => {
          e.close(1e3);
        });
      });
    }(e, o, n), o.listen(t.port, t.address), sendMsg(e, {
      serverStarted: {
        address: t.address,
        basePath: t.basePath,
        browserUrl: getBrowserUrl(t.protocol, t.address, t.port, t.basePath, "/"),
        port: t.port,
        protocol: t.protocol,
        root: t.root,
        initialLoadUrl: getBrowserUrl(t.protocol, t.address, t.port, t.basePath, t.initialLoadUrl || DEV_SERVER_INIT_URL),
        error: null
      }
    }), r = !0;
    const i = () => {
      n.forEach(e => {
        e();
      }), n.length = 0, o = null, setTimeout(() => {
        exit$1(0);
      }, 5e3).unref(), e.removeAllListeners("message");
    };
    e.once("SIGINT", i);
  } catch (t) {
    r ? sendError(e, t) : sendMsg(e, {
      serverStarted: {
        address: null,
        basePath: null,
        browserUrl: null,
        initialLoadUrl: null,
        port: null,
        protocol: null,
        root: null,
        error: String(t)
      }
    });
  }
}

var fn, exit$1;

const util = require("util"), util__default = _interopDefault(util), fs = _interopDefault(require("../sys/node/graceful-fs.js")), path = _interopDefault(require("path")), querystring = require("querystring"), Url = require("url"), zlib = require("zlib"), buffer = require("buffer"), openInEditorApi = _interopDefault(require("./open-in-editor-api.js")), net = require("net"), http = require("http"), https = require("https"), glob = _interopDefault(require("../sys/node/glob.js")), os = require("os"), crypto = require("crypto"), cp = require("child_process"), events = require("events"), ws = require("./ws.js"), DEV_SERVER_INIT_URL = "/~dev-server-init", OPEN_IN_EDITOR_URL = "/~dev-server-open-in-editor", msgResolves = new Map;

let resolveIds = 1;

const DEFAULT_HEADERS = {
  "cache-control": "no-cache, no-store, must-revalidate, max-age=0",
  expires: "0",
  server: "Stencil Dev Server 1.16.4",
  date: "Wed, 1 Jan 2000 00:00:00 GMT",
  "access-control-allow-origin": "*",
  "access-control-expose-headers": "*"
}, TXT_EXT = [ "css", "html", "htm", "js", "json", "svg", "xml" ], noop = () => {}, isString = e => "string" == typeof e, IS_DENO_ENV = "undefined" != typeof Deno, IS_NODE_ENV = !(IS_DENO_ENV || "undefined" == typeof global || "function" != typeof require || !global.process || "string" != typeof __filename || global.origin && "string" == typeof global.origin), buildError = (IS_DENO_ENV && Deno.build.os, 
IS_NODE_ENV && global.process.platform, IS_NODE_ENV ? process.cwd : IS_DENO_ENV && Deno.cwd, 
IS_NODE_ENV ? process.exit : IS_DENO_ENV && Deno.exit, e => {
  const t = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    relFilePath: null,
    absFilePath: null,
    lines: []
  };
  return e && e.push(t), t;
}), catchError = (e, t, r) => {
  const s = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    relFilePath: null,
    absFilePath: null,
    lines: []
  };
  return isString(r) ? s.messageText = r : null != t && (null != t.stack ? s.messageText = t.stack.toString() : null != t.message ? s.messageText = t.message.toString() : s.messageText = t.toString()), 
  null == e || shouldIgnoreError(s.messageText) || e.push(s), s;
}, shouldIgnoreError = e => e === TASK_CANCELED_MSG, TASK_CANCELED_MSG = "task canceled", normalizePath = e => {
  if ("string" != typeof e) throw new Error("invalid path to normalize");
  e = normalizeSlashes(e.trim());
  const t = pathComponents(e, getRootLength(e)), r = reducePathComponents(t), s = r[0], n = r[1], o = s + r.slice(1).join("/");
  return "" === o ? "." : "" === s && n && e.includes("/") && !n.startsWith(".") && !n.startsWith("@") ? "./" + o : o;
}, normalizeSlashes = e => e.replace(backslashRegExp, "/"), backslashRegExp = /\\/g, reducePathComponents = e => {
  if (!Array.isArray(e) || 0 === e.length) return [];
  const t = [ e[0] ];
  for (let r = 1; r < e.length; r++) {
    const s = e[r];
    if (s && "." !== s) {
      if (".." === s) if (t.length > 1) {
        if (".." !== t[t.length - 1]) {
          t.pop();
          continue;
        }
      } else if (t[0]) continue;
      t.push(s);
    }
  }
  return t;
}, getRootLength = e => {
  const t = getEncodedRootLength(e);
  return t < 0 ? ~t : t;
}, getEncodedRootLength = e => {
  if (!e) return 0;
  const t = e.charCodeAt(0);
  if (47 === t || 92 === t) {
    if (e.charCodeAt(1) !== t) return 1;
    const r = e.indexOf(47 === t ? "/" : "\\", 2);
    return r < 0 ? e.length : r + 1;
  }
  if (isVolumeCharacter(t) && 58 === e.charCodeAt(1)) {
    const t = e.charCodeAt(2);
    if (47 === t || 92 === t) return 3;
    if (2 === e.length) return 2;
  }
  const r = e.indexOf("://");
  if (-1 !== r) {
    const t = r + "://".length, s = e.indexOf("/", t);
    if (-1 !== s) {
      const n = e.slice(0, r), o = e.slice(t, s);
      if ("file" === n && ("" === o || "localhost" === o) && isVolumeCharacter(e.charCodeAt(s + 1))) {
        const t = getFileUrlVolumeSeparatorEnd(e, s + 2);
        if (-1 !== t) {
          if (47 === e.charCodeAt(t)) return ~(t + 1);
          if (t === e.length) return ~t;
        }
      }
      return ~(s + 1);
    }
    return ~e.length;
  }
  return 0;
}, isVolumeCharacter = e => e >= 97 && e <= 122 || e >= 65 && e <= 90, getFileUrlVolumeSeparatorEnd = (e, t) => {
  const r = e.charCodeAt(t);
  if (58 === r) return t + 1;
  if (37 === r && 51 === e.charCodeAt(t + 1)) {
    const r = e.charCodeAt(t + 2);
    if (97 === r || 65 === r) return t + 3;
  }
  return -1;
}, pathComponents = (e, t) => {
  const r = e.substring(0, t), s = e.substring(t).split("/"), n = s.length;
  return n > 0 && !s[n - 1] && s.pop(), [ r, ...s ];
}, urlVersionIds = new Map, EDITORS = {
  atom: "Atom",
  code: "Code",
  emacs: "Emacs",
  idea14ce: "IDEA 14 Community Edition",
  phpstorm: "PhpStorm",
  sublime: "Sublime",
  webstorm: "WebStorm",
  vim: "Vim",
  visualstudio: "Visual Studio"
}, EDITOR_PRIORITY = {
  code: 1,
  atom: 2,
  sublime: 3,
  visualstudio: 4,
  idea14ce: 5,
  webstorm: 6,
  phpstorm: 7,
  vim: 8,
  emacs: 9
};

let dirTemplate = null;

const copyFile = util.promisify(fs.copyFile), mkdir = util.promisify(fs.mkdir), readdir = util.promisify(fs.readdir), readFile = util.promisify(fs.readFile), stat = util.promisify(fs.stat), ROOT_DIR = normalizePath(path.resolve("/")), IGNORE = [ ".ds_store", ".gitignore", "desktop.ini", "thumbs.db" ];

fn = new Intl.Collator(0, {
  numeric: 1
}).compare;

const ARROW = "→", BOX_TOP_LEFT = "╭", BOX_TOP_RIGHT = "╮", BOX_BOTTOM_LEFT = "╰", BOX_BOTTOM_RIGHT = "╯", BOX_VERTICAL = "│", BOX_HORIZONTAL = "─", PADDING = 2, INDENT = "           ";

exit$1 = function e(t, r) {
  function s() {
    n === r.length && process.exit(t);
  }
  r || (r = [ process.stdout, process.stderr ]);
  var n = 0;
  r.forEach((function(e) {
    0 === e.bufferSize ? n++ : e.write("", "utf-8", (function() {
      n++, s();
    })), e.write = function() {};
  })), s(), process.on("exit", (function() {
    process.exit(t);
  }));
};

class NodeLazyRequire {
  constructor(e, t) {
    this.nodeResolveModule = e, this.lazyDependencies = t, this.moduleData = new Map;
  }
  async ensure(e, t, r) {
    const s = [];
    let n = !1;
    const o = r.map(async e => {
      const r = this.moduleData.get(e);
      if (r && r.fromDir && r.modulePath) return;
      const [o, i] = this.lazyDependencies[e];
      try {
        const r = this.nodeResolveModule.resolveModule(t, e), s = await async function a(e) {
          const t = await readFile(e, "utf8");
          return JSON.parse(t);
        }(r);
        if (n = !0, semiver(s.version, o) >= 0) return void this.moduleData.set(e, {
          fromDir: t,
          modulePath: path.dirname(r)
        });
      } catch (e) {}
      s.push({
        moduleId: e,
        requiredVersionRange: i
      });
    });
    if (await Promise.all(o), 0 === s.length) return Promise.resolve();
    const i = `Please wait while required dependencies are ${n ? "updated" : "installed"}. This may take a few moments and will only be required for the initial run.`;
    e.info(e.magenta(i));
    const a = s.map(e => e.moduleId), l = e.createTimeSpan(`installing dependenc${a.length > 1 ? "ies" : "y"}: ${a.join(", ")}`);
    try {
      const r = s.map(e => {
        let t = e.moduleId;
        return e.requiredVersionRange && (t += "@" + e.requiredVersionRange), t;
      });
      await function c(e, t, r) {
        return new Promise((s, n) => {
          const o = [ "install", ...r, "--no-audit", "--save-exact", "--save-dev" ], i = {
            shell: !0,
            cwd: t,
            env: Object.assign({}, process.env)
          };
          i.env.NODE_ENV = "development", "debug" === e.getLevel() && o.push("--verbose"), 
          e.debug("npm " + o.join(" ")), e.debug("npm, cwd: " + t);
          const a = cp.spawn("npm", o, i);
          let l = "";
          a.stdout && (a.stdout.setEncoding("utf8"), a.stdout.on("data", e => {
            l += e;
          })), a.stderr && (a.stderr.setEncoding("utf8"), a.stderr.on("data", e => {
            l += e;
          })), a.once("exit", t => {
            "debug" === e.getLevel() && e.debug("npm, exit " + t), 0 === t ? s() : n(`failed to install: ${r.join(", ")}${l ? ", " + l : ""}`);
          });
        });
      }(e, t, r), s.forEach(e => {
        this.moduleData.set(e.moduleId, {
          fromDir: t,
          modulePath: null
        });
      }), l.finish("installing dependencies finished");
    } catch (t) {
      e.error("lazy require failed: " + t);
    }
  }
  require(e) {
    const t = this.moduleData.get(e);
    if (!t) throw new Error("lazy required module has not been ensured: " + e);
    if (!t.modulePath) {
      const r = this.nodeResolveModule.resolveModule(t.fromDir, e);
      t.modulePath = path.dirname(r), this.moduleData.set(e, t);
    }
    return require(t.modulePath);
  }
  getModulePath(e) {
    const t = this.moduleData.get(e);
    if (!t) throw new Error("lazy required module has not been ensured: " + e);
    if (!t.modulePath) {
      const r = this.nodeResolveModule.resolveModule(t.fromDir, e);
      t.modulePath = path.dirname(r), this.moduleData.set(e, t);
    }
    return t.modulePath;
  }
}

class NodeResolveModule {
  constructor() {
    this.resolveModuleCache = new Map;
  }
  resolveModule(e, t, r) {
    const s = `${e}:${t}`, n = this.resolveModuleCache.get(s);
    if (n) return n;
    if (r && r.manuallyResolve) return this.resolveModuleManually(e, t, s);
    if (t.startsWith("@types/")) return this.resolveTypesModule(e, t, s);
    const o = require("module");
    e = path.resolve(e);
    const i = path.join(e, "noop.js");
    let a = normalizePath(o._resolveFilename(t, {
      id: i,
      filename: i,
      paths: o._nodeModulePaths(e)
    }));
    const l = normalizePath(path.parse(e).root);
    let c;
    for (;a !== l; ) if (a = normalizePath(path.dirname(a)), c = path.join(a, "package.json"), 
    fs.existsSync(c)) return this.resolveModuleCache.set(s, c), c;
    throw new Error(`error loading "${t}" from "${e}"`);
  }
  resolveTypesModule(e, t, r) {
    const s = t.split("/"), n = normalizePath(path.parse(e).root);
    let o, i = normalizePath(path.join(e, "noop.js"));
    for (;i !== n; ) if (i = normalizePath(path.dirname(i)), o = path.join(i, "node_modules", s[0], s[1], "package.json"), 
    fs.existsSync(o)) return this.resolveModuleCache.set(r, o), o;
    throw new Error(`error loading "${t}" from "${e}"`);
  }
  resolveModuleManually(e, t, r) {
    const s = normalizePath(path.parse(e).root);
    let n, o = normalizePath(path.join(e, "noop.js"));
    for (;o !== s; ) if (o = normalizePath(path.dirname(o)), n = path.join(o, "node_modules", t, "package.json"), 
    fs.existsSync(n)) return this.resolveModuleCache.set(r, n), n;
    throw new Error(`error loading "${t}" from "${e}"`);
  }
}

class NodeWorkerMain extends events.EventEmitter {
  constructor(e, t) {
    super(), this.id = e, this.tasks = new Map, this.exitCode = null, this.processQueue = !0, 
    this.sendQueue = [], this.stopped = !1, this.successfulMessage = !1, this.totalTasksAssigned = 0, 
    this.fork(t);
  }
  fork(e) {
    const t = {
      execArgv: process.execArgv.filter(e => !/^--(debug|inspect)/.test(e)),
      env: process.env,
      cwd: process.cwd(),
      silent: !0
    };
    this.childProcess = cp.fork(e, [], t), this.childProcess.stdout.setEncoding("utf8"), 
    this.childProcess.stdout.on("data", e => {
      console.log(e);
    }), this.childProcess.stderr.setEncoding("utf8"), this.childProcess.stderr.on("data", e => {
      console.log(e);
    }), this.childProcess.on("message", this.receiveFromWorker.bind(this)), this.childProcess.on("error", e => {
      this.emit("error", e);
    }), this.childProcess.once("exit", e => {
      this.exitCode = e, this.emit("exit", e);
    });
  }
  run(e) {
    this.totalTasksAssigned++, this.tasks.set(e.stencilId, e), this.sendToWorker({
      stencilId: e.stencilId,
      args: e.inputArgs
    });
  }
  sendToWorker(e) {
    this.processQueue ? this.childProcess.send(e, e => {
      if (!(e && e instanceof Error) && (this.processQueue = !0, this.sendQueue.length > 0)) {
        const e = this.sendQueue.slice();
        this.sendQueue = [], e.forEach(e => this.sendToWorker(e));
      }
    }) && !/^win/.test(process.platform) || (this.processQueue = !1) : this.sendQueue.push(e);
  }
  receiveFromWorker(e) {
    if (this.successfulMessage = !0, this.stopped) return;
    const t = this.tasks.get(e.stencilId);
    t ? (null != e.stencilRtnError ? t.reject(e.stencilRtnError) : t.resolve(e.stencilRtnValue), 
    this.tasks.delete(e.stencilId), this.emit("response", e)) : null != e.stencilRtnError && this.emit("error", e.stencilRtnError);
  }
  stop() {
    this.stopped = !0, this.tasks.forEach(e => e.reject(TASK_CANCELED_MSG)), this.tasks.clear(), 
    this.successfulMessage ? (this.childProcess.send({
      exit: !0
    }), setTimeout(() => {
      null === this.exitCode && this.childProcess.kill("SIGKILL");
    }, 100)) : this.childProcess.kill("SIGKILL");
  }
}

class NodeWorkerController extends events.EventEmitter {
  constructor(e, t) {
    super(), this.forkModulePath = e, this.workerIds = 0, this.stencilId = 0, this.isEnding = !1, 
    this.taskQueue = [], this.workers = [];
    const r = os.cpus().length;
    this.useForkedWorkers = t > 0, this.maxWorkers = Math.max(Math.min(t, r), 2) - 1, 
    this.useForkedWorkers ? this.startWorkers() : this.mainThreadRunner = require(e);
  }
  onError(e, t) {
    if ("ERR_IPC_CHANNEL_CLOSED" === e.code) return this.stopWorker(t);
    "EPIPE" !== e.code && console.error(e);
  }
  onExit(e) {
    setTimeout(() => {
      let t = !1;
      const r = this.workers.find(t => t.id === e);
      r && (r.tasks.forEach(e => {
        e.retries++, this.taskQueue.unshift(e), t = !0;
      }), r.tasks.clear()), this.stopWorker(e), t && this.processTaskQueue();
    }, 10);
  }
  startWorkers() {
    for (;this.workers.length < this.maxWorkers; ) this.startWorker();
  }
  startWorker() {
    const e = this.workerIds++, t = new NodeWorkerMain(e, this.forkModulePath);
    t.on("response", this.processTaskQueue.bind(this)), t.once("exit", () => {
      this.onExit(e);
    }), t.on("error", t => {
      this.onError(t, e);
    }), this.workers.push(t);
  }
  stopWorker(e) {
    const t = this.workers.find(t => t.id === e);
    if (t) {
      t.stop();
      const e = this.workers.indexOf(t);
      e > -1 && this.workers.splice(e, 1);
    }
  }
  processTaskQueue() {
    if (!this.isEnding) for (this.useForkedWorkers && this.startWorkers(); this.taskQueue.length > 0; ) {
      const e = getNextWorker(this.workers);
      if (!e) break;
      e.run(this.taskQueue.shift());
    }
  }
  send(...e) {
    return this.isEnding ? Promise.reject(TASK_CANCELED_MSG) : this.useForkedWorkers ? new Promise((t, r) => {
      const s = {
        stencilId: this.stencilId++,
        inputArgs: e,
        retries: 0,
        resolve: t,
        reject: r
      };
      this.taskQueue.push(s), this.processTaskQueue();
    }) : this.mainThreadRunner[e[0]].apply(null, e.slice(1));
  }
  handler(e) {
    return (...t) => this.send(e, ...t);
  }
  cancelTasks() {
    for (const e of this.workers) e.tasks.forEach(e => e.reject(TASK_CANCELED_MSG)), 
    e.tasks.clear();
    this.taskQueue.length = 0;
  }
  destroy() {
    if (!this.isEnding) {
      this.isEnding = !0;
      for (const e of this.taskQueue) e.reject(TASK_CANCELED_MSG);
      this.taskQueue.length = 0;
      const e = this.workers.map(e => e.id);
      for (const t of e) this.stopWorker(t);
    }
  }
}

!function createMessageReceiver(e, t) {
  e.on("message", e => {
    if ("number" == typeof e.resolveId) {
      const t = msgResolves.get(e.resolveId);
      t && (msgResolves.delete(e.resolveId), t(e));
    }
    t(e);
  });
}(process, e => {
  e.startServer && async function t(e) {
    try {
      e.contentTypes = await async function t(e) {
        const t = path.join(e.devServerDir, "content-type-db.json"), r = util__default.promisify(fs.readFile), s = await r(t, "utf8");
        return JSON.parse(s);
      }(e), startDevServerWorker(process, e);
    } catch (e) {
      sendMsg(process, {
        serverStarted: {
          address: null,
          basePath: null,
          browserUrl: null,
          initialLoadUrl: null,
          port: null,
          protocol: null,
          root: null,
          error: String(e)
        }
      });
    }
  }(e.startServer);
}), process.on("unhandledRejection", e => {
  console.log("server worker error", e);
});