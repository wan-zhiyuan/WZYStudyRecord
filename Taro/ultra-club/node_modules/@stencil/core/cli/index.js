const dashToPascalCase = e => (e => e.toLowerCase())(e).split("-").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(""), isFunction = e => "function" == typeof e, isString = e => "string" == typeof e, IS_NODE_ENV = !("undefined" != typeof Deno || "undefined" == typeof global || "function" != typeof require || !global.process || "string" != typeof __filename || global.origin && "string" == typeof global.origin), hasError = e => null != e && 0 !== e.length && e.some(e => "error" === e.level && "runtime" !== e.type), shouldIgnoreError = e => e === TASK_CANCELED_MSG, TASK_CANCELED_MSG = "task canceled", normalizePath = e => {
  if ("string" != typeof e) throw new Error("invalid path to normalize");
  e = normalizeSlashes(e.trim());
  const t = pathComponents(e, getRootLength(e)), s = reducePathComponents(t), n = s[0], r = s[1], o = n + s.slice(1).join("/");
  return "" === o ? "." : "" === n && r && e.includes("/") && !r.startsWith(".") && !r.startsWith("@") ? "./" + o : o;
}, normalizeSlashes = e => e.replace(backslashRegExp, "/"), backslashRegExp = /\\/g, reducePathComponents = e => {
  if (!Array.isArray(e) || 0 === e.length) return [];
  const t = [ e[0] ];
  for (let s = 1; s < e.length; s++) {
    const n = e[s];
    if (n && "." !== n) {
      if (".." === n) if (t.length > 1) {
        if (".." !== t[t.length - 1]) {
          t.pop();
          continue;
        }
      } else if (t[0]) continue;
      t.push(n);
    }
  }
  return t;
}, getRootLength = e => {
  const t = getEncodedRootLength(e);
  return t < 0 ? ~t : t;
}, getEncodedRootLength = e => {
  if (!e) return 0;
  const t = e.charCodeAt(0);
  if (47 === t || 92 === t) {
    if (e.charCodeAt(1) !== t) return 1;
    const s = e.indexOf(47 === t ? "/" : "\\", 2);
    return s < 0 ? e.length : s + 1;
  }
  if (isVolumeCharacter(t) && 58 === e.charCodeAt(1)) {
    const t = e.charCodeAt(2);
    if (47 === t || 92 === t) return 3;
    if (2 === e.length) return 2;
  }
  const s = e.indexOf("://");
  if (-1 !== s) {
    const t = s + "://".length, n = e.indexOf("/", t);
    if (-1 !== n) {
      const r = e.slice(0, s), o = e.slice(t, n);
      if ("file" === r && ("" === o || "localhost" === o) && isVolumeCharacter(e.charCodeAt(n + 1))) {
        const t = getFileUrlVolumeSeparatorEnd(e, n + 2);
        if (-1 !== t) {
          if (47 === e.charCodeAt(t)) return ~(t + 1);
          if (t === e.length) return ~t;
        }
      }
      return ~(n + 1);
    }
    return ~e.length;
  }
  return 0;
}, isVolumeCharacter = e => e >= 97 && e <= 122 || e >= 65 && e <= 90, getFileUrlVolumeSeparatorEnd = (e, t) => {
  const s = e.charCodeAt(t);
  if (58 === s) return t + 1;
  if (37 === s && 51 === e.charCodeAt(t + 1)) {
    const s = e.charCodeAt(t + 2);
    if (97 === s || 65 === s) return t + 3;
  }
  return -1;
}, pathComponents = (e, t) => {
  const s = e.substring(0, t), n = e.substring(t).split("/"), r = n.length;
  return r > 0 && !n[r - 1] && n.pop(), [ s, ...n ];
}, parseFlags = (e, t) => {
  const s = {
    task: null,
    args: [],
    knownArgs: [],
    unknownArgs: null
  };
  if (s.args = e.slice(), s.args.length > 0 && s.args[0] && !s.args[0].startsWith("-") && (s.task = s.args[0]), 
  parseArgs(s, s.args, s.knownArgs), t && "node" === t.name) {
    const e = getNpmConfigEnvArgs(t);
    parseArgs(s, e, s.knownArgs), e.forEach(e => {
      s.args.includes(e) || s.args.push(e);
    });
  }
  if (null != s.task) {
    const e = s.args.indexOf(s.task);
    e > -1 && s.args.splice(e, 1);
  }
  return s.unknownArgs = s.args.filter(e => !s.knownArgs.includes(e)), s;
}, parseArgs = (e, t, s) => {
  ARG_OPTS.boolean.forEach(n => {
    const r = ARG_OPTS.alias[n], o = configCase(n);
    "boolean" != typeof e[o] && (e[o] = null), t.forEach(t => {
      t === "--" + n || t === "--" + o ? (e[o] = !0, s.push(t)) : t === "--no-" + n || t === "--no" + dashToPascalCase(n) ? (e[o] = !1, 
      s.push(t)) : r && t === "-" + r && (e[o] = !0, s.push(t));
    });
  }), ARG_OPTS.string.forEach(n => {
    const r = ARG_OPTS.alias[n], o = configCase(n);
    "string" != typeof e[o] && (e[o] = null);
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (a.startsWith(`--${n}=`)) {
        const t = a.split("=");
        t.shift(), e[o] = t.join("="), s.push(a);
      } else if (a === "--" + n) e[o] = t[i + 1], s.push(a), s.push(t[i + 1]); else if (a === "--" + o) e[o] = t[i + 1], 
      s.push(a), s.push(t[i + 1]); else if (a.startsWith(`--${o}=`)) {
        const t = a.split("=");
        t.shift(), e[o] = t.join("="), s.push(a);
      } else if (r) if (a.startsWith(`-${r}=`)) {
        const t = a.split("=");
        t.shift(), e[o] = t.join("="), s.push(a);
      } else a === "-" + r && (e[o] = t[i + 1], s.push(t[i + 1]));
    }
  }), ARG_OPTS.number.forEach(n => {
    const r = ARG_OPTS.alias[n], o = configCase(n);
    "number" != typeof e[o] && (e[o] = null);
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (a.startsWith(`--${n}=`)) {
        const t = a.split("=");
        t.shift(), e[o] = parseInt(t.join(""), 10), s.push(a);
      } else if (a === "--" + n) e[o] = parseInt(t[i + 1], 10), s.push(t[i + 1]); else if (a.startsWith(`--${o}=`)) {
        const t = a.split("=");
        t.shift(), e[o] = parseInt(t.join(""), 10), s.push(a);
      } else if (a === "--" + o) e[o] = parseInt(t[i + 1], 10), s.push(t[i + 1]); else if (r) if (a.startsWith(`-${r}=`)) {
        const t = a.split("=");
        t.shift(), e[o] = parseInt(t.join(""), 10), s.push(a);
      } else a === "-" + r && (e[o] = parseInt(t[i + 1], 10), s.push(t[i + 1]));
    }
  });
}, configCase = e => (e = dashToPascalCase(e)).charAt(0).toLowerCase() + e.substr(1), ARG_OPTS = {
  boolean: [ "build", "cache", "check-version", "ci", "compare", "debug", "dev", "devtools", "docs", "e2e", "es5", "esm", "headless", "help", "log", "open", "prerender", "prerender-external", "prod", "profile", "service-worker", "screenshot", "serve", "skip-node-check", "spec", "stats", "update-screenshot", "verbose", "version", "watch" ],
  number: [ "max-workers", "port" ],
  string: [ "address", "config", "docs-json", "emulate", "log-level", "root", "screenshot-connector" ],
  alias: {
    config: "c",
    help: "h",
    port: "p",
    version: "v"
  }
}, getNpmConfigEnvArgs = e => {
  let t = [];
  try {
    const s = e.getEnvironmentVar("npm_config_argv");
    s && (t = JSON.parse(s).original, "run" === t[0] && (t = t.slice(2)));
  } catch (e) {}
  return t;
}, dependencies = [ {
  name: "@stencil/core",
  version: "1.16.4",
  main: "compiler/stencil.min.js",
  resources: [ "internal/index.d.ts", "internal/package.json", "internal/stencil-core.js", "internal/stencil-core.d.ts", "internal/stencil-ext-modules.d.ts", "internal/stencil-private.d.ts", "internal/stencil-public-compiler.d.ts", "internal/stencil-public-docs.d.ts", "internal/stencil-public-runtime.d.ts", "internal/client/css-shim.js", "internal/client/dom.js", "internal/client/index.js", "internal/client/patch.js", "internal/client/shadow-css.js", "internal/client/package.json", "internal/hydrate/index.js", "internal/hydrate/runner.js", "internal/hydrate/shadow-css.js", "internal/hydrate/package.json", "mock-doc/index.js", "mock-doc/package.json", "package.json" ]
}, {
  name: "typescript",
  version: "3.9.7",
  main: "lib/typescript.js",
  resources: [ "lib/lib.dom.d.ts", "lib/lib.es2015.d.ts", "lib/lib.es5.d.ts", "lib/lib.es2015.core.d.ts", "lib/lib.es2015.collection.d.ts", "lib/lib.es2015.generator.d.ts", "lib/lib.es2015.iterable.d.ts", "lib/lib.es2015.symbol.d.ts", "lib/lib.es2015.promise.d.ts", "lib/lib.es2015.proxy.d.ts", "lib/lib.es2015.reflect.d.ts", "lib/lib.es2015.symbol.wellknown.d.ts", "lib/lib.es2016.d.ts", "lib/lib.es2016.array.include.d.ts", "lib/lib.es2017.d.ts", "lib/lib.es2017.typedarrays.d.ts", "lib/lib.es2017.intl.d.ts", "lib/lib.es2017.object.d.ts", "lib/lib.es2017.sharedmemory.d.ts", "lib/lib.es2017.string.d.ts", "lib/lib.es2018.d.ts", "lib/lib.es2018.asyncgenerator.d.ts", "lib/lib.es2018.asynciterable.d.ts", "lib/lib.es2018.promise.d.ts", "lib/lib.es2018.regexp.d.ts", "lib/lib.es2018.intl.d.ts", "lib/lib.esnext.intl.d.ts", "lib/lib.es2020.bigint.d.ts", "package.json" ]
}, {
  name: "rollup",
  version: "2.21.0",
  main: "dist/rollup.browser.es.js"
}, {
  name: "terser",
  version: "4.8.0",
  main: "dist/bundle.min.js"
} ], startupCompilerLog = (e, t) => {
  if (!0 === t.suppressLogs) return;
  const {logger: s} = t, n = "debug" === s.getLevel(), r = e.version.includes("-"), o = e.version.includes("-dev.");
  r && !o && s.warn(s.yellow("This is a prerelease build, undocumented changes might happen at any time. Technical support is not available for prereleases, but any assistance testing is appreciated.")), 
  t.devMode && !n && (t.buildEs5 && s.warn("Generating ES5 during development is a very task expensive, initial and incremental builds will be much slower. Drop the '--es5' flag and use a modern browser for development."), 
  t.enableCache || s.warn("Disabling cache during development will slow down incremental builds."));
}, runPrerenderTask = async (e, t, s, n, r) => {
  const o = [];
  try {
    const i = await e.createPrerenderer(t), a = await i.start({
      hydrateAppFilePath: s,
      componentGraph: n,
      srcIndexHtmlPath: r
    });
    o.push(...a.diagnostics);
  } catch (e) {
    ((e, t, s) => {
      const n = {
        level: "error",
        type: "build",
        header: "Build Error",
        messageText: "build error",
        relFilePath: null,
        absFilePath: null,
        lines: []
      };
      isString(void 0) ? n.messageText = void 0 : null != t && (null != t.stack ? n.messageText = t.stack.toString() : null != t.message ? n.messageText = t.message.toString() : n.messageText = t.toString()), 
      null == e || shouldIgnoreError(n.messageText) || e.push(n);
    })(o, e);
  }
  return o;
}, startCheckVersion = async (e, t) => e.devMode && !e.flags.ci && !t.includes("-dev.") && isFunction(e.sys.checkVersion) ? e.sys.checkVersion(e.logger, t) : null, printCheckVersionResults = async e => {
  if (e) {
    const t = await e;
    isFunction(t) && t();
  }
}, isOutputTargetDocs = e => e.type === DOCS || e.type === DOCS_README || e.type === DOCS_JSON || e.type === DOCS_CUSTOM || e.type === DOCS_VSCODE, DOCS = "docs", DOCS_CUSTOM = "docs-custom", DOCS_JSON = "docs-json", DOCS_README = "docs-readme", DOCS_VSCODE = "docs-vscode", chooseFilesToGenerate = async () => {
  const {prompt: e} = await import("../sys/node/prompts.js");
  return (await e({
    name: "filesToGenerate",
    type: "multiselect",
    message: "Which additional files do you want to generate?",
    choices: [ {
      value: "css",
      title: "Stylesheet (.css)",
      selected: !0
    }, {
      value: "spec.tsx",
      title: "Spec Test  (.spec.tsx)",
      selected: !0
    }, {
      value: "e2e.ts",
      title: "E2E Test (.e2e.ts)",
      selected: !0
    } ]
  })).filesToGenerate;
}, isTest = e => "e2e.ts" === e || "spec.tsx" === e, getBoilerplateByExtension = (e, t, s) => {
  switch (t) {
   case "tsx":
    return getComponentBoilerplate(e, s);

   case "css":
    return getStyleUrlBoilerplate();

   case "spec.tsx":
    return getSpecTestBoilerplate(e);

   case "e2e.ts":
    return getE2eTestBoilerplate(e);

   default:
    throw new Error(`Unkown extension "${t}".`);
  }
}, getComponentBoilerplate = (e, t) => {
  const s = [ "{" ];
  return s.push(`  tag: '${e}',`), t && s.push(`  styleUrl: '${e}.css',`), s.push("  shadow: true,"), 
  s.push("}"), `import { Component, Host, h } from '@stencil/core';\n\n@Component(${s.join("\n")})\nexport class ${toPascalCase(e)} {\n\n  render() {\n    return (\n      <Host>\n        <slot></slot>\n      </Host>\n    );\n  }\n\n}\n`;
}, getStyleUrlBoilerplate = () => ":host {\n  display: block;\n}\n", getSpecTestBoilerplate = e => `import { newSpecPage } from '@stencil/core/testing';\nimport { ${toPascalCase(e)} } from '../${e}';\n\ndescribe('${e}', () => {\n  it('renders', async () => {\n    const page = await newSpecPage({\n      components: [${toPascalCase(e)}],\n      html: \`<${e}></${e}>\`,\n    });\n    expect(page.root).toEqualHtml(\`\n      <${e}>\n        <mock:shadow-root>\n          <slot></slot>\n        </mock:shadow-root>\n      </${e}>\n    \`);\n  });\n});\n`, getE2eTestBoilerplate = e => `import { newE2EPage } from '@stencil/core/testing';\n\ndescribe('${e}', () => {\n  it('renders', async () => {\n    const page = await newE2EPage();\n    await page.setContent('<${e}></${e}>');\n\n    const element = await page.find('${e}');\n    expect(element).toHaveClass('hydrated');\n  });\n});\n`, toPascalCase = e => e.split("-").reduce((e, t) => e + t[0].toUpperCase() + t.substr(1), ""), taskHelp = (e, t) => {
  const s = t.dim("windows" === e.details.platform ? ">" : "$");
  console.log(`\n  ${t.bold("Build:")} ${t.dim("Build components for development or production.")}\n\n    ${s} ${t.green("stencil build [--dev] [--watch] [--prerender] [--debug]")}\n\n      ${t.cyan("--dev")} ${t.dim(".............")} Development build\n      ${t.cyan("--watch")} ${t.dim("...........")} Rebuild when files update\n      ${t.cyan("--serve")} ${t.dim("...........")} Start the dev-server\n      ${t.cyan("--prerender")} ${t.dim(".......")} Prerender the application\n      ${t.cyan("--docs")} ${t.dim("............")} Generate component readme.md docs\n      ${t.cyan("--config")} ${t.dim("..........")} Set stencil config file\n      ${t.cyan("--stats")} ${t.dim("...........")} Write stencil-stats.json file\n      ${t.cyan("--log")} ${t.dim(".............")} Write stencil-build.log file\n      ${t.cyan("--debug")} ${t.dim("...........")} Set the log level to debug\n\n\n  ${t.bold("Test:")} ${t.dim("Run unit and end-to-end tests.")}\n\n    ${s} ${t.green("stencil test [--spec] [--e2e]")}\n\n      ${t.cyan("--spec")} ${t.dim("............")} Run unit tests with Jest\n      ${t.cyan("--e2e")} ${t.dim(".............")} Run e2e tests with Puppeteer\n\n\n  ${t.bold("Examples:")}\n\n    ${s} ${t.green("stencil build --dev --watch --serve")}\n    ${s} ${t.green("stencil build --prerender")}\n    ${s} ${t.green("stencil test --spec --e2e")}\n\n`);
}, run = async e => {
  const {args: t, logger: s, sys: n} = e;
  try {
    const e = parseFlags(t, n), r = e.task;
    if ((e.debug || e.verbose) && s.setLevel("debug"), e.ci && s.enableColors(!1), isFunction(n.applyGlobalPatch) && n.applyGlobalPatch(n.getCurrentDirectory()), 
    "help" === r || e.help) return void taskHelp(n, s);
    ((e, t) => {
      "info" !== t && "serve" !== t && "version" !== t && e.info(e.cyan("@stencil/core"));
    })(s, r);
    const o = await (async e => {
      const t = e.sys, s = t.getCurrentDirectory(), n = {
        configPath: null,
        rootDir: normalizePath(s),
        diagnostics: []
      };
      let r = e.configPath;
      r = isString(r) ? t.platformPath.isAbsolute(r) ? normalizePath(e.configPath) : normalizePath(t.platformPath.join(s, r)) : n.rootDir;
      const o = await t.stat(r);
      if (!o) {
        const e = (e => {
          const t = {
            level: "error",
            type: "build",
            header: "Build Error",
            messageText: "build error",
            relFilePath: null,
            absFilePath: null,
            lines: []
          };
          return e && e.push(t), t;
        })(n.diagnostics);
        return e.absFilePath = r, e.header = "Invalid config path", e.messageText = `Config path "${r}" not found`, 
        n;
      }
      if (o.isFile()) n.configPath = r, n.rootDir = t.platformPath.dirname(r); else if (o.isDirectory()) for (const e of [ "stencil.config.ts", "stencil.config.js" ]) {
        const s = t.platformPath.join(r, e), o = await t.stat(s);
        if (o && o.isFile()) {
          n.configPath = s, n.rootDir = t.platformPath.dirname(s);
          break;
        }
      }
      return n;
    })({
      sys: n,
      configPath: e.config
    });
    hasError(o.diagnostics) && (s.printDiagnostics(o.diagnostics), n.exit(1));
    const i = await n.ensureDependencies({
      rootDir: o.rootDir,
      logger: s,
      dependencies
    });
    hasError(i.diagnostics) && (s.printDiagnostics(i.diagnostics), n.exit(1));
    const a = await (async e => (await e.dynamicImport(e.getCompilerExecutingPath()), 
    globalThis.stencil))(n);
    if ("version" === r || e.version) return void console.log(a.version);
    if (((e, t, s) => {
      if ("info" === t || "serve" === t || "version" === t) return;
      let n;
      n = s.version.includes("-dev.") ? e.yellow("[LOCAL DEV]") : e.cyan("v" + s.version), 
      n += e.emoji(" " + s.vermoji), e.info(n);
    })(s, r, a), ((e, t, s, n) => {
      const r = e.details, o = `${e.name} ${e.version}`, i = `${r.platform}, ${r.cpuModel}`, a = `cpus: ${e.hardwareConcurrency}, freemem: ${Math.round(r.freemem() / 1e6)}MB, totalmem: ${Math.round(r.totalmem / 1e6)}MB`;
      "debug" === t.getLevel() ? (t.debug(o), t.debug(i), t.debug(a), t.debug("compiler: " + e.getCompilerExecutingPath()), 
      t.debug("build: " + n.buildId)) : s.ci && (t.info(o), t.info(i), t.info(a));
    })(n, s, e, a), "info" === r) return void ((e, t, s) => {
      const n = t.details, r = e.versions;
      console.log(""), console.log(`${s.cyan("      System:")} ${t.name} ${t.version}`), 
      console.log(`${s.cyan("     Plaform:")} ${n.platform} (${n.release})`), console.log(`${s.cyan("   CPU Model:")} ${n.cpuModel} (${t.hardwareConcurrency} cpu${1 !== t.hardwareConcurrency ? "s" : ""})`), 
      console.log(`${s.cyan("    Compiler:")} ${t.getCompilerExecutingPath()}`), console.log(`${s.cyan("       Build:")} ${e.buildId}`), 
      console.log(`${s.cyan("     Stencil:")} ${e.version}${s.emoji(" " + e.vermoji)}`), 
      console.log(`${s.cyan("  TypeScript:")} ${r.typescript}`), console.log(`${s.cyan("      Rollup:")} ${r.rollup}`), 
      console.log(`${s.cyan("      Terser:")} ${r.terser}`), console.log("");
    })(a, n, s);
    const l = await a.loadConfig({
      config: {
        flags: e
      },
      configPath: o.configPath,
      logger: s,
      sys: n,
      typescriptPath: i.typescriptPath
    });
    l.diagnostics.length > 0 && (s.printDiagnostics(l.diagnostics), hasError(l.diagnostics) && n.exit(1)), 
    isFunction(n.applyGlobalPatch) && n.applyGlobalPatch(l.config.rootDir), await n.ensureResources({
      rootDir: l.config.rootDir,
      logger: s,
      dependencies
    }), await runTask(a, l.config, r);
  } catch (e) {
    shouldIgnoreError(e) || (s.error(`uncaught cli error: ${e}${"debug" === s.getLevel() ? e.stack : ""}`), 
    n.exit(1));
  }
}, runTask = async (e, t, s) => {
  switch (t.flags = t.flags || {}, t.outputTargets = t.outputTargets || [], s) {
   case "build":
    await (async (e, t) => {
      if (t.flags.watch) return void await (async (e, t) => {
        let s = null, n = 0;
        try {
          startupCompilerLog(e, t);
          const r = startCheckVersion(t, e.version), o = await e.createCompiler(t), i = await o.createWatcher();
          if (t.flags.serve) {
            const e = t.sys.getDevServerExecutingPath(), {start: n} = await t.sys.dynamicImport(e);
            s = await n(t.devServer, t.logger, i);
          }
          t.sys.onProcessInterrupt(() => {
            o.destroy();
          });
          const a = i.on("buildFinish", async () => {
            a(), printCheckVersionResults(r);
          });
          if (s) {
            const e = i.on("buildFinish", () => {
              e(), t.logger.info(t.logger.cyan(s.browserUrl) + "\n");
            });
          }
          t.flags.prerender && i.on("buildFinish", async s => {
            if (!s.hasError) {
              const n = await runPrerenderTask(e, t, s.hydrateAppFilePath, s.componentGraph, null);
              t.logger.printDiagnostics(n);
            }
          });
          const l = await i.start();
          l.exitCode > 0 && (n = l.exitCode);
        } catch (e) {
          n = 1, t.logger.error(e);
        }
        s && await s.close(), n > 0 && t.sys.exit(n);
      })(e, t);
      let s = 0;
      try {
        startupCompilerLog(e, t);
        const n = startCheckVersion(t, e.version), r = await e.createCompiler(t), o = await r.build();
        if (await r.destroy(), o.hasError) s = 1; else if (t.flags.prerender) {
          const n = await runPrerenderTask(e, t, o.hydrateAppFilePath, o.componentGraph, null);
          t.logger.printDiagnostics(n), n.some(e => "error" === e.level) && (s = 1);
        }
        await printCheckVersionResults(n);
      } catch (e) {
        s = 1, t.logger.error(e);
      }
      s > 0 && t.sys.exit(s);
    })(e, t);
    break;

   case "docs":
    await (async (e, t) => {
      t.devServer = null, t.outputTargets = t.outputTargets.filter(isOutputTargetDocs), 
      t.devMode = !0, startupCompilerLog(e, t);
      const s = await e.createCompiler(t);
      await s.build(), await s.destroy();
    })(e, t);
    break;

   case "help":
    taskHelp(t.sys, t.logger);
    break;

   case "generate":
   case "g":
    await (async (e, t) => {
      IS_NODE_ENV || (t.logger.error('"generate" command is currently only implemented for a NodeJS environment'), 
      t.sys.exit(1));
      const s = e.path;
      t.configPath || (t.logger.error("Please run this command in your root directory (i. e. the one containing stencil.config.ts)."), 
      t.sys.exit(1));
      const n = t.srcDir;
      n || (t.logger.error("Stencil's srcDir was not specified."), t.sys.exit(1));
      const {prompt: r} = await import("../sys/node/prompts.js"), o = t.flags.unknownArgs.find(e => !e.startsWith("-")) || (await r({
        name: "tagName",
        type: "text",
        message: "Component tag name (dash-case):"
      })).tagName, {dir: i, base: a} = s.parse(o), l = (e => {
        if (e !== e.trim()) return "Tag can not contain white spaces";
        if (e !== e.toLowerCase()) return "Tag can not contain upper case characters";
        if ("string" != typeof e) return `Tag "${e}" must be a string type`;
        if (0 === e.length) return "Received empty tag value";
        if (e.indexOf(" ") > -1) return `"${e}" tag cannot contain a space`;
        if (e.indexOf(",") > -1) return `"${e}" tag cannot be used for multiple tags`;
        const t = e.replace(/\w|-/g, "");
        return "" !== t ? `"${e}" tag contains invalid characters: ${t}` : -1 === e.indexOf("-") ? `"${e}" tag must contain a dash (-) to work as a valid web component` : e.indexOf("--") > -1 ? `"${e}" tag cannot contain multiple dashes (--) next to each other` : 0 === e.indexOf("-") ? `"${e}" tag cannot start with a dash (-)` : e.lastIndexOf("-") === e.length - 1 ? `"${e}" tag cannot end with a dash (-)` : void 0;
      })(a);
      l && (t.logger.error(l), t.sys.exit(1));
      const c = [ "tsx", ...await chooseFilesToGenerate() ], g = c.some(isTest) ? "test" : "", d = s.join(n, "components", i, a);
      await t.sys.mkdir(s.join(d, g), {
        recursive: !0
      });
      const p = await Promise.all(c.map(s => (async (e, t, s, n, r, o) => {
        isTest(r) && (s = e.path.join(s, "test"));
        const i = e.path.join(s, `${n}.${r}`), a = getBoilerplateByExtension(n, r, o);
        return await t.sys.writeFile(i, a), i;
      })(e, t, d, a, s, c.includes("css")))).catch(e => t.logger.error(e));
      if (!p) return t.sys.exit(1);
      console.log(), console.log(`${t.logger.gray("$")} stencil generate ${o}`), console.log(), 
      console.log(t.logger.bold("The following files have been generated:"));
      const u = t.rootDir;
      p.map(e => console.log("  - " + s.relative(u, e)));
    })(e, t);
    break;

   case "prerender":
    await (async (e, t) => {
      startupCompilerLog(e, t);
      const s = t.flags.unknownArgs[0];
      "string" != typeof s && (t.logger.error("Missing hydrate app script path"), t.sys.exit(1));
      const n = t.srcIndexHtml, r = await runPrerenderTask(e, t, s, null, n);
      t.logger.printDiagnostics(r), r.some(e => "error" === e.level) && t.sys.exit(1);
    })(e, t);
    break;

   case "serve":
    await (async e => {
      e.suppressLogs = !0, e.flags.serve = !0, e.devServer.openBrowser = e.flags.open, 
      e.devServer.reloadStrategy = null, e.devServer.initialLoadUrl = "/", e.devServer.websocket = !1, 
      e.maxConcurrentWorkers = 1, e.devServer.root = isString(e.flags.root) ? e.flags.root : e.sys.getCurrentDirectory();
      const t = e.sys.getDevServerExecutingPath(), {start: s} = await e.sys.dynamicImport(t), n = await s(e.devServer, e.logger);
      console.log(`${e.logger.cyan("     Root:")} ${n.root}`), console.log(`${e.logger.cyan("  Address:")} ${n.address}`), 
      console.log(`${e.logger.cyan("     Port:")} ${n.port}`), console.log(`${e.logger.cyan("   Server:")} ${n.browserUrl}`), 
      console.log(""), e.sys.onProcessInterrupt(() => {
        n && n.close();
      });
    })(t);
    break;

   case "test":
    await (async e => {
      IS_NODE_ENV || (e.logger.error('"test" command is currently only implemented for a NodeJS environment'), 
      e.sys.exit(1));
      try {
        const t = {
          e2e: !!e.flags.e2e,
          screenshot: !!e.flags.screenshot,
          spec: !!e.flags.spec,
          updateScreenshot: !!e.flags.updateScreenshot
        }, s = [ "@types/jest", "jest", "jest-cli" ];
        if (t.e2e) {
          const n = e.testing.browserExecutablePath ? "puppeteer-core" : "puppeteer";
          s.push("@types/puppeteer", n), t.screenshot && e.logger.warn(e.logger.yellow("EXPERIMENTAL: screenshot visual diff testing is currently under heavy development and has not reached a stable status. However, any assistance testing would be appreciated."));
        }
        await e.sys.lazyRequire.ensure(e.logger, e.rootDir, s);
        const {createTesting: n} = await import("../testing/index.js"), r = await n(e), o = await r.run(t);
        await r.destroy(), o || e.sys.exit(1);
      } catch (t) {
        e.logger.error(t), e.sys.exit(1);
      }
    })(t);
    break;

   case "version":
    console.log(e.version);
    break;

   default:
    t.logger.error(t.logger.emoji("❌ ") + "Invalid stencil command, please see the options below:"), 
    taskHelp(t.sys, t.logger), t.sys.exit(1);
  }
};

export { parseFlags, run, runTask };