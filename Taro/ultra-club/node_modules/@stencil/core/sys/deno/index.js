function assertPath(e) {
  if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}

function isPosixPathSeparator(e) {
  return 47 === e;
}

function isPathSeparator(e) {
  return isPosixPathSeparator(e) || 92 === e;
}

function isWindowsDeviceRoot(e) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}

function normalizeString(e, t, r, n) {
  let o, a = "", i = 0, s = -1, l = 0;
  for (let c = 0, h = e.length; c <= h; ++c) {
    if (c < h) o = e.charCodeAt(c); else {
      if (n(o)) break;
      o = 47;
    }
    if (n(o)) {
      if (s === c - 1 || 1 === l) ; else if (s !== c - 1 && 2 === l) {
        if (a.length < 2 || 2 !== i || 46 !== a.charCodeAt(a.length - 1) || 46 !== a.charCodeAt(a.length - 2)) {
          if (a.length > 2) {
            const e = a.lastIndexOf(r);
            -1 === e ? (a = "", i = 0) : (a = a.slice(0, e), i = a.length - 1 - a.lastIndexOf(r)), 
            s = c, l = 0;
            continue;
          }
          if (2 === a.length || 1 === a.length) {
            a = "", i = 0, s = c, l = 0;
            continue;
          }
        }
        t && (a.length > 0 ? a += r + ".." : a = "..", i = 2);
      } else a.length > 0 ? a += r + e.slice(s + 1, c) : a = e.slice(s + 1, c), i = c - s - 1;
      s = c, l = 0;
    } else 46 === o && -1 !== l ? ++l : l = -1;
  }
  return a;
}

function _format(e, t) {
  const r = t.dir || t.root, n = t.base || (t.name || "") + (t.ext || "");
  return r ? r === t.root ? r + n : r + e + n : n;
}

function assert(e, t = "") {
  if (!e) throw new DenoStdInternalError(t);
}

function resolve(...e) {
  let t = "", r = "", n = !1;
  for (let o = e.length - 1; o >= -1; o--) {
    let a;
    if (o >= 0) a = e[o]; else if (t) {
      if (null == globalThis.Deno) throw new TypeError("Resolved a relative path without a CWD.");
      a = Deno.env.get("=" + t) || Deno.cwd(), void 0 !== a && a.slice(0, 3).toLowerCase() === t.toLowerCase() + "\\" || (a = t + "\\");
    } else {
      if (null == globalThis.Deno) throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      a = Deno.cwd();
    }
    assertPath(a);
    const i = a.length;
    if (0 === i) continue;
    let s = 0, l = "", c = !1;
    const h = a.charCodeAt(0);
    if (i > 1) if (isPathSeparator(h)) if (c = !0, isPathSeparator(a.charCodeAt(1))) {
      let e = 2, t = e;
      for (;e < i && !isPathSeparator(a.charCodeAt(e)); ++e) ;
      if (e < i && e !== t) {
        const r = a.slice(t, e);
        for (t = e; e < i && isPathSeparator(a.charCodeAt(e)); ++e) ;
        if (e < i && e !== t) {
          for (t = e; e < i && !isPathSeparator(a.charCodeAt(e)); ++e) ;
          e === i ? (l = `\\\\${r}\\${a.slice(t)}`, s = e) : e !== t && (l = `\\\\${r}\\${a.slice(t, e)}`, 
          s = e);
        }
      }
    } else s = 1; else isWindowsDeviceRoot(h) && 58 === a.charCodeAt(1) && (l = a.slice(0, 2), 
    s = 2, i > 2 && isPathSeparator(a.charCodeAt(2)) && (c = !0, s = 3)); else isPathSeparator(h) && (s = 1, 
    c = !0);
    if (!(l.length > 0 && t.length > 0 && l.toLowerCase() !== t.toLowerCase()) && (0 === t.length && l.length > 0 && (t = l), 
    n || (r = `${a.slice(s)}\\${r}`, n = c), n && t.length > 0)) break;
  }
  return r = normalizeString(r, !n, "\\", isPathSeparator), t + (n ? "\\" : "") + r || ".";
}

function normalize(e) {
  assertPath(e);
  const t = e.length;
  if (0 === t) return ".";
  let r, n = 0, o = !1;
  const a = e.charCodeAt(0);
  if (t > 1) if (isPathSeparator(a)) if (o = !0, isPathSeparator(e.charCodeAt(1))) {
    let o = 2, a = o;
    for (;o < t && !isPathSeparator(e.charCodeAt(o)); ++o) ;
    if (o < t && o !== a) {
      const i = e.slice(a, o);
      for (a = o; o < t && isPathSeparator(e.charCodeAt(o)); ++o) ;
      if (o < t && o !== a) {
        for (a = o; o < t && !isPathSeparator(e.charCodeAt(o)); ++o) ;
        if (o === t) return `\\\\${i}\\${e.slice(a)}\\`;
        o !== a && (r = `\\\\${i}\\${e.slice(a, o)}`, n = o);
      }
    }
  } else n = 1; else isWindowsDeviceRoot(a) && 58 === e.charCodeAt(1) && (r = e.slice(0, 2), 
  n = 2, t > 2 && isPathSeparator(e.charCodeAt(2)) && (o = !0, n = 3)); else if (isPathSeparator(a)) return "\\";
  let i;
  return i = n < t ? normalizeString(e.slice(n), !o, "\\", isPathSeparator) : "", 
  0 !== i.length || o || (i = "."), i.length > 0 && isPathSeparator(e.charCodeAt(t - 1)) && (i += "\\"), 
  void 0 === r ? o ? i.length > 0 ? "\\" + i : "\\" : i.length > 0 ? i : "" : o ? i.length > 0 ? `${r}\\${i}` : r + "\\" : i.length > 0 ? r + i : r;
}

function resolve$1(...e) {
  let t = "", r = !1;
  for (let n = e.length - 1; n >= -1 && !r; n--) {
    let o;
    if (n >= 0) o = e[n]; else {
      if (null == globalThis.Deno) throw new TypeError("Resolved a relative path without a CWD.");
      o = Deno.cwd();
    }
    assertPath(o), 0 !== o.length && (t = `${o}/${t}`, r = 47 === o.charCodeAt(0));
  }
  return t = normalizeString(t, !r, "/", isPosixPathSeparator), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
}

function normalize$1(e) {
  if (assertPath(e), 0 === e.length) return ".";
  const t = 47 === e.charCodeAt(0), r = 47 === e.charCodeAt(e.length - 1);
  return 0 !== (e = normalizeString(e, !t, "/", isPosixPathSeparator)).length || t || (e = "."), 
  e.length > 0 && r && (e += "/"), t ? "/" + e : e;
}

function globToRegExp(e, {extended: t = !1, globstar: r = !0} = {}) {
  const n = function o(e, {extended: t = !1, globstar: r = !1, strict: n = !1, filepath: a = !1, flags: i = ""} = {}) {
    function s(e, t = {
      split: !1,
      last: !1,
      only: ""
    }) {
      const {split: r, last: n, only: o} = t;
      "path" !== o && (c += e), a && "regex" !== o && (u += e.match(l) ? SEP$1 : e, r ? (n && (h += e), 
      "" !== h && (i.includes("g") || (h = `^${h}$`), d.push(new RegExp(h, i))), h = "") : h += e);
    }
    const l = new RegExp(`^${SEP$1}${n ? "" : "+"}$`);
    let c = "", h = "", u = "";
    const d = [];
    let f = !1, m = !1;
    const g = [];
    let p, y;
    for (let o = 0; o < e.length; o++) if (p = e[o], y = e[o + 1], [ "\\", "$", "^", ".", "=" ].includes(p)) s("\\" + p); else if (p.match(l)) s(SEP$1, {
      split: !0
    }), null != y && y.match(l) && !n && (c += "?"); else if ("(" !== p) if (")" !== p) if ("|" !== p) if ("+" !== p) if ("@" === p && t && "(" === y) g.push(p); else if ("!" !== p) if ("?" !== p) if ("[" !== p) if ("]" !== p) if ("{" !== p) if ("}" !== p) if ("," !== p) if ("*" !== p) s(p); else {
      if ("(" === y && t) {
        g.push(p);
        continue;
      }
      const n = e[o - 1];
      let a = 1;
      for (;"*" === e[o + 1]; ) a++, o++;
      const i = e[o + 1];
      r ? a > 1 && [ SEP_RAW, "/", void 0 ].includes(n) && [ SEP_RAW, "/", void 0 ].includes(i) ? (s(GLOBSTAR, {
        only: "regex"
      }), s(GLOBSTAR_SEGMENT, {
        only: "path",
        last: !0,
        split: !0
      }), o++) : (s(WILDCARD, {
        only: "regex"
      }), s(WILDCARD_SEGMENT, {
        only: "path"
      })) : s(".*");
    } else {
      if (f) {
        s("|");
        continue;
      }
      s("\\" + p);
    } else {
      if (t) {
        f = !1, s(")");
        continue;
      }
      s("\\" + p);
    } else {
      if (t) {
        f = !0, s("(?:");
        continue;
      }
      s("\\" + p);
    } else {
      if (t) {
        m = !1, s(p);
        continue;
      }
      s("\\" + p);
    } else {
      if (m && ":" === y) {
        o++;
        let t = "";
        for (;":" !== e[++o]; ) t += e[o];
        "alnum" === t ? s("(?:\\w|\\d)") : "space" === t ? s("\\s") : "digit" === t && s("\\d"), 
        o++;
        continue;
      }
      if (t) {
        m = !0, s(p);
        continue;
      }
      s("\\" + p);
    } else {
      if (t) {
        "(" === y ? g.push(p) : s(".");
        continue;
      }
      s("\\" + p);
    } else {
      if (t) {
        if (m) {
          s("^");
          continue;
        }
        if ("(" === y) {
          g.push(p), s("(?!"), o++;
          continue;
        }
        s("\\" + p);
        continue;
      }
      s("\\" + p);
    } else {
      if ("(" === y && t) {
        g.push(p);
        continue;
      }
      s("\\" + p);
    } else {
      if (g.length) {
        s(p);
        continue;
      }
      s("\\" + p);
    } else {
      if (g.length) {
        s(p);
        const e = g.pop();
        s("@" === e ? "{1}" : "!" === e ? WILDCARD : e);
        continue;
      }
      s("\\" + p);
    } else {
      if (g.length) {
        s(p + "?:");
        continue;
      }
      s("\\" + p);
    }
    i.includes("g") || (c = `^${c}$`, h = `^${h}$`, a && (u = `^${u}$`));
    const w = {
      regex: new RegExp(c, i)
    };
    return a && (d.push(new RegExp(h, i)), w.path = {
      regex: new RegExp(u, i),
      segments: d,
      globstar: new RegExp(i.includes("g") ? GLOBSTAR_SEGMENT : `^${GLOBSTAR_SEGMENT}$`, i)
    }), w;
  }(e, {
    extended: t,
    globstar: r,
    strict: !1,
    filepath: !0
  });
  return assert(null != n.path), n.path.regex;
}

function isGlob(e) {
  const t = {
    "{": "}",
    "(": ")",
    "[": "]"
  }, r = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if ("" === e) return !1;
  let n;
  for (;n = r.exec(e); ) {
    if (n[2]) return !0;
    let r = n.index + n[0].length;
    const o = n[1], a = o ? t[o] : null;
    if (o && a) {
      const t = e.indexOf(a, r);
      -1 !== t && (r = t + 1);
    }
    e = e.slice(r);
  }
  return !1;
}

function joinGlobs(e, {extended: t = !1, globstar: r = !1} = {}) {
  if (!r || 0 == e.length) return join$2(...e);
  if (0 === e.length) return ".";
  let n;
  for (const t of e) {
    const e = t;
    e.length > 0 && (n ? n += `${SEP}${e}` : n = e);
  }
  return n ? function o(e, {globstar: t = !1} = {}) {
    if (e.match(/\0/g)) throw new Error(`Glob contains invalid characters: "${e}"`);
    if (!t) return normalize$2(e);
    const r = SEP_PATTERN.source, n = new RegExp(`(?<=(${r}|^)\\*\\*${r})\\.\\.(?=${r}|$)`, "g");
    return normalize$2(e.replace(n, "\0")).replace(/\0/g, "..");
  }(n, {
    extended: t,
    globstar: r
  }) : ".";
}

function code(e, t) {
  return {
    open: `[${e.join(";")}m`,
    close: `[${t}m`,
    regexp: new RegExp(`\\x1b\\[${t}m`, "g")
  };
}

function run(e, t) {
  return enabled ? `${t.open}${e.replace(t.regexp, t.open)}${t.close}` : e;
}

async function createWalkEntry(e) {
  e = normalize$2(e);
  const t = basename$2(e), r = await Deno.stat(e);
  return {
    path: e,
    name: t,
    isFile: r.isFile,
    isDirectory: r.isDirectory,
    isSymlink: r.isSymlink
  };
}

function include(e, t, r, n) {
  return !(t && !t.some(t => e.endsWith(t)) || r && !r.some(t => !!e.match(t)) || n && n.some(t => !!e.match(t)));
}

async function* walk(e, {maxDepth: t = 1 / 0, includeFiles: r = !0, includeDirs: n = !0, followSymlinks: o = !1, exts: a, match: i, skip: s} = {}) {
  if (!(t < 0) && (n && include(e, a, i, s) && (yield await createWalkEntry(e)), !(t < 1) && include(e, void 0, void 0, s))) for await (const l of Deno.readDir(e)) {
    if (l.isSymlink) {
      if (o) throw new Error("unimplemented");
      continue;
    }
    assert(null != l.name);
    const c = join$2(e, l.name);
    l.isFile ? r && include(c, a, i, s) && (yield {
      path: c,
      ...l
    }) : yield* walk(c, {
      maxDepth: t - 1,
      includeFiles: r,
      includeDirs: n,
      followSymlinks: o,
      exts: a,
      match: i,
      skip: s
    });
  }
}

function throwUnlessNotFound(e) {
  if (!(e instanceof Deno.errors.NotFound)) throw e;
}

function comparePath(e, t) {
  return e.path < t.path ? -1 : e.path > t.path ? 1 : 0;
}

async function denoCopyTasks(e, t, r) {
  const n = {
    diagnostics: [],
    dirPaths: [],
    filePaths: []
  };
  try {
    t = ((e, t = (e => e)) => {
      const r = new Set;
      return e.filter(e => {
        const n = t(e);
        return null == n || !r.has(n) && (r.add(n), !0);
      });
    })((a = await Promise.all(t.map(e => async function t(e, r) {
      return isGlob(e.src) ? await async function n(e, t) {
        var r, n, o, a;
        const i = [];
        try {
          for (o = __asyncValues(async function* s(e, {root: t = Deno.cwd(), exclude: r = [], includeDirs: n = !0, extended: o = !1, globstar: a = !1} = {}) {
            async function* i(e, t) {
              if (e.isDirectory) if (".." != t) {
                if ("**" == t) return yield* walk(e.path, {
                  includeFiles: !1,
                  skip: h
                });
                yield* walk(e.path, {
                  maxDepth: 1,
                  match: [ globToRegExp(joinGlobs([ e.path, t ], s), s) ],
                  skip: h
                });
              } else {
                const t = joinGlobs([ e.path, ".." ], s);
                try {
                  if ((e => !h.some(t => !!e.match(t)))(t)) return yield await createWalkEntry(t);
                } catch (e) {
                  throwUnlessNotFound(e);
                }
              }
            }
            const s = {
              extended: o,
              globstar: a
            }, l = isAbsolute$2(t) ? normalize$2(t) : joinGlobs([ Deno.cwd(), t ], s), c = e => isAbsolute$2(e) ? normalize$2(e) : joinGlobs([ l, e ], s), h = r.map(c).map(e => globToRegExp(e, s)), {segments: u, hasTrailingSep: d, winRoot: f} = function m(e) {
              const t = SEP_PATTERN.source, r = e.replace(new RegExp(`^${t}|${t}$`, "g"), "").split(SEP_PATTERN), n = isAbsolute$2(e);
              return {
                segments: r,
                isAbsolute: n,
                hasTrailingSep: !!e.match(new RegExp(t + "$")),
                winRoot: isWindows$1 && n ? r.shift() : void 0
              };
            }(c(e));
            let g, p = null != f ? f : "/";
            for (;u.length > 0 && !isGlob(u[0]); ) {
              const e = u.shift();
              assert(null != e), p = joinGlobs([ p, e ], s);
            }
            try {
              g = await createWalkEntry(p);
            } catch (e) {
              return throwUnlessNotFound(e);
            }
            let y = [ g ];
            for (const e of u) {
              const t = new Map;
              for (const r of y) for await (const n of i(r, e)) t.set(n.path, n);
              y = [ ...t.values() ].sort(comparePath);
            }
            d && (y = y.filter(e => e.isDirectory)), n || (y = y.filter(e => !e.isDirectory)), 
            yield* y;
          }(e.src, {
            root: t
          })); !(a = await o.next()).done; ) {
            const r = createGlobCopyTask(e, t, a.value.name);
            i.push(r);
          }
        } catch (e) {
          r = {
            error: e
          };
        } finally {
          try {
            a && !a.done && (n = o.return) && await n.call(o);
          } finally {
            if (r) throw r.error;
          }
        }
        return i;
      }(e, r) : [ {
        src: getSrcAbsPath(r, e.src),
        dest: e.keepDirStructure ? join$2(e.dest, e.src) : e.dest,
        warn: e.warn,
        keepDirStructure: e.keepDirStructure
      } ];
    }(e, r))), t = a.flat ? a.flat(1) : a.reduce((e, t) => (e.push(...t), e), [])), e => e.dest);
    const o = [];
    for (;t.length > 0; ) {
      const r = t.splice(0, 100);
      await Promise.all(r.map(t => processCopyTask(e, n, o, t)));
    }
    const i = function o(e) {
      const t = [];
      return e.forEach(e => {
        !function r(e, t) {
          (t = normalizePath(t)) !== ROOT_DIR && t + "/" !== ROOT_DIR && "" !== t && (e.includes(t) || e.push(t));
        }(t, dirname$2(e.dest));
      }), t.sort((e, t) => {
        const r = e.split("/").length, n = t.split("/").length;
        return r < n ? -1 : r > n ? 1 : e < t ? -1 : e > t ? 1 : 0;
      }), t;
    }(o);
    try {
      await Promise.all(i.map(t => e.mkdir(t, {
        recursive: !0
      })));
    } catch (e) {}
    for (;o.length > 0; ) {
      const t = o.splice(0, 100);
      await Promise.all(t.map(t => e.copyFile(t.src, t.dest)));
    }
  } catch (e) {
    catchError(n.diagnostics, e);
  }
  var a;
  return n;
}

function getSrcAbsPath(e, t) {
  return isAbsolute$2(t) ? t : join$2(e, t);
}

function createGlobCopyTask(e, t, r) {
  const n = join$2(e.dest, e.keepDirStructure ? r : basename$2(r));
  return {
    src: join$2(t, r),
    dest: n,
    warn: e.warn,
    keepDirStructure: e.keepDirStructure
  };
}

async function processCopyTask(e, t, r, n) {
  try {
    n.src = normalizePath(n.src), n.dest = normalizePath(n.dest), (await e.stat(n.src)).isDirectory ? (t.dirPaths.includes(n.dest) || t.dirPaths.push(n.dest), 
    await async function o(e, t, r, n) {
      var o, a, i, s;
      try {
        try {
          for (i = __asyncValues(e.readDir(n.src)); !(s = await i.next()).done; ) {
            const o = s.value, a = {
              src: join$2(n.src, o.name),
              dest: join$2(n.dest, o.name),
              warn: n.warn
            };
            await processCopyTask(e, t, r, a);
          }
        } catch (e) {
          o = {
            error: e
          };
        } finally {
          try {
            s && !s.done && (a = i.return) && await a.call(i);
          } finally {
            if (o) throw o.error;
          }
        }
      } catch (e) {
        catchError(t.diagnostics, e);
      }
    }(e, t, r, n)) : function a(e) {
      return e = e.trim().toLowerCase(), IGNORE.some(t => e.endsWith(t));
    }(n.src) || (t.filePaths.includes(n.dest) || t.filePaths.push(n.dest), r.push(n));
  } catch (e) {
    !1 !== n.warn && (buildError(t.diagnostics).messageText = e.message);
  }
}

function createDenoSys(e = {}) {
  let t, r, n, o, a = null, i = new URL("../../compiler/stencil.js", import.meta.url).href;
  const s = e.Deno || globalThis.Deno, l = new Set, c = isRemoteUrl(import.meta.url), h = async (e, t, r) => {
    try {
      return void await s.stat(r);
    } catch (e) {}
    try {
      const n = await fetch(t);
      if (n.ok) {
        const e = dirname$2(r);
        try {
          await s.mkdir(e, {
            recursive: !0
          });
        } catch (e) {}
        const t = await n.clone().text(), o = new TextEncoder;
        await s.writeFile(r, o.encode(t));
      } else buildError(e).messageText = `Unable to fetch: ${t}, ${n.status}`;
    } catch (t) {
      catchError(e, t);
    }
  }, u = {
    name: "deno",
    version: s.version.deno,
    async access(e) {
      try {
        return await s.stat(e), !0;
      } catch (e) {
        return !1;
      }
    },
    accessSync(e) {
      try {
        return s.statSync(e), !0;
      } catch (e) {
        return !1;
      }
    },
    addDestory(e) {
      l.add(e);
    },
    removeDestory(e) {
      l.delete(e);
    },
    async copyFile(e, t) {
      try {
        return await s.copyFile(e, t), !0;
      } catch (e) {
        return !1;
      }
    },
    createWorkerController: e => ((e, t) => {
      let r = 0, n = !1, o = !1, a = 0;
      const i = new Map, s = [], l = [], c = Math.max(Math.min(t, e.hardwareConcurrency), 2) - 1, h = new Map, u = e => console.error(e), d = () => {
        const e = new URL("./worker.js", import.meta.url).href, t = {
          name: "stencil.worker." + a++,
          type: "module",
          deno: !0
        }, r = new Worker(e, t), o = {
          worker: r,
          activeTasks: 0,
          sendQueue: []
        };
        return r.onerror = u, r.onmessage = e => ((e, t) => {
          if (!n) {
            const r = t.data;
            if (Array.isArray(r)) for (const t of r) if (t) {
              const r = i.get(t.stencilId);
              r ? (i.delete(t.stencilId), t.stencilRtnError ? r.reject(t.stencilRtnError) : r.resolve(t.stencilRtnValue), 
              e.activeTasks--, (e.activeTasks < 0 || e.activeTasks > 50) && (e.activeTasks = 0)) : t.stencilRtnError && console.error(t.stencilRtnError);
            }
          }
        })(o, e), o;
      }, f = e => {
        e.sendQueue.length > 0 && (e.worker.postMessage(e.sendQueue), e.sendQueue.length = 0);
      }, m = e => {
        let t;
        if (l.length > 0) {
          if (t = l[0], c > 1) {
            for (const e of l) e.activeTasks < t.activeTasks && (t = e);
            t.activeTasks > 0 && l.length < c && (t = d(), l.push(t));
          }
        } else t = d(), l.push(t);
        t.activeTasks++, t.sendQueue.push(e);
      }, g = () => {
        o = !1, s.forEach(m), s.length = 0, l.forEach(f);
      }, p = (...e) => new Promise((t, a) => {
        if (n) a(TASK_CANCELED_MSG); else {
          const n = {
            stencilId: r++,
            args: e
          };
          s.push(n), h.set(n.stencilId, Date.now()), i.set(n.stencilId, {
            resolve: t,
            reject: a
          }), o || (o = !0, queueMicrotask(g));
        }
      });
      return {
        send: p,
        destroy: () => {
          n = !0, i.forEach(e => e.reject(TASK_CANCELED_MSG)), i.clear(), l.forEach(e => e.worker.terminate()), 
          l.length = 0;
        },
        handler: e => function(...t) {
          return p(e, ...t);
        },
        maxWorkers: c
      };
    })(u, e),
    async destroy() {
      const e = [];
      l.forEach(t => {
        try {
          const r = t();
          r && r.then && e.push(r);
        } catch (e) {
          console.error("node sys destroy: " + e);
        }
      }), await Promise.all(e), l.clear();
    },
    dynamicImport: e => (c && (e = (e => (!isString(e) || isRemoteUrl(e) || isFileUrl(e) || (e = isFileUrl(e) ? new URL(e).href : (e = normalizePath(e)).startsWith("/") ? "file://" + e : "file:///" + e), 
    e))(e)), import(e + "?1.16.4")),
    encodeToBase64: e => Buffer.from(e).toString("base64"),
    async ensureDependencies(e) {
      const a = e.logger.createTimeSpan("ensure dependencies start", !0), s = [], l = e.dependencies.find(e => "@stencil/core" === e.name), c = e.dependencies.find(e => "typescript" === e.name);
      r = new URL("../../compiler/stencil.js", import.meta.url).href, isRemoteUrl(r) || (r = u.getRemoteModuleUrl({
        moduleId: l.name,
        version: l.version,
        path: l.main
      })), t = new URL("../../", r), i = u.getLocalModulePath({
        rootDir: e.rootDir,
        moduleId: l.name,
        path: l.main
      }), n = u.getRemoteModuleUrl({
        moduleId: c.name,
        version: c.version,
        path: c.main
      }), o = u.getLocalModulePath({
        rootDir: e.rootDir,
        moduleId: c.name,
        path: c.main
      });
      const d = h(s, r, i), f = h(s, n, o);
      return await Promise.all([ d, f ]), u.getCompilerExecutingPath = () => i, a.finish("ensure dependencies end"), 
      {
        stencilPath: i,
        typescriptPath: o,
        diagnostics: s
      };
    },
    async ensureResources(e) {
      const r = e.dependencies.find(e => "@stencil/core" === e.name), n = e.dependencies.find(e => "typescript" === e.name), o = [], a = u.getLocalModulePath({
        rootDir: e.rootDir,
        moduleId: r.name,
        path: "package.json"
      }), i = u.getLocalModulePath({
        rootDir: e.rootDir,
        moduleId: n.name,
        path: "package.json"
      }), s = u.access(a), l = u.access(i), c = await s, h = await l;
      if (c || (e.logger.debug("stencilBaseUrl: " + t.href), r.resources.forEach(n => {
        o.push({
          url: new URL(n, t).href,
          path: u.getLocalModulePath({
            rootDir: e.rootDir,
            moduleId: r.name,
            path: n
          })
        });
      })), h || n.resources.forEach(t => {
        o.push({
          url: u.getRemoteModuleUrl({
            moduleId: n.name,
            version: n.version,
            path: t
          }),
          path: u.getLocalModulePath({
            rootDir: e.rootDir,
            moduleId: n.name,
            path: t
          })
        });
      }), o.length > 0) {
        console.log(o);
        const t = new Set, r = e.logger.createTimeSpan("ensure resources start", !0);
        await Promise.all(o.map(async r => {
          const n = await fetch(r.url);
          if (n.ok) {
            const e = n.text(), o = dirname$2(r.path);
            t.has(o) || (u.mkdir(o, {
              recursive: !0
            }), t.add(o)), await u.writeFile(r.path, await e);
          } else e.logger.error("unable to fetch: " + r.url);
        })), r.finish("ensure resources end: " + o.length);
      }
    },
    exit: s.exit,
    getCompilerExecutingPath: () => i,
    getCurrentDirectory: () => normalizePath(s.cwd()),
    getEnvironmentVar: e => s.env.get(e),
    getLocalModulePath: e => join$2(e.rootDir, "node_modules", e.moduleId, e.path),
    getRemoteModuleUrl: e => {
      const t = `${e.moduleId}${e.version ? "@" + e.version : ""}/${e.path}`;
      return new URL(t, "https://cdn.jsdelivr.net/npm/").href;
    },
    glob: (e, t) => null,
    hardwareConcurrency: 0,
    async isSymbolicLink(e) {
      try {
        return (await s.stat(e)).isSymlink;
      } catch (e) {
        return !1;
      }
    },
    async mkdir(e, t) {
      const r = {
        basename: basename$2(e),
        dirname: dirname$2(e),
        path: e,
        newDirs: [],
        error: null
      };
      try {
        await s.mkdir(e, t);
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    mkdirSync(e, t) {
      const r = {
        basename: basename$2(e),
        dirname: dirname$2(e),
        path: e,
        newDirs: [],
        error: null
      };
      try {
        s.mkdirSync(e, t);
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    nextTick: queueMicrotask,
    normalizePath,
    platformPath: {
      basename: basename$2,
      dirname: dirname$2,
      extname: extname$2,
      isAbsolute: isAbsolute$2,
      join: join$2,
      normalize: normalize$2,
      parse: parse$2,
      relative: relative$2,
      resolve: resolve$2,
      sep: sep$2,
      delimiter: delimiter$2,
      posix,
      win32
    },
    async readdir(e) {
      var t, r, n, o;
      const a = [];
      try {
        try {
          for (n = __asyncValues$1(s.readDir(e)); !(o = await n.next()).done; ) {
            const t = o.value;
            a.push(join$2(e, t.name));
          }
        } catch (e) {
          t = {
            error: e
          };
        } finally {
          try {
            o && !o.done && (r = n.return) && await r.call(n);
          } finally {
            if (t) throw t.error;
          }
        }
      } catch (e) {}
      return a;
    },
    readdirSync(e) {
      const t = [];
      try {
        for (const r of s.readDirSync(e)) t.push(join$2(e, r.name));
      } catch (e) {}
      return t;
    },
    async readFile(e) {
      try {
        const t = new TextDecoder("utf-8"), r = await s.readFile(e);
        return t.decode(r);
      } catch (e) {}
    },
    readFileSync(e) {
      try {
        const t = new TextDecoder("utf-8"), r = s.readFileSync(e);
        return t.decode(r);
      } catch (e) {}
    },
    async realpath(e) {
      const t = {
        error: null,
        path: void 0
      };
      try {
        t.path = await s.realPath(e);
      } catch (e) {
        t.error = e;
      }
      return t;
    },
    realpathSync(e) {
      const t = {
        error: null,
        path: void 0
      };
      try {
        t.path = s.realPathSync(e);
      } catch (e) {
        t.error = e;
      }
      return t;
    },
    async rename(e, t) {
      const r = {
        oldPath: e,
        newPath: t,
        error: null,
        oldDirs: [],
        oldFiles: [],
        newDirs: [],
        newFiles: [],
        renamed: [],
        isFile: !1,
        isDirectory: !1
      };
      try {
        await s.rename(e, t);
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    resolvePath: e => normalizePath(e),
    async rmdir(e, t) {
      const r = {
        basename: basename$2(e),
        dirname: dirname$2(e),
        path: e,
        removedDirs: [],
        removedFiles: [],
        error: null
      };
      try {
        await s.remove(e, t);
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    rmdirSync(e, t) {
      const r = {
        basename: basename$2(e),
        dirname: dirname$2(e),
        path: e,
        removedDirs: [],
        removedFiles: [],
        error: null
      };
      try {
        s.removeSync(e, t);
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    async stat(e) {
      try {
        const t = s.statSync(e);
        return {
          isFile: () => t.isFile,
          isDirectory: () => t.isDirectory,
          isSymbolicLink: () => t.isSymlink,
          size: t.size
        };
      } catch (e) {}
    },
    statSync(e) {
      try {
        const t = s.statSync(e);
        return {
          isFile: () => t.isFile,
          isDirectory: () => t.isDirectory,
          isSymbolicLink: () => t.isSymlink,
          size: t.size
        };
      } catch (e) {}
    },
    tmpdir: () => (null == a && (a = dirname$2(s.makeTempDirSync())), a),
    async unlink(e) {
      const t = {
        basename: basename$2(e),
        dirname: dirname$2(e),
        path: e,
        error: null
      };
      try {
        await s.remove(e);
      } catch (e) {
        t.error = e;
      }
      return t;
    },
    unlinkSync(e) {
      const t = {
        basename: basename$2(e),
        dirname: dirname$2(e),
        path: e,
        error: null
      };
      try {
        s.removeSync(e);
      } catch (e) {
        t.error = e;
      }
      return t;
    },
    async writeFile(e, t) {
      const r = {
        path: e,
        error: null
      };
      try {
        const r = new TextEncoder;
        await s.writeFile(e, r.encode(t));
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    writeFileSync(e, t) {
      const r = {
        path: e,
        error: null
      };
      try {
        const r = new TextEncoder;
        s.writeFileSync(e, r.encode(t));
      } catch (e) {
        r.error = e;
      }
      return r;
    },
    watchDirectory(e, t, r) {
      const n = s.watchFs(e, {
        recursive: r
      });
      (async () => {
        var e, r, o, a;
        try {
          try {
            for (o = __asyncValues$1(n); !(a = await o.next()).done; ) {
              const e = a.value;
              for (const r of e.paths) {
                const n = normalizePath(r);
                "create" === e.kind ? (t(n, "dirAdd"), u.events.emit("dirAdd", n)) : "modify" === e.kind ? (t(n, "fileUpdate"), 
                u.events.emit("fileUpdate", n)) : "remove" === e.kind && (t(n, "dirDelete"), u.events.emit("dirDelete", n));
              }
            }
          } catch (t) {
            e = {
              error: t
            };
          } finally {
            try {
              a && !a.done && (r = o.return) && await r.call(o);
            } finally {
              if (e) throw e.error;
            }
          }
        } catch (e) {}
      })();
      const o = async () => {
        try {
          await n.return();
        } catch (e) {}
      };
      return u.addDestory(o), {
        close: o
      };
    },
    watchFile(e, t) {
      const r = s.watchFs(e, {
        recursive: !1
      });
      (async () => {
        var e, n, o, a;
        try {
          try {
            for (o = __asyncValues$1(r); !(a = await o.next()).done; ) {
              const e = a.value;
              for (const r of e.paths) {
                const n = normalizePath(r);
                "create" === e.kind ? (t(n, "fileAdd"), u.events.emit("fileAdd", n)) : "modify" === e.kind ? (t(n, "fileUpdate"), 
                u.events.emit("fileUpdate", n)) : "remove" === e.kind && (t(n, "fileDelete"), u.events.emit("fileDelete", n));
              }
            }
          } catch (t) {
            e = {
              error: t
            };
          } finally {
            try {
              a && !a.done && (n = o.return) && await n.call(o);
            } finally {
              if (e) throw e.error;
            }
          }
        } catch (e) {}
      })();
      const n = async () => {
        try {
          await r.return();
        } catch (e) {}
      };
      return u.addDestory(n), {
        close: n
      };
    },
    async generateContentHash(e) {
      const t = e.length;
      if (0 === t) return "";
      let r = 0;
      for (let n = 0; n < t; n++) r = (r << 5) - r + e.charCodeAt(n), r |= 0;
      return r < 0 && (r *= -1), r + "";
    },
    copy: (e, t) => denoCopyTasks(s, e, t),
    details: {
      cpuModel: "cpu-model",
      freemem: () => 0,
      platform: s.build.os,
      release: s.build.vendor,
      totalmem: 0
    },
    applyGlobalPatch: async e => {
      const {applyNodeCompat: t} = await import("./node-compat.js");
      t({
        fromDir: e
      });
    }
  };
  return u;
}

var _a, _b, __asyncValues, __asyncValues$1;

const createTerminalLogger = e => {
  let t = "info", r = null;
  const n = [], o = e => {
    if (e.length) {
      const t = new Date, r = "[" + ("0" + t.getMinutes()).slice(-2) + ":" + ("0" + t.getSeconds()).slice(-2) + "." + Math.floor(t.getMilliseconds() / 1e3 * 10) + "]";
      e[0] = f(r) + e[0].substr(r.length);
    }
  }, a = e => {
    if (e.length) {
      const t = "[ WARN  ]";
      e[0] = d(h(t)) + e[0].substr(t.length);
    }
  }, i = e => {
    if (e.length) {
      const t = "[ ERROR ]";
      e[0] = d(c(t)) + e[0].substr(t.length);
    }
  }, s = e => {
    if (e.length) {
      const t = new Date, r = "[" + ("0" + t.getMinutes()).slice(-2) + ":" + ("0" + t.getSeconds()).slice(-2) + "." + Math.floor(t.getMilliseconds() / 1e3 * 10) + "]";
      e[0] = u(r) + e[0].substr(r.length);
    }
  }, l = (t, o) => {
    if (r) {
      const r = new Date, a = ("0" + r.getHours()).slice(-2) + ":" + ("0" + r.getMinutes()).slice(-2) + ":" + ("0" + r.getSeconds()).slice(-2) + ".0" + Math.floor(r.getMilliseconds() / 1e3 * 10) + "  " + ("000" + (e.memoryUsage() / 1e6).toFixed(1)).slice(-6) + "MB  " + t + "  " + o.join(", ");
      n.push(a);
    }
  }, c = t => e.color(t, "red"), h = t => e.color(t, "yellow"), u = t => e.color(t, "cyan"), d = t => e.color(t, "bold"), f = t => e.color(t, "dim"), m = t => e.color(t, "bgRed"), g = e => LOG_LEVELS.indexOf(e) >= LOG_LEVELS.indexOf(t), p = (t, r, n) => {
    var o, a;
    let i = t.length - r + n - 1;
    for (;t.length + INDENT.length > e.getColumns(); ) if (r > t.length - r + n && r > 5) t = t.substr(1), 
    r--; else {
      if (!(i > 1)) break;
      t = t.substr(0, t.length - 1), i--;
    }
    const s = [], l = Math.max(t.length, r + n);
    for (o = 0; o < l; o++) a = t.charAt(o), o >= r && o < r + n && (a = m("" === a ? " " : a)), 
    s.push(a);
    return s.join("");
  }, y = e => e.trim().startsWith("//") ? f(e) : e.split(" ").map(e => JS_KEYWORDS.indexOf(e) > -1 ? u(e) : e).join(" "), w = e => {
    let t = !0;
    const r = [];
    for (var n = 0; n < e.length; n++) {
      const o = e.charAt(n);
      ";" === o || "{" === o ? t = !0 : ".#,:}@$[]/*".indexOf(o) > -1 && (t = !1), t && "abcdefghijklmnopqrstuvwxyz-_".indexOf(o.toLowerCase()) > -1 ? r.push(u(o)) : r.push(o);
    }
    return r.join("");
  };
  return {
    enableColors: e.enableColors,
    emoji: e.emoji,
    getLevel: () => t,
    setLevel: e => t = e,
    debug: (...t) => {
      if (g("debug")) {
        e.memoryUsage() > 0 && t.push(f(` MEM: ${(e.memoryUsage() / 1e6).toFixed(1)}MB`));
        const r = wordWrap(t, e.getColumns());
        s(r), console.log(r.join("\n"));
      }
      l("D", t);
    },
    info: (...t) => {
      if (g("info")) {
        const r = wordWrap(t, e.getColumns());
        o(r), console.log(r.join("\n"));
      }
      l("I", t);
    },
    warn: (...t) => {
      if (g("warn")) {
        const r = wordWrap(t, e.getColumns());
        a(r), console.warn("\n" + r.join("\n") + "\n");
      }
      l("W", t);
    },
    error: (...t) => {
      for (let e = 0; e < t.length; e++) if (t[e] instanceof Error) {
        const r = t[e];
        t[e] = r.message, r.stack && (t[e] += "\n" + r.stack);
      }
      if (g("error")) {
        const r = wordWrap(t, e.getColumns());
        i(r), console.error("\n" + r.join("\n") + "\n");
      }
      l("E", t);
    },
    createTimeSpan: (t, r = !1, n) => {
      const a = Date.now(), i = () => Date.now() - a, c = {
        duration: i,
        finish: (t, a, c, h) => {
          const u = i();
          let m;
          return m = u > 1e3 ? "in " + (u / 1e3).toFixed(2) + " s" : parseFloat(u.toFixed(3)) > 0 ? "in " + u + " ms" : "in less than 1 ms", 
          ((t, r, n, a, i, c, h) => {
            let u = t;
            if (n && (u = e.color(t, n)), a && (u = d(u)), u += " " + f(r), c) {
              if (g("debug")) {
                const t = [ u ], r = e.memoryUsage();
                r > 0 && t.push(f(` MEM: ${(r / 1e6).toFixed(1)}MB`));
                const n = wordWrap(t, e.getColumns());
                s(n), console.log(n.join("\n"));
              }
              l("D", [ `${t} ${r}` ]);
            } else {
              const n = wordWrap([ u ], e.getColumns());
              o(n), console.log(n.join("\n")), l("I", [ `${t} ${r}` ]), h && h.push(`${t} ${r}`);
            }
            i && console.log("");
          })(t, m, a, c, h, r, n), u;
        }
      };
      return ((t, r, n) => {
        const a = [ `${t} ${f("...")}` ];
        if (r) {
          if (g("debug")) {
            e.memoryUsage() > 0 && a.push(f(` MEM: ${(e.memoryUsage() / 1e6).toFixed(1)}MB`));
            const r = wordWrap(a, e.getColumns());
            s(r), console.log(r.join("\n")), l("D", [ t + " ..." ]);
          }
        } else {
          const r = wordWrap(a, e.getColumns());
          o(r), console.log(r.join("\n")), l("I", [ t + " ..." ]), n && n.push(t + " ...");
        }
      })(t, r, n), c;
    },
    printDiagnostics: (r, n) => {
      if (!r || 0 === r.length) return;
      let l = [ "" ];
      r.forEach(r => {
        l = l.concat(((r, n) => {
          const l = wordWrap([ r.messageText ], e.getColumns());
          let c = "";
          r.header && "Build Error" !== r.header && (c += r.header), "string" == typeof r.absFilePath && "string" != typeof r.relFilePath && ("string" != typeof n && (n = e.cwd()), 
          r.relFilePath = e.relativePath(n, r.absFilePath), r.relFilePath.includes("/") || (r.relFilePath = "./" + r.relFilePath));
          let d = r.relFilePath;
          return "string" != typeof d && (d = r.absFilePath), "string" == typeof d && (c.length > 0 && (c += ": "), 
          c += u(d), "number" == typeof r.lineNumber && r.lineNumber > -1 && (c += f(":"), 
          c += h("" + r.lineNumber), "number" == typeof r.columnNumber && r.columnNumber > -1 && (c += f(":"), 
          c += h("" + r.columnNumber)))), c.length > 0 && l.unshift(INDENT + c), l.push(""), 
          r.lines && r.lines.length && (prepareLines(r.lines).forEach(e => {
            if (!isMeaningfulLine(e.text)) return;
            let t = "";
            for (e.lineNumber > -1 && (t = `L${e.lineNumber}:  `); t.length < INDENT.length; ) t = " " + t;
            let n = e.text;
            e.errorCharStart > -1 && (n = p(n, e.errorCharStart, e.errorLength)), t = f(t), 
            "typescript" === r.language || "javascript" === r.language ? t += y(n) : "scss" === r.language || "css" === r.language ? t += w(n) : t += n, 
            l.push(t);
          }), l.push("")), "error" === r.level ? i(l) : "warn" === r.level ? a(l) : "debug" === r.level ? s(l) : o(l), 
          null != r.debugText && "debug" === t && (l.push(r.debugText), s(wordWrap([ r.debugText ], e.getColumns()))), 
          l;
        })(r, n));
      }), console.log(l.join("\n"));
    },
    red: c,
    green: t => e.color(t, "green"),
    yellow: h,
    blue: t => e.color(t, "blue"),
    magenta: t => e.color(t, "magenta"),
    cyan: u,
    gray: t => e.color(t, "gray"),
    bold: d,
    dim: f,
    bgRed: m,
    setLogFilePath: e => r = e,
    writeLogs: t => {
      if (r) try {
        l("F", [ "--------------------------------------" ]), e.writeLogs(r, n.join("\n"), t);
      } catch (e) {}
      n.length = 0;
    }
  };
}, LOG_LEVELS = [ "debug", "info", "warn", "error" ], wordWrap = (e, t) => {
  const r = [], n = [];
  e.forEach(e => {
    null === e ? n.push("null") : void 0 === e ? n.push("undefined") : "string" == typeof e ? e.replace(/\s/gm, " ").split(" ").forEach(e => {
      e.trim().length && n.push(e.trim());
    }) : "number" == typeof e || "boolean" == typeof e || "function" == typeof e ? n.push(e.toString()) : Array.isArray(e) || Object(e) === e ? n.push(() => e.toString()) : n.push(e.toString());
  });
  let o = INDENT;
  return n.forEach(e => {
    r.length > 25 || ("function" == typeof e ? (o.trim().length && r.push(o), r.push(e()), 
    o = INDENT) : INDENT.length + e.length > t - 1 ? (o.trim().length && r.push(o), 
    r.push(INDENT + e), o = INDENT) : e.length + o.length > t - 1 ? (r.push(o), o = INDENT + e + " ") : o += e + " ");
  }), o.trim().length && r.push(o), r.map(e => e.trimRight());
}, prepareLines = e => {
  const t = JSON.parse(JSON.stringify(e));
  for (let e = 0; e < 100; e++) {
    if (!eachLineHasLeadingWhitespace(t)) return t;
    for (let e = 0; e < t.length; e++) if (t[e].text = t[e].text.substr(1), t[e].errorCharStart--, 
    !t[e].text.length) return t;
  }
  return t;
}, eachLineHasLeadingWhitespace = e => {
  if (!e.length) return !1;
  for (var t = 0; t < e.length; t++) {
    if (!e[t].text || e[t].text.length < 1) return !1;
    const r = e[t].text.charAt(0);
    if (" " !== r && "\t" !== r) return !1;
  }
  return !0;
}, isMeaningfulLine = e => !!e && (e = e.trim()).length > 0, JS_KEYWORDS = [ "abstract", "any", "as", "break", "boolean", "case", "catch", "class", "console", "const", "continue", "debugger", "declare", "default", "delete", "do", "else", "enum", "export", "extends", "false", "finally", "for", "from", "function", "get", "if", "import", "in", "implements", "Infinity", "instanceof", "let", "module", "namespace", "NaN", "new", "number", "null", "public", "private", "protected", "require", "return", "static", "set", "string", "super", "switch", "this", "throw", "try", "true", "type", "typeof", "undefined", "var", "void", "with", "while", "yield" ], INDENT = "           ", navigator = globalThis.navigator;

let isWindows = !1;

null != globalThis.Deno ? isWindows = "windows" == Deno.build.os : null != (null == navigator ? void 0 : navigator.appVersion) && (isWindows = navigator.appVersion.includes("Win"));

class DenoStdInternalError extends Error {
  constructor(e) {
    super(e), this.name = "DenoStdInternalError";
  }
}

const _win32 = {
  __proto__: null,
  sep: "\\",
  delimiter: ";",
  resolve,
  normalize,
  isAbsolute: function isAbsolute(e) {
    assertPath(e);
    const t = e.length;
    if (0 === t) return !1;
    const r = e.charCodeAt(0);
    return !!isPathSeparator(r) || !!(isWindowsDeviceRoot(r) && t > 2 && 58 === e.charCodeAt(1) && isPathSeparator(e.charCodeAt(2)));
  },
  join: function join(...e) {
    const t = e.length;
    if (0 === t) return ".";
    let r, n = null;
    for (let o = 0; o < t; ++o) {
      const t = e[o];
      assertPath(t), t.length > 0 && (void 0 === r ? r = n = t : r += "\\" + t);
    }
    if (void 0 === r) return ".";
    let o = !0, a = 0;
    if (assert(null != n), isPathSeparator(n.charCodeAt(0))) {
      ++a;
      const e = n.length;
      e > 1 && isPathSeparator(n.charCodeAt(1)) && (++a, e > 2 && (isPathSeparator(n.charCodeAt(2)) ? ++a : o = !1));
    }
    if (o) {
      for (;a < r.length && isPathSeparator(r.charCodeAt(a)); ++a) ;
      a >= 2 && (r = "\\" + r.slice(a));
    }
    return normalize(r);
  },
  relative: function relative(e, t) {
    if (assertPath(e), assertPath(t), e === t) return "";
    const r = resolve(e), n = resolve(t);
    if (r === n) return "";
    if ((e = r.toLowerCase()) === (t = n.toLowerCase())) return "";
    let o = 0, a = e.length;
    for (;o < a && 92 === e.charCodeAt(o); ++o) ;
    for (;a - 1 > o && 92 === e.charCodeAt(a - 1); --a) ;
    const i = a - o;
    let s = 0, l = t.length;
    for (;s < l && 92 === t.charCodeAt(s); ++s) ;
    for (;l - 1 > s && 92 === t.charCodeAt(l - 1); --l) ;
    const c = l - s, h = i < c ? i : c;
    let u = -1, d = 0;
    for (;d <= h; ++d) {
      if (d === h) {
        if (c > h) {
          if (92 === t.charCodeAt(s + d)) return n.slice(s + d + 1);
          if (2 === d) return n.slice(s + d);
        }
        i > h && (92 === e.charCodeAt(o + d) ? u = d : 2 === d && (u = 3));
        break;
      }
      const r = e.charCodeAt(o + d);
      if (r !== t.charCodeAt(s + d)) break;
      92 === r && (u = d);
    }
    if (d !== h && -1 === u) return n;
    let f = "";
    for (-1 === u && (u = 0), d = o + u + 1; d <= a; ++d) d !== a && 92 !== e.charCodeAt(d) || (0 === f.length ? f += ".." : f += "\\..");
    return f.length > 0 ? f + n.slice(s + u, l) : (s += u, 92 === n.charCodeAt(s) && ++s, 
    n.slice(s, l));
  },
  toNamespacedPath: function toNamespacedPath(e) {
    if ("string" != typeof e) return e;
    if (0 === e.length) return "";
    const t = resolve(e);
    if (t.length >= 3) if (92 === t.charCodeAt(0)) {
      if (92 === t.charCodeAt(1)) {
        const e = t.charCodeAt(2);
        if (63 !== e && 46 !== e) return "\\\\?\\UNC\\" + t.slice(2);
      }
    } else if (isWindowsDeviceRoot(t.charCodeAt(0)) && 58 === t.charCodeAt(1) && 92 === t.charCodeAt(2)) return "\\\\?\\" + t;
    return e;
  },
  dirname: function dirname(e) {
    assertPath(e);
    const t = e.length;
    if (0 === t) return ".";
    let r = -1, n = -1, o = !0, a = 0;
    const i = e.charCodeAt(0);
    if (t > 1) if (isPathSeparator(i)) {
      if (r = a = 1, isPathSeparator(e.charCodeAt(1))) {
        let n = 2, o = n;
        for (;n < t && !isPathSeparator(e.charCodeAt(n)); ++n) ;
        if (n < t && n !== o) {
          for (o = n; n < t && isPathSeparator(e.charCodeAt(n)); ++n) ;
          if (n < t && n !== o) {
            for (o = n; n < t && !isPathSeparator(e.charCodeAt(n)); ++n) ;
            if (n === t) return e;
            n !== o && (r = a = n + 1);
          }
        }
      }
    } else isWindowsDeviceRoot(i) && 58 === e.charCodeAt(1) && (r = a = 2, t > 2 && isPathSeparator(e.charCodeAt(2)) && (r = a = 3)); else if (isPathSeparator(i)) return e;
    for (let r = t - 1; r >= a; --r) if (isPathSeparator(e.charCodeAt(r))) {
      if (!o) {
        n = r;
        break;
      }
    } else o = !1;
    if (-1 === n) {
      if (-1 === r) return ".";
      n = r;
    }
    return e.slice(0, n);
  },
  basename: function basename(e, t = "") {
    if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string');
    assertPath(e);
    let r, n = 0, o = -1, a = !0;
    if (e.length >= 2 && isWindowsDeviceRoot(e.charCodeAt(0)) && 58 === e.charCodeAt(1) && (n = 2), 
    void 0 !== t && t.length > 0 && t.length <= e.length) {
      if (t.length === e.length && t === e) return "";
      let i = t.length - 1, s = -1;
      for (r = e.length - 1; r >= n; --r) {
        const l = e.charCodeAt(r);
        if (isPathSeparator(l)) {
          if (!a) {
            n = r + 1;
            break;
          }
        } else -1 === s && (a = !1, s = r + 1), i >= 0 && (l === t.charCodeAt(i) ? -1 == --i && (o = r) : (i = -1, 
        o = s));
      }
      return n === o ? o = s : -1 === o && (o = e.length), e.slice(n, o);
    }
    for (r = e.length - 1; r >= n; --r) if (isPathSeparator(e.charCodeAt(r))) {
      if (!a) {
        n = r + 1;
        break;
      }
    } else -1 === o && (a = !1, o = r + 1);
    return -1 === o ? "" : e.slice(n, o);
  },
  extname: function extname(e) {
    assertPath(e);
    let t = 0, r = -1, n = 0, o = -1, a = !0, i = 0;
    e.length >= 2 && 58 === e.charCodeAt(1) && isWindowsDeviceRoot(e.charCodeAt(0)) && (t = n = 2);
    for (let s = e.length - 1; s >= t; --s) {
      const t = e.charCodeAt(s);
      if (isPathSeparator(t)) {
        if (!a) {
          n = s + 1;
          break;
        }
      } else -1 === o && (a = !1, o = s + 1), 46 === t ? -1 === r ? r = s : 1 !== i && (i = 1) : -1 !== r && (i = -1);
    }
    return -1 === r || -1 === o || 0 === i || 1 === i && r === o - 1 && r === n + 1 ? "" : e.slice(r, o);
  },
  format: function format(e) {
    if (null === e || "object" != typeof e) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
    return _format("\\", e);
  },
  parse: function parse(e) {
    assertPath(e);
    const t = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    }, r = e.length;
    if (0 === r) return t;
    let n = 0, o = e.charCodeAt(0);
    if (r > 1) {
      if (isPathSeparator(o)) {
        if (n = 1, isPathSeparator(e.charCodeAt(1))) {
          let t = 2, o = t;
          for (;t < r && !isPathSeparator(e.charCodeAt(t)); ++t) ;
          if (t < r && t !== o) {
            for (o = t; t < r && isPathSeparator(e.charCodeAt(t)); ++t) ;
            if (t < r && t !== o) {
              for (o = t; t < r && !isPathSeparator(e.charCodeAt(t)); ++t) ;
              t === r ? n = t : t !== o && (n = t + 1);
            }
          }
        }
      } else if (isWindowsDeviceRoot(o) && 58 === e.charCodeAt(1)) {
        if (n = 2, !(r > 2)) return t.root = t.dir = e, t;
        if (isPathSeparator(e.charCodeAt(2))) {
          if (3 === r) return t.root = t.dir = e, t;
          n = 3;
        }
      }
    } else if (isPathSeparator(o)) return t.root = t.dir = e, t;
    n > 0 && (t.root = e.slice(0, n));
    let a = -1, i = n, s = -1, l = !0, c = e.length - 1, h = 0;
    for (;c >= n; --c) if (o = e.charCodeAt(c), isPathSeparator(o)) {
      if (!l) {
        i = c + 1;
        break;
      }
    } else -1 === s && (l = !1, s = c + 1), 46 === o ? -1 === a ? a = c : 1 !== h && (h = 1) : -1 !== a && (h = -1);
    return -1 === a || -1 === s || 0 === h || 1 === h && a === s - 1 && a === i + 1 ? -1 !== s && (t.base = t.name = e.slice(i, s)) : (t.name = e.slice(i, a), 
    t.base = e.slice(i, s), t.ext = e.slice(a, s)), t.dir = i > 0 && i !== n ? e.slice(0, i - 1) : t.root, 
    t;
  },
  fromFileUrl: function fromFileUrl(e) {
    return new URL(String(e)).pathname.replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/").replace(/\//g, "\\");
  }
}, _posix = {
  __proto__: null,
  sep: "/",
  delimiter: ":",
  resolve: resolve$1,
  normalize: normalize$1,
  isAbsolute: function isAbsolute$1(e) {
    return assertPath(e), e.length > 0 && 47 === e.charCodeAt(0);
  },
  join: function join$1(...e) {
    if (0 === e.length) return ".";
    let t;
    for (let r = 0, n = e.length; r < n; ++r) {
      const n = e[r];
      assertPath(n), n.length > 0 && (t ? t += "/" + n : t = n);
    }
    return t ? normalize$1(t) : ".";
  },
  relative: function relative$1(e, t) {
    if (assertPath(e), assertPath(t), e === t) return "";
    if ((e = resolve$1(e)) === (t = resolve$1(t))) return "";
    let r = 1;
    const n = e.length;
    for (;r < n && 47 === e.charCodeAt(r); ++r) ;
    const o = n - r;
    let a = 1;
    const i = t.length;
    for (;a < i && 47 === t.charCodeAt(a); ++a) ;
    const s = i - a, l = o < s ? o : s;
    let c = -1, h = 0;
    for (;h <= l; ++h) {
      if (h === l) {
        if (s > l) {
          if (47 === t.charCodeAt(a + h)) return t.slice(a + h + 1);
          if (0 === h) return t.slice(a + h);
        } else o > l && (47 === e.charCodeAt(r + h) ? c = h : 0 === h && (c = 0));
        break;
      }
      const n = e.charCodeAt(r + h);
      if (n !== t.charCodeAt(a + h)) break;
      47 === n && (c = h);
    }
    let u = "";
    for (h = r + c + 1; h <= n; ++h) h !== n && 47 !== e.charCodeAt(h) || (0 === u.length ? u += ".." : u += "/..");
    return u.length > 0 ? u + t.slice(a + c) : (a += c, 47 === t.charCodeAt(a) && ++a, 
    t.slice(a));
  },
  toNamespacedPath: function toNamespacedPath$1(e) {
    return e;
  },
  dirname: function dirname$1(e) {
    if (assertPath(e), 0 === e.length) return ".";
    const t = 47 === e.charCodeAt(0);
    let r = -1, n = !0;
    for (let t = e.length - 1; t >= 1; --t) if (47 === e.charCodeAt(t)) {
      if (!n) {
        r = t;
        break;
      }
    } else n = !1;
    return -1 === r ? t ? "/" : "." : t && 1 === r ? "//" : e.slice(0, r);
  },
  basename: function basename$1(e, t = "") {
    if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string');
    assertPath(e);
    let r, n = 0, o = -1, a = !0;
    if (void 0 !== t && t.length > 0 && t.length <= e.length) {
      if (t.length === e.length && t === e) return "";
      let i = t.length - 1, s = -1;
      for (r = e.length - 1; r >= 0; --r) {
        const l = e.charCodeAt(r);
        if (47 === l) {
          if (!a) {
            n = r + 1;
            break;
          }
        } else -1 === s && (a = !1, s = r + 1), i >= 0 && (l === t.charCodeAt(i) ? -1 == --i && (o = r) : (i = -1, 
        o = s));
      }
      return n === o ? o = s : -1 === o && (o = e.length), e.slice(n, o);
    }
    for (r = e.length - 1; r >= 0; --r) if (47 === e.charCodeAt(r)) {
      if (!a) {
        n = r + 1;
        break;
      }
    } else -1 === o && (a = !1, o = r + 1);
    return -1 === o ? "" : e.slice(n, o);
  },
  extname: function extname$1(e) {
    assertPath(e);
    let t = -1, r = 0, n = -1, o = !0, a = 0;
    for (let i = e.length - 1; i >= 0; --i) {
      const s = e.charCodeAt(i);
      if (47 !== s) -1 === n && (o = !1, n = i + 1), 46 === s ? -1 === t ? t = i : 1 !== a && (a = 1) : -1 !== t && (a = -1); else if (!o) {
        r = i + 1;
        break;
      }
    }
    return -1 === t || -1 === n || 0 === a || 1 === a && t === n - 1 && t === r + 1 ? "" : e.slice(t, n);
  },
  format: function format$1(e) {
    if (null === e || "object" != typeof e) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
    return _format("/", e);
  },
  parse: function parse$1(e) {
    assertPath(e);
    const t = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (0 === e.length) return t;
    const r = 47 === e.charCodeAt(0);
    let n;
    r ? (t.root = "/", n = 1) : n = 0;
    let o = -1, a = 0, i = -1, s = !0, l = e.length - 1, c = 0;
    for (;l >= n; --l) {
      const t = e.charCodeAt(l);
      if (47 !== t) -1 === i && (s = !1, i = l + 1), 46 === t ? -1 === o ? o = l : 1 !== c && (c = 1) : -1 !== o && (c = -1); else if (!s) {
        a = l + 1;
        break;
      }
    }
    return -1 === o || -1 === i || 0 === c || 1 === c && o === i - 1 && o === a + 1 ? -1 !== i && (t.base = t.name = 0 === a && r ? e.slice(1, i) : e.slice(a, i)) : (0 === a && r ? (t.name = e.slice(1, o), 
    t.base = e.slice(1, i)) : (t.name = e.slice(a, o), t.base = e.slice(a, i)), t.ext = e.slice(o, i)), 
    a > 0 ? t.dir = e.slice(0, a - 1) : r && (t.dir = "/"), t;
  },
  fromFileUrl: function fromFileUrl$1(e) {
    return new URL(String(e)).pathname;
  }
}, SEP = isWindows ? "\\" : "/", SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/, SEP$1 = isWindows ? "(?:\\\\|\\/)" : "\\/", SEP_ESC = isWindows ? "\\\\" : "/", SEP_RAW = isWindows ? "\\" : "/", GLOBSTAR = `(?:(?:[^${SEP_ESC}/]*(?:${SEP_ESC}|/|$))*)`, WILDCARD = `(?:[^${SEP_ESC}/]*)`, GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}/]*(?:${SEP_ESC}|/|$))*)`, WILDCARD_SEGMENT = `(?:[^${SEP_ESC}/]*)`, path = isWindows ? _win32 : _posix, win32 = _win32, posix = _posix, {basename: basename$2, delimiter: delimiter$2, dirname: dirname$2, extname: extname$2, format: format$2, fromFileUrl: fromFileUrl$2, isAbsolute: isAbsolute$2, join: join$2, normalize: normalize$2, parse: parse$2, relative: relative$2, resolve: resolve$2, sep: sep$2, toNamespacedPath: toNamespacedPath$2} = path;

let enabled = !(null === (_b = null === (_a = globalThis.Deno) || void 0 === _a ? void 0 : _a.noColor) || void 0 === _b || _b);

const isWindows$1 = "windows" == Deno.build.os, createDenoLogger = e => {
  let t = !0;
  const r = e.Deno;
  return createTerminalLogger({
    color: (e, n) => {
      if (t && !r.noColor) switch (n) {
       case "bgRed":
        return function o(e) {
          return run(e, code([ 41 ], 49));
        }(e);

       case "blue":
        return function a(e) {
          return run(e, code([ 34 ], 39));
        }(e);

       case "bold":
        return function i(e) {
          return run(e, code([ 1 ], 22));
        }(e);

       case "cyan":
        return function s(e) {
          return run(e, code([ 36 ], 39));
        }(e);

       case "dim":
        return function l(e) {
          return run(e, code([ 2 ], 22));
        }(e);

       case "gray":
        return function c(e) {
          return run(e, code([ 90 ], 39));
        }(e);

       case "green":
        return function h(e) {
          return run(e, code([ 32 ], 39));
        }(e);

       case "magenta":
        return function u(e) {
          return run(e, code([ 35 ], 39));
        }(e);

       case "red":
        return function d(e) {
          return run(e, code([ 31 ], 39));
        }(e);

       case "yellow":
        return function f(e) {
          return run(e, code([ 33 ], 39));
        }(e);
      }
      return e;
    },
    cwd: () => r.cwd(),
    emoji: e => "windows" !== r.build.os ? e : "",
    enableColors: e => t = e,
    getColumns: () => {
      const e = r.stdout && r.stdout.columns || 80;
      return Math.max(Math.min(120, e), 60);
    },
    memoryUsage: () => -1,
    relativePath: (e, t) => t,
    writeLogs: (e, t, n) => {
      const o = (new TextEncoder).encode(t);
      r.writeFileSync(e, o, {
        append: n
      });
    }
  });
}, isString = e => "string" == typeof e, buildError = e => {
  const t = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    relFilePath: null,
    absFilePath: null,
    lines: []
  };
  return e && e.push(t), t;
}, catchError = (e, t, r) => {
  const n = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    relFilePath: null,
    absFilePath: null,
    lines: []
  };
  return isString(r) ? n.messageText = r : null != t && (null != t.stack ? n.messageText = t.stack.toString() : null != t.message ? n.messageText = t.message.toString() : n.messageText = t.toString()), 
  null == e || shouldIgnoreError(n.messageText) || e.push(n), n;
}, shouldIgnoreError = e => e === TASK_CANCELED_MSG, TASK_CANCELED_MSG = "task canceled", normalizePath = e => {
  if ("string" != typeof e) throw new Error("invalid path to normalize");
  e = normalizeSlashes(e.trim());
  const t = pathComponents(e, getRootLength(e)), r = reducePathComponents(t), n = r[0], o = r[1], a = n + r.slice(1).join("/");
  return "" === a ? "." : "" === n && o && e.includes("/") && !o.startsWith(".") && !o.startsWith("@") ? "./" + a : a;
}, normalizeSlashes = e => e.replace(backslashRegExp, "/"), backslashRegExp = /\\/g, reducePathComponents = e => {
  if (!Array.isArray(e) || 0 === e.length) return [];
  const t = [ e[0] ];
  for (let r = 1; r < e.length; r++) {
    const n = e[r];
    if (n && "." !== n) {
      if (".." === n) if (t.length > 1) {
        if (".." !== t[t.length - 1]) {
          t.pop();
          continue;
        }
      } else if (t[0]) continue;
      t.push(n);
    }
  }
  return t;
}, getRootLength = e => {
  const t = getEncodedRootLength(e);
  return t < 0 ? ~t : t;
}, getEncodedRootLength = e => {
  if (!e) return 0;
  const t = e.charCodeAt(0);
  if (47 === t || 92 === t) {
    if (e.charCodeAt(1) !== t) return 1;
    const r = e.indexOf(47 === t ? "/" : "\\", 2);
    return r < 0 ? e.length : r + 1;
  }
  if (isVolumeCharacter(t) && 58 === e.charCodeAt(1)) {
    const t = e.charCodeAt(2);
    if (47 === t || 92 === t) return 3;
    if (2 === e.length) return 2;
  }
  const r = e.indexOf("://");
  if (-1 !== r) {
    const t = r + "://".length, n = e.indexOf("/", t);
    if (-1 !== n) {
      const o = e.slice(0, r), a = e.slice(t, n);
      if ("file" === o && ("" === a || "localhost" === a) && isVolumeCharacter(e.charCodeAt(n + 1))) {
        const t = getFileUrlVolumeSeparatorEnd(e, n + 2);
        if (-1 !== t) {
          if (47 === e.charCodeAt(t)) return ~(t + 1);
          if (t === e.length) return ~t;
        }
      }
      return ~(n + 1);
    }
    return ~e.length;
  }
  return 0;
}, isVolumeCharacter = e => e >= 97 && e <= 122 || e >= 65 && e <= 90, getFileUrlVolumeSeparatorEnd = (e, t) => {
  const r = e.charCodeAt(t);
  if (58 === r) return t + 1;
  if (37 === r && 51 === e.charCodeAt(t + 1)) {
    const r = e.charCodeAt(t + 2);
    if (97 === r || 65 === r) return t + 3;
  }
  return -1;
}, pathComponents = (e, t) => {
  const r = e.substring(0, t), n = e.substring(t).split("/"), o = n.length;
  return o > 0 && !n[o - 1] && n.pop(), [ r, ...n ];
}, isRemoteUrl = e => !!isString(e) && ((e = e.toLowerCase()).startsWith("https://") || e.startsWith("http://")), isFileUrl = e => !!isString(e) && e.toLowerCase().startsWith("file:/");

__asyncValues = function(e) {
  function t(t) {
    r[t] = e[t] && function(r) {
      return new Promise((function(n, o) {
        !function a(e, t, r, n) {
          Promise.resolve(n).then((function(t) {
            e({
              value: t,
              done: r
            });
          }), t);
        }(n, o, (r = e[t](r)).done, r.value);
      }));
    };
  }
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r, n = e[Symbol.asyncIterator];
  return n ? n.call(e) : (e = "function" == typeof __values ? __values(e) : e[Symbol.iterator](), 
  r = {}, t("next"), t("throw"), t("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
};

const ROOT_DIR = normalizePath(resolve$2("/")), IGNORE = [ ".ds_store", ".gitignore", "desktop.ini", "thumbs.db" ];

__asyncValues$1 = function(e) {
  function t(t) {
    r[t] = e[t] && function(r) {
      return new Promise((function(n, o) {
        !function a(e, t, r, n) {
          Promise.resolve(n).then((function(t) {
            e({
              value: t,
              done: r
            });
          }), t);
        }(n, o, (r = e[t](r)).done, r.value);
      }));
    };
  }
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r, n = e[Symbol.asyncIterator];
  return n ? n.call(e) : (e = "function" == typeof __values ? __values(e) : e[Symbol.iterator](), 
  r = {}, t("next"), t("throw"), t("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
};

export { createDenoLogger, createDenoSys };