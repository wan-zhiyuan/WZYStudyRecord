function createWindowFromHtml(e, t) {
  let r = templateWindows.get(t);
  return null == r && (r = new MockWindow(e), templateWindows.set(t, r)), cloneWindow(r);
}

function normalizeHydrateOptions(e) {
  const t = Object.assign({
    serializeToHtml: !1,
    destroyWindow: !1,
    destroyDocument: !1
  }, e || {});
  return "boolean" != typeof t.clientHydrateAnnotations && (t.clientHydrateAnnotations = !0), 
  "boolean" != typeof t.constrainTimeouts && (t.constrainTimeouts = !0), "number" != typeof t.maxHydrateCount && (t.maxHydrateCount = 300), 
  "boolean" != typeof t.runtimeLogging && (t.runtimeLogging = !1), "number" != typeof t.timeout && (t.timeout = 15e3), 
  Array.isArray(t.excludeComponents) ? t.excludeComponents = t.excludeComponents.filter(filterValidTags).map(mapValidTags) : t.excludeComponents = [], 
  Array.isArray(t.staticComponents) ? t.staticComponents = t.staticComponents.filter(filterValidTags).map(mapValidTags) : t.staticComponents = [], 
  t;
}

function filterValidTags(e) {
  return "string" == typeof e && e.includes("-");
}

function mapValidTags(e) {
  return e.trim().toLowerCase();
}

function generateHydrateResults(e) {
  "string" != typeof e.url && (e.url = "https://hydrate.stenciljs.com/");
  const t = {
    diagnostics: [],
    url: e.url,
    host: null,
    hostname: null,
    href: null,
    pathname: null,
    port: null,
    search: null,
    hash: null,
    html: null,
    httpStatus: null,
    hydratedCount: 0,
    anchors: [],
    components: [],
    imgs: [],
    scripts: [],
    styles: [],
    title: null
  };
  try {
    const r = new URL(e.url, "https://hydrate.stenciljs.com/");
    t.url = r.href, t.host = r.host, t.hostname = r.hostname, t.href = r.href, t.port = r.port, 
    t.pathname = r.pathname, t.search = r.search, t.hash = r.hash;
  } catch (e) {
    renderCatchError(t, e);
  }
  return t;
}

function renderBuildDiagnostic(e, t, r, s) {
  const n = {
    level: t,
    type: "build",
    header: r,
    messageText: s,
    relFilePath: null,
    absFilePath: null,
    lines: []
  };
  return e.pathname ? "/" !== e.pathname && (n.header += ": " + e.pathname) : e.url && (n.header += ": " + e.url), 
  e.diagnostics.push(n), n;
}

function renderBuildError(e, t) {
  return renderBuildDiagnostic(e, "error", "Hydrate Error", t);
}

function renderCatchError(e, t) {
  const r = renderBuildError(e, null);
  return null != t && (null != t.stack ? r.messageText = t.stack.toString() : null != t.message ? r.messageText = t.message.toString() : r.messageText = t.toString()), 
  r;
}

function runtimeLog(e, t, r) {
  global.console[t].apply(global.console, [ `[ ${e}  ${t} ] `, ...r ]);
}

function collectAttributes(e) {
  const t = {}, r = e.attributes;
  for (let e = 0, s = r.length; e < s; e++) {
    const s = r.item(e), n = s.nodeName.toLowerCase();
    if (SKIP_ATTRS.has(n)) continue;
    const o = s.nodeValue;
    "class" === n && "" === o || (t[n] = o);
  }
  return t;
}

function patchDomImplementation(e, t) {
  let r;
  if (null != e.defaultView ? (t.destroyWindow = !0, patchWindow(e.defaultView), r = e.defaultView) : (t.destroyWindow = !0, 
  t.destroyDocument = !1, r = new MockWindow(!1)), r.document !== e && (r.document = e), 
  e.defaultView !== r && (e.defaultView = r), "function" != typeof e.documentElement.constructor.prototype.getRootNode && (e.createElement("unknown-element").constructor.prototype.getRootNode = getRootNode), 
  "function" == typeof e.createEvent) {
    const t = e.createEvent("CustomEvent").constructor;
    r.CustomEvent !== t && (r.CustomEvent = t);
  }
  try {
    e.baseURI;
  } catch (t) {
    Object.defineProperty(e, "baseURI", {
      get() {
        const t = e.querySelector("base[href]");
        return t ? new URL(t.getAttribute("href"), r.location.href).href : r.location.href;
      }
    });
  }
  return r;
}

function getRootNode(e) {
  const t = null != e && !0 === e.composed;
  let r = this;
  for (;null != r.parentNode; ) r = r.parentNode, !0 === t && null == r.parentNode && null != r.host && (r = r.host);
  return r;
}

function renderToString(e, t) {
  const r = normalizeHydrateOptions(t);
  return r.serializeToHtml = !0, new Promise(t => {
    const s = generateHydrateResults(r);
    if (hasError(s.diagnostics)) t(s); else if ("string" == typeof e) try {
      r.destroyWindow = !0, r.destroyDocument = !0, render(new MockWindow(e), r, s, t);
    } catch (e) {
      renderCatchError(s, e), t(s);
    } else if (isValidDocument(e)) try {
      r.destroyDocument = !1, render(patchDomImplementation(e, r), r, s, t);
    } catch (e) {
      renderCatchError(s, e), t(s);
    } else renderBuildError(s, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
    t(s);
  });
}

function hydrateDocument(e, t) {
  const r = normalizeHydrateOptions(t);
  return r.serializeToHtml = !1, new Promise(t => {
    const s = generateHydrateResults(r);
    if (hasError(s.diagnostics)) t(s); else if ("string" == typeof e) try {
      r.destroyWindow = !0, r.destroyDocument = !0, render(new MockWindow(e), r, s, t);
    } catch (e) {
      renderCatchError(s, e), t(s);
    } else if (isValidDocument(e)) try {
      r.destroyDocument = !1, render(patchDomImplementation(e, r), r, s, t);
    } catch (e) {
      renderCatchError(s, e), t(s);
    } else renderBuildError(s, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
    t(s);
  });
}

function render(e, t, r, s) {
  if (process.__stencilErrors || (process.__stencilErrors = !0, process.on("unhandledRejection", e => {
    console.log("unhandledRejection", e);
  })), function n(e, t, r) {
    try {
      e.location.href = t.url;
    } catch (e) {
      renderCatchError(r, e);
    }
    if ("string" == typeof t.userAgent) try {
      e.navigator.userAgent = t.userAgent;
    } catch (e) {}
    if ("string" == typeof t.cookie) try {
      e.document.cookie = t.cookie;
    } catch (e) {}
    if ("string" == typeof t.referrer) try {
      e.document.referrer = t.referrer;
    } catch (e) {}
    if ("string" == typeof t.direction) try {
      e.document.documentElement.setAttribute("dir", t.direction);
    } catch (e) {}
    if ("string" == typeof t.language) try {
      e.document.documentElement.setAttribute("lang", t.language);
    } catch (e) {}
    try {
      e.customElements = null;
    } catch (e) {}
    return t.constrainTimeouts && constrainTimeouts(e), function s(e, t, r) {
      try {
        const s = e.location.pathname;
        e.console.error = (...e) => {
          renderCatchError(r, [ ...e ].join(", ")), t.runtimeLogging && runtimeLog(s, "error", e);
        }, e.console.debug = (...e) => {
          renderBuildDiagnostic(r, "debug", "Hydrate Debug", [ ...e ].join(", ")), t.runtimeLogging && runtimeLog(s, "debug", e);
        }, t.runtimeLogging && [ "log", "warn", "assert", "info", "trace" ].forEach(t => {
          e.console[t] = (...e) => {
            runtimeLog(s, t, e);
          };
        });
      } catch (e) {
        renderCatchError(r, e);
      }
    }(e, t, r), e;
  }(e, t, r), "function" == typeof t.beforeHydrate) try {
    const n = t.beforeHydrate(e.document);
    isPromise(n) ? n.then(() => {
      hydrateFactory(e, t, r, afterHydrate, s);
    }) : hydrateFactory(e, t, r, afterHydrate, s);
  } catch (n) {
    renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
  } else hydrateFactory(e, t, r, afterHydrate, s);
}

function afterHydrate(e, t, r, s) {
  if ("function" == typeof t.afterHydrate) try {
    const n = t.afterHydrate(e.document);
    isPromise(n) ? n.then(() => {
      finalizeHydrate(e, e.document, t, r, s);
    }) : finalizeHydrate(e, e.document, t, r, s);
  } catch (n) {
    renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
  } else finalizeHydrate(e, e.document, t, r, s);
}

function finalizeHydrate(e, t, r, s, n) {
  try {
    if (function e(t, r, s) {
      const n = r.children;
      for (let r = 0, o = n.length; r < o; r++) {
        const o = n[r], i = o.nodeName.toLowerCase();
        if (i.includes("-")) {
          const e = t.components.find(e => e.tag === i);
          null != e && (e.count++, s > e.depth && (e.depth = s));
        } else switch (i) {
         case "a":
          const e = collectAttributes(o);
          e.href = o.href, "string" == typeof e.href && (t.anchors.some(t => t.href === e.href) || t.anchors.push(e));
          break;

         case "img":
          const r = collectAttributes(o);
          r.src = o.src, "string" == typeof r.src && (t.imgs.some(e => e.src === r.src) || t.imgs.push(r));
          break;

         case "link":
          const s = collectAttributes(o);
          s.href = o.href, "string" == typeof s.rel && "stylesheet" === s.rel.toLowerCase() && "string" == typeof s.href && (t.styles.some(e => e.link === s.href) || (delete s.rel, 
          delete s.type, t.styles.push(s)));
          break;

         case "script":
          const n = collectAttributes(o);
          n.src = o.src, "string" == typeof n.src && (t.scripts.some(e => e.src === n.src) || t.scripts.push(n));
        }
        e(t, o, ++s);
      }
    }(s, t.documentElement, 0), !1 !== r.removeUnusedStyles) try {
      ((e, t) => {
        try {
          const r = e.head.querySelectorAll("style[data-styles]"), s = r.length;
          if (s > 0) {
            const n = (e => {
              const t = {
                attrs: new Set,
                classNames: new Set,
                ids: new Set,
                tags: new Set
              };
              return collectUsedSelectors(t, e), t;
            })(e.documentElement);
            for (let e = 0; e < s; e++) removeUnusedStyleText(n, t, r[e]);
          }
        } catch (e) {
          ((e, t, r) => {
            const s = {
              level: "error",
              type: "build",
              header: "Build Error",
              messageText: "build error",
              relFilePath: null,
              absFilePath: null,
              lines: []
            };
            null != t && (null != t.stack ? s.messageText = t.stack.toString() : null != t.message ? s.messageText = t.message.toString() : s.messageText = t.toString()), 
            null == e || shouldIgnoreError(s.messageText) || e.push(s);
          })(t, e);
        }
      })(t, s.diagnostics);
    } catch (e) {
      renderCatchError(s, e);
    }
    if ("string" == typeof r.title) try {
      t.title = r.title;
    } catch (e) {
      renderCatchError(s, e);
    }
    s.title = t.title, r.removeScripts && function e(t) {
      const r = t.children;
      for (let t = r.length - 1; t >= 0; t--) {
        const s = r[t];
        e(s), ("SCRIPT" === s.nodeName || "LINK" === s.nodeName && "modulepreload" === s.getAttribute("rel")) && s.remove();
      }
    }(t.documentElement);
    try {
      ((e, t) => {
        let r = e.head.querySelector('link[rel="canonical"]');
        "string" == typeof t ? (null == r && (r = e.createElement("link"), r.setAttribute("rel", "canonical"), 
        e.head.appendChild(r)), r.setAttribute("href", t)) : null != r && (r.getAttribute("href") || r.parentNode.removeChild(r));
      })(t, r.canonicalUrl);
    } catch (e) {
      renderCatchError(s, e);
    }
    try {
      (e => {
        const t = e.head;
        let r = t.querySelector("meta[charset]");
        null == r ? (r = e.createElement("meta"), r.setAttribute("charset", "utf-8")) : r.remove(), 
        t.insertBefore(r, t.firstChild);
      })(t);
    } catch (e) {}
    hasError(s.diagnostics) || (s.httpStatus = 200);
    try {
      const e = t.head.querySelector('meta[http-equiv="status"]');
      if (null != e) {
        const t = e.getAttribute("content");
        t && t.length > 0 && (s.httpStatus = parseInt(t, 10));
      }
    } catch (e) {}
    r.clientHydrateAnnotations && t.documentElement.classList.add("hydrated"), r.serializeToHtml && (s.html = serializeDocumentToString(t, r));
  } catch (e) {
    renderCatchError(s, e);
  }
  if (r.destroyWindow) try {
    r.destroyDocument || (e.document = null, t.defaultView = null), e.close();
  } catch (e) {
    renderCatchError(s, e);
  }
  n(s);
}

function serializeDocumentToString(e, t) {
  return serializeNodeToHtml(e, {
    approximateLineWidth: t.approximateLineWidth,
    outerHtml: !1,
    prettyHtml: t.prettyHtml,
    removeAttributeQuotes: t.removeAttributeQuotes,
    removeBooleanAttributeQuotes: t.removeBooleanAttributeQuotes,
    removeEmptyAttributes: t.removeEmptyAttributes,
    removeHtmlComments: t.removeHtmlComments,
    serializeShadowRoot: !1
  });
}

function isValidDocument(e) {
  return null != e && 9 === e.nodeType && null != e.documentElement && 1 === e.documentElement.nodeType && null != e.body && 1 === e.body.nodeType;
}

import { MockWindow, cloneWindow, constrainTimeouts, patchWindow, serializeNodeToHtml } from "@stencil/core/mock-doc";

import { hydrateFactory } from "@stencil/core/hydrate-factory";

const templateWindows = new Map, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, IS_DENO_ENV = "undefined" != typeof Deno, IS_NODE_ENV = !(IS_DENO_ENV || "undefined" == typeof global || "function" != typeof require || !global.process || "string" != typeof __filename || global.origin && "string" == typeof global.origin), hasError = (IS_DENO_ENV && Deno.build.os, 
IS_NODE_ENV && global.process.platform, IS_NODE_ENV ? process.cwd : IS_DENO_ENV && Deno.cwd, 
IS_NODE_ENV ? process.exit : IS_DENO_ENV && Deno.exit, e => null != e && 0 !== e.length && e.some(e => "error" === e.level && "runtime" !== e.type)), shouldIgnoreError = e => e === TASK_CANCELED_MSG, TASK_CANCELED_MSG = "task canceled", SKIP_ATTRS = new Set([ "s-id", "c-id" ]), collectUsedSelectors = (e, t) => {
  if (null != t && 1 === t.nodeType) {
    const r = t.children, s = t.nodeName.toLowerCase();
    e.tags.add(s);
    const n = t.attributes;
    for (let r = 0, s = n.length; r < s; r++) {
      const s = n.item(r), o = s.name.toLowerCase();
      if (e.attrs.add(o), "class" === o) {
        const r = t.classList;
        for (let t = 0, s = r.length; t < s; t++) e.classNames.add(r.item(t));
      } else "id" === o && e.ids.add(s.value);
    }
    if (r) for (let t = 0, s = r.length; t < s; t++) collectUsedSelectors(e, r[t]);
  }
}, parseCss = (e, t) => {
  let r = 1, s = 1;
  const n = [], o = e => {
    const t = e.match(/\n/g);
    t && (r += t.length);
    const n = e.lastIndexOf("\n");
    s = ~n ? e.length - n : s + e.length;
  }, i = () => {
    const e = {
      line: r,
      column: s
    };
    return t => (t.position = new N(e), m(), t);
  }, a = o => {
    const i = e.split("\n"), a = {
      level: "error",
      type: "css",
      language: "css",
      header: "CSS Parse",
      messageText: o,
      absFilePath: t,
      lines: [ {
        lineIndex: r - 1,
        lineNumber: r,
        errorCharStart: s,
        text: e[r - 1]
      } ]
    };
    if (r > 1) {
      const t = {
        lineIndex: r - 1,
        lineNumber: r - 1,
        text: e[r - 2],
        errorCharStart: -1,
        errorLength: -1
      };
      a.lines.unshift(t);
    }
    if (r + 2 < i.length) {
      const e = {
        lineIndex: r,
        lineNumber: r + 1,
        text: i[r],
        errorCharStart: -1,
        errorLength: -1
      };
      a.lines.push(e);
    }
    return n.push(a), null;
  }, l = () => u(/^{\s*/), c = () => u(/^}/), u = t => {
    const r = t.exec(e);
    if (!r) return;
    const s = r[0];
    return o(s), e = e.slice(s.length), r;
  }, d = () => {
    let t;
    const r = [];
    for (m(), h(r); e.length && "}" !== e.charAt(0) && (t = w() || z()); ) !1 !== t && (r.push(t), 
    h(r));
    return r;
  }, m = () => u(/^\s*/), h = e => {
    let t;
    for (e = e || []; t = f(); ) !1 !== t && e.push(t);
    return e;
  }, f = () => {
    const t = i();
    if ("/" !== e.charAt(0) || "*" !== e.charAt(1)) return null;
    let r = 2;
    for (;"" !== e.charAt(r) && ("*" !== e.charAt(r) || "/" !== e.charAt(r + 1)); ) ++r;
    if (r += 2, "" === e.charAt(r - 1)) return a("End of comment missing");
    const n = e.slice(2, r - 2);
    return s += 2, o(n), e = e.slice(r), s += 2, t({
      type: "comment",
      comment: n
    });
  }, p = () => {
    const e = u(/^([^{]+)/);
    return e ? trim(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, (function(e) {
      return e.replace(/,/g, "‌");
    })).split(/\s*(?![^(]*\)),\s*/).map((function(e) {
      return e.replace(/\u200C/g, ",");
    })) : null;
  }, g = () => {
    const e = i();
    let t = u(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!t) return null;
    if (t = trim(t[0]), !u(/^:\s*/)) return a("property missing ':'");
    const r = u(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/), s = e({
      type: "declaration",
      property: t.replace(commentre, ""),
      value: r ? trim(r[0]).replace(commentre, "") : ""
    });
    return u(/^[;\s]*/), s;
  }, y = () => {
    const e = [];
    if (!l()) return a("missing '{'");
    let t;
    for (h(e); t = g(); ) !1 !== t && (e.push(t), h(e));
    return c() ? e : a("missing '}'");
  }, C = () => {
    let e;
    const t = [], r = i();
    for (;e = u(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); ) t.push(e[1]), u(/^,\s*/);
    return t.length ? r({
      type: "keyframe",
      values: t,
      declarations: y()
    }) : null;
  }, S = e => {
    const t = new RegExp("^@" + e + "\\s*([^;]+);");
    return () => {
      const r = i(), s = u(t);
      if (!s) return null;
      const n = {
        type: e
      };
      return n[e] = s[1].trim(), r(n);
    };
  }, E = S("import"), b = S("charset"), T = S("namespace"), w = () => "@" !== e[0] ? null : (() => {
    const e = i();
    let t = u(/^@([-\w]+)?keyframes\s*/);
    if (!t) return null;
    const r = t[1];
    if (t = u(/^([-\w]+)\s*/), !t) return a("@keyframes missing name");
    const s = t[1];
    if (!l()) return a("@keyframes missing '{'");
    let n, o = h();
    for (;n = C(); ) o.push(n), o = o.concat(h());
    return c() ? e({
      type: "keyframes",
      name: s,
      vendor: r,
      keyframes: o
    }) : a("@keyframes missing '}'");
  })() || (() => {
    const e = i(), t = u(/^@media *([^{]+)/);
    if (!t) return null;
    const r = trim(t[1]);
    if (!l()) return a("@media missing '{'");
    const s = h().concat(d());
    return c() ? e({
      type: "media",
      media: r,
      rules: s
    }) : a("@media missing '}'");
  })() || (() => {
    const e = i(), t = u(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    return t ? e({
      type: "custom-media",
      name: trim(t[1]),
      media: trim(t[2])
    }) : null;
  })() || (() => {
    const e = i(), t = u(/^@supports *([^{]+)/);
    if (!t) return null;
    const r = trim(t[1]);
    if (!l()) return a("@supports missing '{'");
    const s = h().concat(d());
    return c() ? e({
      type: "supports",
      supports: r,
      rules: s
    }) : a("@supports missing '}'");
  })() || E() || b() || T() || (() => {
    const e = i(), t = u(/^@([-\w]+)?document *([^{]+)/);
    if (!t) return null;
    const r = trim(t[1]), s = trim(t[2]);
    if (!l()) return a("@document missing '{'");
    const n = h().concat(d());
    return c() ? e({
      type: "document",
      document: s,
      vendor: r,
      rules: n
    }) : a("@document missing '}'");
  })() || (() => {
    const e = i();
    if (!u(/^@page */)) return null;
    const t = p() || [];
    if (!l()) return a("@page missing '{'");
    let r, s = h();
    for (;r = g(); ) s.push(r), s = s.concat(h());
    return c() ? e({
      type: "page",
      selectors: t,
      declarations: s
    }) : a("@page missing '}'");
  })() || (() => {
    const e = i();
    if (!u(/^@host\s*/)) return null;
    if (!l()) return a("@host missing '{'");
    const t = h().concat(d());
    return c() ? e({
      type: "host",
      rules: t
    }) : a("@host missing '}'");
  })() || (() => {
    const e = i();
    if (!u(/^@font-face\s*/)) return null;
    if (!l()) return a("@font-face missing '{'");
    let t, r = h();
    for (;t = g(); ) r.push(t), r = r.concat(h());
    return c() ? e({
      type: "font-face",
      declarations: r
    }) : a("@font-face missing '}'");
  })(), z = () => {
    const e = i(), t = p();
    return t ? (h(), e({
      type: "rule",
      selectors: t,
      declarations: y()
    })) : a("selector missing");
  };
  class N {
    constructor(e) {
      this.start = e, this.end = {
        line: r,
        column: s
      }, this.source = t;
    }
  }
  return N.prototype.content = e, Object.assign({
    diagnostics: n
  }, addParent((() => {
    const e = d();
    return {
      type: "stylesheet",
      stylesheet: {
        source: t,
        rules: e
      }
    };
  })()));
}, trim = e => e ? e.trim() : "", addParent = (e, t) => {
  const r = e && "string" == typeof e.type, s = r ? e : t;
  for (const t in e) {
    const r = e[t];
    Array.isArray(r) ? r.forEach((function(e) {
      addParent(e, s);
    })) : r && "object" == typeof r && addParent(r, s);
  }
  return r && Object.defineProperty(e, "parent", {
    configurable: !0,
    writable: !0,
    enumerable: !1,
    value: t || null
  }), e;
}, commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, getCssSelectors = e => {
  SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
  const t = (e = e.replace(/\./g, " .").replace(/\#/g, " #").replace(/\[/g, " [").replace(/\>/g, " > ").replace(/\+/g, " + ").replace(/\~/g, " ~ ").replace(/\*/g, " * ").replace(/\:not\((.*?)\)/g, " ")).split(" ");
  for (let e = 0, r = t.length; e < r; e++) t[e] = t[e].split(":")[0], 0 !== t[e].length && ("." === t[e].charAt(0) ? SELECTORS.classNames.push(t[e].substr(1)) : "#" === t[e].charAt(0) ? SELECTORS.ids.push(t[e].substr(1)) : "[" === t[e].charAt(0) ? (t[e] = t[e].substr(1).split("=")[0].split("]")[0].trim(), 
  SELECTORS.attrs.push(t[e].toLowerCase())) : /[a-z]/g.test(t[e].charAt(0)) && SELECTORS.tags.push(t[e].toLowerCase()));
  return SELECTORS.classNames = SELECTORS.classNames.sort((e, t) => e.length < t.length ? -1 : e.length > t.length ? 1 : 0), 
  SELECTORS;
}, SELECTORS = {
  all: [],
  tags: [],
  classNames: [],
  ids: [],
  attrs: []
}, serializeCssVisitNode = (e, t, r, s) => {
  const n = t.type;
  return "declaration" === n ? serializeCssDeclaration(t, r, s) : "rule" === n ? serializeCssRule(e, t) : "comment" === n ? "!" === t.comment[0] ? `/*${t.comment}*/` : "" : "media" === n ? serializeCssMedia(e, t) : "keyframes" === n ? serializeCssKeyframes(e, t) : "keyframe" === n ? serializeCssKeyframe(e, t) : "font-face" === n ? serializeCssFontFace(e, t) : "supports" === n ? serializeCssSupports(e, t) : "import" === n ? "@import " + t.import + ";" : "charset" === n ? "@charset " + t.charset + ";" : "page" === n ? serializeCssPage(e, t) : "host" === n ? "@host{" + serializeCssMapVisit(e, t.rules) + "}" : "custom-media" === n ? "@custom-media " + t.name + " " + t.media + ";" : "document" === n ? serializeCssDocument(e, t) : "namespace" === n ? "@namespace " + t.namespace + ";" : "";
}, serializeCssRule = (e, t) => {
  const r = t.declarations, s = e.usedSelectors, n = t.selectors.slice();
  if (null == r || 0 === r.length) return "";
  if (s) {
    let t, r, o = !0;
    for (t = n.length - 1; t >= 0; t--) {
      const i = getCssSelectors(n[t]);
      o = !0;
      let a = i.classNames.length;
      if (a > 0 && e.hasUsedClassNames) for (r = 0; r < a; r++) if (!s.classNames.has(i.classNames[r])) {
        o = !1;
        break;
      }
      if (o && e.hasUsedTags && (a = i.tags.length, a > 0)) for (r = 0; r < a; r++) if (!s.tags.has(i.tags[r])) {
        o = !1;
        break;
      }
      if (o && e.hasUsedAttrs && (a = i.attrs.length, a > 0)) for (r = 0; r < a; r++) if (!s.attrs.has(i.attrs[r])) {
        o = !1;
        break;
      }
      if (o && e.hasUsedIds && (a = i.ids.length, a > 0)) for (r = 0; r < a; r++) if (!s.ids.has(i.ids[r])) {
        o = !1;
        break;
      }
      o || n.splice(t, 1);
    }
  }
  if (0 === n.length) return "";
  const o = [];
  let i = "";
  for (const e of t.selectors) i = removeSelectorWhitespace(e), o.includes(i) || o.push(i);
  return `${o}{${serializeCssMapVisit(e, r)}}`;
}, serializeCssDeclaration = (e, t, r) => "" === e.value ? "" : r - 1 === t ? e.property + ":" + e.value : e.property + ":" + e.value + ";", serializeCssMedia = (e, t) => {
  const r = serializeCssMapVisit(e, t.rules);
  return "" === r ? "" : "@media " + removeMediaWhitespace(t.media) + "{" + r + "}";
}, serializeCssKeyframes = (e, t) => {
  const r = serializeCssMapVisit(e, t.keyframes);
  return "" === r ? "" : "@" + (t.vendor || "") + "keyframes " + t.name + "{" + r + "}";
}, serializeCssKeyframe = (e, t) => t.values.join(",") + "{" + serializeCssMapVisit(e, t.declarations) + "}", serializeCssFontFace = (e, t) => {
  const r = serializeCssMapVisit(e, t.declarations);
  return "" === r ? "" : "@font-face{" + r + "}";
}, serializeCssSupports = (e, t) => {
  const r = serializeCssMapVisit(e, t.rules);
  return "" === r ? "" : "@supports " + t.supports + "{" + r + "}";
}, serializeCssPage = (e, t) => "@page " + t.selectors.join(", ") + "{" + serializeCssMapVisit(e, t.declarations) + "}", serializeCssDocument = (e, t) => {
  const r = serializeCssMapVisit(e, t.rules), s = "@" + (t.vendor || "") + "document " + t.document;
  return "" === r ? "" : s + "{" + r + "}";
}, serializeCssMapVisit = (e, t) => {
  let r = "";
  if (t) for (let s = 0, n = t.length; s < n; s++) r += serializeCssVisitNode(e, t[s], s, n);
  return r;
}, removeSelectorWhitespace = e => {
  let t = "", r = "", s = !1;
  for (let n = 0, o = (e = e.trim()).length; n < o; n++) if (r = e[n], "[" === r && "\\" !== t[t.length - 1] ? s = !0 : "]" === r && "\\" !== t[t.length - 1] && (s = !1), 
  !s && CSS_WS_REG.test(r)) {
    if (CSS_NEXT_CHAR_REG.test(e[n + 1])) continue;
    if (CSS_PREV_CHAR_REG.test(t[t.length - 1])) continue;
    t += " ";
  } else t += r;
  return t;
}, removeMediaWhitespace = e => {
  let t = "", r = "";
  for (let s = 0, n = (e = e.trim()).length; s < n; s++) if (r = e[s], CSS_WS_REG.test(r)) {
    if (CSS_WS_REG.test(t[t.length - 1])) continue;
    t += " ";
  } else t += r;
  return t;
}, CSS_WS_REG = /\s/, CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/, CSS_PREV_CHAR_REG = /[>\(\~\,\+]/, removeUnusedStyleText = (e, t, r) => {
  try {
    const s = parseCss(r.innerHTML);
    if (t.push(...s.diagnostics), hasError(t)) return;
    try {
      r.innerHTML = ((e, t) => {
        const r = t.usedSelectors || null, s = {
          usedSelectors: r || null,
          hasUsedAttrs: !!r && r.attrs.size > 0,
          hasUsedClassNames: !!r && r.classNames.size > 0,
          hasUsedIds: !!r && r.ids.size > 0,
          hasUsedTags: !!r && r.tags.size > 0
        }, n = e.rules;
        if (!n) return "";
        const o = n.length, i = [];
        for (let e = 0; e < o; e++) i.push(serializeCssVisitNode(s, n[e], e, o));
        return i.join("");
      })(s.stylesheet, {
        usedSelectors: e
      });
    } catch (e) {
      t.push({
        level: "warn",
        type: "css",
        header: "CSS Stringify",
        messageText: e
      });
    }
  } catch (e) {
    t.push({
      level: "warn",
      type: "css",
      header: "CSS Parse",
      messageText: e
    });
  }
};

export { createWindowFromHtml, hydrateDocument, renderToString, serializeDocumentToString };